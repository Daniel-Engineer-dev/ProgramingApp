[
  {
    "id": "two-sum",
    "title": "Two Sum",
    "acceptance": 0.568255927572189,
    "difficulty": "Easy",
    "likes": 66645,
    "dislikes": 2480,
    "stars": null,
    "tags": [
      "array",
      "hash-table"
    ],
    "description": "Cho một mảng của các số nguyên nums và một số nguyên target, trả về các chỉ số của hai các số Sao cho họ cộng ra để target. Bạn có thể giả sử rằng each đầu vào sẽ có chính xác một lời giải, và Bạn không được dùng giống nhau phần tử hai lần. Bạn có thể trả về đáp án Theo bất kỳ thứ tự nào.",
    "constraints": [
      "2 <= nums.length <= 104",
      "-109 <= nums[i] <= 109",
      "-109 <= target <= 109",
      "Chỉ một hợp lệ đáp án tồn tại. Câu hỏi thêm: Bạn có thể đưa ra một thuật toán đó là nhỏ hơn O(n2) thời gian độ phức tạp?"
    ],
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Vì nums[0] + nums[1] == 9, chúng ta trả về [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]",
        "explanation": ""
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]",
        "explanation": ""
      }
    ],
    "content": "Một really vét cạn vét cạn way sẽ là để tìm kiếm cho tất cả có thể các cặp của các số but đó sẽ là too chậm. Again, it's tốt nhất để Hãy thử out vét cạn vét cạn các lời giải chỉ cho completeness. Nó là từ những vét cạn vét cạn các lời giải đó Bạn có thể đưa ra optimizations. Vì vậy, nếu chúng ta fix một của các số, say <code>x</code>, chúng ta có để scan toàn bộ mảng để tìm next số <code>y</code> nào là <code>value - x</code> ở đâu giá trị là đầu vào parameter. Chúng ta có thể change our mảng somehow vì vậy đó điều này tìm kiếm becomes faster? thứ hai train của thought là, không changing mảng, Chúng ta có thể dùng additional bộ nhớ somehow? Like maybe một băm bản đồ để speed ra tìm kiếm?",
    "defaultCode": {
      "cpp": "class Solution { public: vector<int> twoSum(vector<int>& nums, int target) { } };",
      "java": "class Solution { public int[] twoSum(int[] nums, int target) { } }",
      "javascript": "/** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { };",
      "python": "class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:04 PM UTC+7",
    "editorial": {
      "content": "Bài toán yêu cầu tìm hai chỉ số i, j (i ≠ j) sao cho nums[i] + nums[j] = target.\nTa có thể làm brute force O(n^2), nhưng có cách tối ưu hơn bằng hash map hoặc bằng cách sắp xếp rồi dùng two pointers.",
      "lastUpdated": "January 13, 2026 at 3:39:04 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dùng Hash Map (One-pass)",
          "description": "Duyệt mảng đúng 1 lần. Với mỗi phần tử x tại i, kiểm tra trong map xem đã có (target - x) chưa.\nNếu có, trả về [index_of(target-x), i]. Nếu chưa, lưu map[x] = i.",
          "timeComplexity": "$O(n)$ trung bình (phụ thuộc hash)",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> mp; // value -> index\n        for (int i = 0; i < (int)nums.size(); i++) {\n            int need = target - nums[i];\n            auto it = mp.find(need);\n            if (it != mp.end()) return {it->second, i};\n            mp[nums[i]] = i;\n        }\n        return {}; // theo đề luôn có 1 đáp án hợp lệ\n    }\n};",
            "java": "import java.util.*;\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> mp = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int need = target - nums[i];\n            if (mp.containsKey(need)) {\n                return new int[]{mp.get(need), i};\n            }\n            mp.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}",
            "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n  const mp = new Map(); // value -> index\n  for (let i = 0; i < nums.length; i++) {\n    const need = target - nums[i];\n    if (mp.has(need)) return [mp.get(need), i];\n    mp.set(nums[i], i);\n  }\n  return [];\n};",
            "python": "from typing import List\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        mp = {}  # value -> index\n        for i, x in enumerate(nums):\n            need = target - x\n            if need in mp:\n                return [mp[need], i]\n            mp[x] = i\n        return []"
          }
        },
        {
          "name": "Sort + Two Pointers",
          "description": "Tạo danh sách (value, index), sort theo value. Dùng 2 con trỏ l=0, r=n-1:\n- Nếu a[l].value + a[r].value < target: tăng l\n- Nếu > target: giảm r\n- Nếu == target: trả về 2 chỉ số gốc.",
          "timeComplexity": "$O(n\\log n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<pair<int,int>> a;\n        a.reserve(nums.size());\n        for (int i = 0; i < (int)nums.size(); i++) a.push_back({nums[i], i});\n        sort(a.begin(), a.end());\n        int l = 0, r = (int)a.size() - 1;\n        while (l < r) {\n            long long sum = (long long)a[l].first + a[r].first;\n            if (sum == target) return {a[l].second, a[r].second};\n            if (sum < target) l++;\n            else r--;\n        }\n        return {};\n    }\n};",
            "java": "import java.util.*;\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        int[][] a = new int[n][2]; // [value, index]\n        for (int i = 0; i < n; i++) {\n            a[i][0] = nums[i];\n            a[i][1] = i;\n        }\n        Arrays.sort(a, (x, y) -> Integer.compare(x[0], y[0]));\n        int l = 0, r = n - 1;\n        while (l < r) {\n            long sum = (long)a[l][0] + a[r][0];\n            if (sum == target) return new int[]{a[l][1], a[r][1]};\n            if (sum < target) l++;\n            else r--;\n        }\n        return new int[0];\n    }\n}",
            "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n  const a = nums.map((v, i) => [v, i]);\n  a.sort((x, y) => x[0] - y[0]);\n  let l = 0, r = a.length - 1;\n  while (l < r) {\n    const sum = a[l][0] + a[r][0];\n    if (sum === target) return [a[l][1], a[r][1]];\n    if (sum < target) l++;\n    else r--;\n  }\n  return [];\n};",
            "python": "from typing import List\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        a = sorted([(v, i) for i, v in enumerate(nums)])\n        l, r = 0, len(a) - 1\n        while l < r:\n            s = a[l][0] + a[r][0]\n            if s == target:\n                return [a[l][1], a[r][1]]\n            if s < target:\n                l += 1\n            else:\n                r -= 1\n        return []"
          }
        }
      ]
    }
  },
  {
    "id": "add-two-numbers",
    "title": "Add Two Numbers",
    "acceptance": 0.47638754216999957,
    "difficulty": "Medium",
    "likes": 35882,
    "dislikes": 7119,
    "stars": null,
    "tags": [
      "linked-list",
      "math",
      "recursion"
    ],
    "description": "Bạn được cho hai không rỗng liên kết các danh sách biểu diễn hai không âm các số nguyên. các chữ số là được lưu trong đảo ngược thứ tự, và each của their các nút chứa một một chữ số. Cộng hai các số và trả về tổng như một danh sách liên kết. Bạn có thể giả sử hai các số làm không chứa bất kỳ ở đầu 0, ngoại trừ số 0 chính nó.",
    "constraints": [
      "số của các nút trong each danh sách liên kết là Trong khoảng [1, 100].",
      "0 <= Node.val <= 9",
      "Đảm bảo rằng danh sách biểu diễn một số đó không có ở đầu các số 0."
    ],
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": ""
      },
      {
        "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
        "output": "[8,9,9,9,0,0,0,1]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: Optional[ListNode] :type l2: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:05 PM UTC+7",
    "editorial": {
      "content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
      "lastUpdated": "January 13, 2026 at 3:39:05 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers trên Linked List",
          "description": "Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: Optional[ListNode] :type l2: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "longest-substring-without-repeating-characters",
    "title": "Longest Substring Without Repeating Characters",
    "acceptance": 0.38199168080295054,
    "difficulty": "Medium",
    "likes": 44052,
    "dislikes": 2159,
    "stars": null,
    "tags": [
      "hash-table",
      "string",
      "sliding-window"
    ],
    "description": "Cho một chuỗi s, tìm độ dài của dài nhất chuỗi con không trùng lặp các ký tự.",
    "constraints": [
      "0 <= s.length <= 5 * 104 s Gồm Tiếng Anh các chữ cái, các chữ số, các ký hiệu và dấu cách."
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "Đáp án là \"abc\", với độ dài của 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "Đáp án là \"b\", với độ dài của 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "Đáp án là \"wke\", với độ dài của 3. Lưu ý rằng đáp án phải là một chuỗi con, \"pwke\" là một dãy con và không một chuỗi con."
      }
    ],
    "content": "Generate tất cả có thể chuỗi con & kiểm tra cho each chuỗi con nếu nó's hợp lệ và giữ updating maxLen accordingly.",
    "defaultCode": {
      "cpp": "class Solution { public: int lengthOfLongestSubstring(string s) { } };",
      "java": "class Solution { public int lengthOfLongestSubstring(String s) { } }",
      "javascript": "/** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(s) { };",
      "python": "class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:05 PM UTC+7",
    "editorial": {
      "content": "Given a string s, find the length of the longest substring without duplicate characters.\n\nHint/nhắc ý (crawl được): Generate all possible substrings & check for each substring if it's valid and keep updating maxLen accordingly.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:05 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: int lengthOfLongestSubstring(string s) { } };",
            "java": "class Solution { public int lengthOfLongestSubstring(String s) { } }",
            "javascript": "/** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(s) { };",
            "python": "class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "median-of-two-sorted-arrays",
    "title": "Median of Two Sorted Arrays",
    "acceptance": 0.45566991520270456,
    "difficulty": "Hard",
    "likes": 31541,
    "dislikes": 3533,
    "stars": null,
    "tags": [
      "array",
      "binary-search",
      "divide-and-conquer"
    ],
    "description": "Cho hai đã sắp xếp các mảng nums1 và nums2 của kích thước m và n tương ứng, trả về median của hai đã sắp xếp các mảng. overall run thời gian độ phức tạp nên là O(log (m+n)).",
    "constraints": [
      "nums1.length == m nums2.length == n",
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "-106 <= nums1[i], nums2[i] <= 106"
    ],
    "examples": [
      {
        "input": "nums1 = [1,3], nums2 = [2]",
        "output": "2.00000",
        "explanation": "merged mảng = [1,2,3] và median là 2."
      },
      {
        "input": "nums1 = [1,2], nums2 = [3,4]",
        "output": "2.50000",
        "explanation": "merged mảng = [1,2,3,4] và median là (2 + 3) / 2 = 2.5."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) { } };",
      "java": "class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { } }",
      "javascript": "/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */ var findMedianSortedArrays = function(nums1, nums2) { };",
      "python": "class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:06 PM UTC+7",
    "editorial": {
      "content": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n\nGợi ý hướng giải: Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer). Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả.",
      "lastUpdated": "January 13, 2026 at 3:39:06 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Binary Search",
          "description": "Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
          "timeComplexity": "$O(\\log n)$ hoặc $O(n\\log M)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) { } };",
            "java": "class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { } }",
            "javascript": "/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */ var findMedianSortedArrays = function(nums1, nums2) { };",
            "python": "class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "longest-palindromic-substring",
    "title": "Longest Palindromic Substring",
    "acceptance": 0.37039269777846096,
    "difficulty": "Medium",
    "likes": 32084,
    "dislikes": 1975,
    "stars": null,
    "tags": [
      "two-pointers",
      "string",
      "dynamic-programming"
    ],
    "description": "Cho một chuỗi s, trả về dài nhất palindromic chuỗi con trong s.",
    "constraints": [
      "1 <= s.length <= 1000 s consist của chỉ các chữ số và Tiếng Anh các chữ cái."
    ],
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "\"aba\" là cũng một hợp lệ đáp án."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "\"bb\"",
        "explanation": ""
      }
    ],
    "content": "Làm thế nào chúng ta có thể tái sử dụng một trước đó đã tính đối xứng để tính một lớn hơn đối xứng? Nếu “aba” là một đối xứng, là “xabax” một đối xứng? Similarly là “xabay” một đối xứng? Độ phức tạp dựa trên gợi ý:</br> Nếu chúng ta dùng vét cạn-vét cạn và kiểm tra liệu cho mỗi bắt đầu và kết thúc vị trí một chuỗi con là một đối xứng chúng ta có O(n^2) bắt đầu - kết thúc các cặp và O(n) palindromic kiểm tra. Chúng ta có thể reduce thời gian cho palindromic kiểm tra để O(1) bởi reusing một số previous computation.",
    "defaultCode": {
      "cpp": "class Solution { public: string longestPalindrome(string s) { } };",
      "java": "class Solution { public String longestPalindrome(String s) { } }",
      "javascript": "/** * @param {string} s * @return {string} */ var longestPalindrome = function(s) { };",
      "python": "class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:06 PM UTC+7",
    "editorial": {
      "content": "Given a string s, return the longest palindromic substring in s.\n\nHint/nhắc ý (crawl được): How can we reuse a previously computed palindrome to compute a larger palindrome? If “aba” is a palindrome, is “xabax” a palindrome? Similarly is “xabay” a palindrome? Complexity based hint:</br> If we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:06 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: string longestPalindrome(string s) { } };",
            "java": "class Solution { public String longestPalindrome(String s) { } }",
            "javascript": "/** * @param {string} s * @return {string} */ var longestPalindrome = function(s) { };",
            "python": "class Solution(object): def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "zigzag-conversion",
    "title": "Zigzag Conversion",
    "acceptance": 0.532063770727817,
    "difficulty": "Medium",
    "likes": 9125,
    "dislikes": 15780,
    "stars": null,
    "tags": [
      "string"
    ],
    "description": "chuỗi \"PAYPALISHIRING\" là written trong một zigzag mẫu trên một cho số của các hàng like điều này: (bạn có thể want để display điều này mẫu trong một fixed font cho better legibility) P Một H N Một P L S I I G Y I R Và thì đọc đường thẳng bởi đường thẳng: \"PAHNAPLSIIGYIR\" Viết code đó sẽ take một chuỗi và tạo điều này conversion cho một số của các hàng: chuỗi chuyển đổi(chuỗi s, int numRows);",
    "constraints": [
      "1 <= s.length <= 1000 s Gồm Tiếng Anh các chữ cái (chữ thường và chữ hoa), ',' và '.'.",
      "1 <= numRows <= 1000"
    ],
    "examples": [
      {
        "input": "s = \"PAYPALISHIRING\", numRows = 3",
        "output": "\"PAHNAPLSIIGYIR\"",
        "explanation": ""
      },
      {
        "input": "s = \"PAYPALISHIRING\", numRows = 4",
        "output": "\"PINALSIGYAHRPI\"",
        "explanation": "P I N Một L S I G Y Một H R P I"
      },
      {
        "input": "s = \"A\", numRows = 1",
        "output": "\"A\"",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: string convert(string s, int numRows) { } };",
      "java": "class Solution { public String convert(String s, int numRows) { } }",
      "javascript": "/** * @param {string} s * @param {number} numRows * @return {string} */ var convert = function(s, numRows) { };",
      "python": "class Solution(object): def convert(self, s, numRows): \"\"\" :type s: str :type numRows: int :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:07 PM UTC+7",
    "editorial": {
      "content": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows);\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:07 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "String Processing",
          "description": "Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(n)$",
          "code": {
            "cpp": "class Solution { public: string convert(string s, int numRows) { } };",
            "java": "class Solution { public String convert(String s, int numRows) { } }",
            "javascript": "/** * @param {string} s * @param {number} numRows * @return {string} */ var convert = function(s, numRows) { };",
            "python": "class Solution(object): def convert(self, s, numRows): \"\"\" :type s: str :type numRows: int :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "reverse-integer",
    "title": "Reverse Integer",
    "acceptance": 0.312907672065629,
    "difficulty": "Medium",
    "likes": 15124,
    "dislikes": 13946,
    "stars": null,
    "tags": [
      "math"
    ],
    "description": "Cho một có dấu 32-bit số nguyên x, trả về x với nó các chữ số được đảo ngược. Nếu reversing x causes giá trị để go bên ngoài có dấu 32-bit số nguyên khoảng [-231, 231 - 1], thì trả về 0. Giả sử environment không allow bạn để lưu 64-bit các số nguyên (có dấu hoặc không dấu).",
    "constraints": [
      "-231 <= x <= 231 - 1"
    ],
    "examples": [
      {
        "input": "x = 123",
        "output": "321",
        "explanation": ""
      },
      {
        "input": "x = -123",
        "output": "-321",
        "explanation": ""
      },
      {
        "input": "x = 120",
        "output": "21",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int reverse(int x) { } };",
      "java": "class Solution { public int reverse(int x) { } }",
      "javascript": "/** * @param {number} x * @return {number} */ var reverse = function(x) { };",
      "python": "class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:09 PM UTC+7",
    "editorial": {
      "content": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
      "lastUpdated": "January 13, 2026 at 3:39:09 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Math / Simulation",
          "description": "Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int reverse(int x) { } };",
            "java": "class Solution { public int reverse(int x) { } }",
            "javascript": "/** * @param {number} x * @return {number} */ var reverse = function(x) { };",
            "python": "class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "string-to-integer-atoi",
    "title": "String to Integer (atoi)",
    "acceptance": 0.20344055662066332,
    "difficulty": "Medium",
    "likes": 5991,
    "dislikes": 15381,
    "stars": null,
    "tags": [
      "string"
    ],
    "description": "Cài đặt myAtoi(chuỗi s) hàm, nào chuyển đổi một chuỗi để một 32-bit có dấu số nguyên. thuật toán cho myAtoi(chuỗi s) là như theo: Khoảng trắng: Bỏ qua bất kỳ ở đầu khoảng trắng (\" \"). Dấu: Xác định dấu bởi kiểm tra nếu next ký tự là '-' hoặc '+', assuming positivity nếu neither present. Conversion: Đọc số nguyên bởi skipping ở đầu các số 0 cho đến khi một không-chữ số ký tự là encountered hoặc kết thúc của chuỗi là reached. Nếu không các chữ số là đọc, thì Kết quả là 0. Làm tròn: Nếu số nguyên là out của 32-bit có dấu số nguyên khoảng [-231, 231 - 1], thì làm tròn số nguyên để remain Trong khoảng. Specifically, các số nguyên nhỏ hơn -231 nên là làm tròn để -231, và các số nguyên lớn hơn 231 - 1 nên là làm tròn để 231 - 1. Trả về số nguyên như final kết quả.",
    "constraints": [
      "0 <= s.length <= 200 s Gồm Tiếng Anh các chữ cái (chữ thường và chữ hoa), các chữ số (0-9), ' ', '+', '-', và '.'."
    ],
    "examples": [
      {
        "input": "s = \"42\"",
        "output": "42",
        "explanation": "được gạch chân các ký tự là điều gì là đọc trong và dấu mũ là hiện tại bộ đọc vị trí. Bước 1: \"42\" (không các ký tự đọc vì Có không ở đầu khoảng trắng) ^ Bước 2: \"42\" (không các ký tự đọc vì Có neither một '-' nor '+') ^ Bước 3: \"42\" (\"42\" là đọc trong) ^"
      },
      {
        "input": "s = \" -042\"",
        "output": "-42",
        "explanation": "Bước 1: \" -042\" (ở đầu khoảng trắng là đọc và ignored) ^ Bước 2: \" -042\" ('-' là đọc, vì vậy kết quả nên là âm) ^ Bước 3: \" -042\" (\"042\" là đọc trong, ở đầu các số 0 ignored trong kết quả) ^"
      },
      {
        "input": "s = \"1337c0d3\"",
        "output": "1337",
        "explanation": "Bước 1: \"1337c0d3\" (không các ký tự đọc vì Có không ở đầu khoảng trắng) ^ Bước 2: \"1337c0d3\" (không các ký tự đọc vì Có neither một '-' nor '+') ^ Bước 3: \"1337c0d3\" (\"1337\" là đọc trong; đọc dừng vì next ký tự là một không-chữ số) ^"
      },
      {
        "input": "s = \"0-1\"",
        "output": "0",
        "explanation": "Bước 1: \"0-1\" (không các ký tự đọc vì Có không ở đầu khoảng trắng) ^ Bước 2: \"0-1\" (không các ký tự đọc vì Có neither một '-' nor '+') ^ Bước 3: \"0-1\" (\"0\" là đọc trong; đọc dừng vì next ký tự là một không-chữ số) ^"
      },
      {
        "input": "s = \"words and 987\"",
        "output": "0",
        "explanation": "Đọc dừng tại đầu tiên không-chữ số ký tự 'w'."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int myAtoi(string s) { } };",
      "java": "class Solution { public int myAtoi(String s) { } }",
      "javascript": "/** * @param {string} s * @return {number} */ var myAtoi = function(s) { };",
      "python": "class Solution(object): def myAtoi(self, s): \"\"\" :type s: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:10 PM UTC+7",
    "editorial": {
      "content": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer. The algorithm for myAtoi(string s) is as follows: Whitespace: Ignore any leading whitespace (\" \"). Signedness: Determine the sign by checking if the next character is '-' or '+', assuming positivity if neither present. Conversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0. Rounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1. Return the integer as the final result.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:10 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "String Processing",
          "description": "Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(n)$",
          "code": {
            "cpp": "class Solution { public: int myAtoi(string s) { } };",
            "java": "class Solution { public int myAtoi(String s) { } }",
            "javascript": "/** * @param {string} s * @return {number} */ var myAtoi = function(s) { };",
            "python": "class Solution(object): def myAtoi(self, s): \"\"\" :type s: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "palindrome-number",
    "title": "Palindrome Number",
    "acceptance": 0.6007898220348802,
    "difficulty": "Easy",
    "likes": 15383,
    "dislikes": 2901,
    "stars": null,
    "tags": [
      "math"
    ],
    "description": "Cho một số nguyên x, trả về đúng nếu x là một đối xứng, và sai otherwise.",
    "constraints": [
      "-231 <= x <= 231 - 1 Câu hỏi thêm: Bạn có thể solve nó không chuyển đổi số nguyên để một chuỗi?"
    ],
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 đọc như 121 từ left để right và từ right để left."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "Từ left để right, nó đọc -121. Từ right để left, nó becomes 121-. Do đó nó là không một đối xứng."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "Đọc 01 từ right để left. Do đó nó là không một đối xứng."
      }
    ],
    "content": "Beware của overflow khi nào bạn đảo ngược số nguyên.",
    "defaultCode": {
      "cpp": "class Solution { public: bool isPalindrome(int x) { } };",
      "java": "class Solution { public boolean isPalindrome(int x) { } }",
      "javascript": "/** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { };",
      "python": "class Solution(object): def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:10 PM UTC+7",
    "editorial": {
      "content": "Given an integer x, return true if x is a palindrome, and false otherwise.\n\nHint/nhắc ý (crawl được): Beware of overflow when you reverse the integer.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
      "lastUpdated": "January 13, 2026 at 3:39:10 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Math / Simulation",
          "description": "Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: bool isPalindrome(int x) { } };",
            "java": "class Solution { public boolean isPalindrome(int x) { } }",
            "javascript": "/** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { };",
            "python": "class Solution(object): def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "regular-expression-matching",
    "title": "Regular Expression Matching",
    "acceptance": 0.30209683883526706,
    "difficulty": "Hard",
    "likes": 13166,
    "dislikes": 2371,
    "stars": null,
    "tags": [
      "string",
      "dynamic-programming",
      "recursion"
    ],
    "description": "Cho một đầu vào chuỗi s và một mẫu p, cài đặt khớp biểu thức chính quy với support cho '.' và '*' ở đâu: '.' Khớp bất kỳ một ký tự. '*' Khớp 0 hoặc nhiều hơn của đứng trước phần tử. khớp nên bao phủ toàn bộ đầu vào chuỗi (không một phần).",
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= p.length <= 20",
      "s Chỉ chứa chữ thường Tiếng Anh các chữ cái.",
      "p Chỉ chứa chữ thường Tiếng Anh các chữ cái, '.', và '*'.",
      "Đảm bảo cho each appearance của ký tự '*', có sẽ là một previous hợp lệ ký tự để khớp."
    ],
    "examples": [
      {
        "input": "s = \"aa\", p = \"a\"",
        "output": "false",
        "explanation": "\"a\" không khớp toàn bộ chuỗi \"aa\"."
      },
      {
        "input": "s = \"aa\", p = \"a*\"",
        "output": "true",
        "explanation": "'*' means 0 hoặc nhiều hơn của đứng trước phần tử, 'một'. Do đó, bởi repeating 'một' một lần, nó becomes \"aa\"."
      },
      {
        "input": "s = \"ab\", p = \".*\"",
        "output": "true",
        "explanation": "\".*\" means \"zero or more (*) of any character (.)\"."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool isMatch(string s, string p) { } };",
      "java": "class Solution { public boolean isMatch(String s, String p) { } }",
      "javascript": "/** * @param {string} s * @param {string} p * @return {boolean} */ var isMatch = function(s, p) { };",
      "python": "class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:11 PM UTC+7",
    "editorial": {
      "content": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where: '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial).\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:39:11 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: bool isMatch(string s, string p) { } };",
            "java": "class Solution { public boolean isMatch(String s, String p) { } }",
            "javascript": "/** * @param {string} s * @param {string} p * @return {boolean} */ var isMatch = function(s, p) { };",
            "python": "class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "container-with-most-water",
    "title": "Container With Most Water",
    "acceptance": 0.5925182085166045,
    "difficulty": "Medium",
    "likes": 33423,
    "dislikes": 2149,
    "stars": null,
    "tags": [
      "array",
      "two-pointers",
      "greedy"
    ],
    "description": "Bạn được cho một số nguyên mảng height của độ dài n. Có n thẳng đứng các đường thẳng được vẽ Sao cho hai hai đầu mút của ith đường thẳng là (i, 0) và (i, height[i]). Tìm hai các đường thẳng đó cùng với x-trục tạo thành một bình chứa, Sao cho bình chứa chứa nhiều nhất nước. Trả về lớn nhất lượng của nước một bình chứa có thể lưu. Lưu ý rằng Bạn không được nghiêng bình chứa.",
    "constraints": [
      "n == height.length",
      "2 <= n <= 105",
      "0 <= height[i] <= 104"
    ],
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "bên trên thẳng đứng các đường thẳng là được biểu diễn bởi mảng [1,8,6,2,5,4,8,3,7]. Trong điều này trường hợp, lớn nhất area của nước (blue section) bình chứa có thể chứa là 49."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": ""
      }
    ],
    "content": "Nếu bạn simulate problem, nó sẽ là O(n^2) nào là không hiệu quả. Hãy thử dùng hai-các con trỏ. Tập hợp một con trỏ để left và một để right của mảng. Always di chuyển con trỏ đó points để lower đường thẳng. Làm thế nào bạn có thể tính lượng của nước tại each bước?",
    "defaultCode": {
      "cpp": "class Solution { public: int maxArea(vector<int>& height) { } };",
      "java": "class Solution { public int maxArea(int[] height) { } }",
      "javascript": "/** * @param {number[]} height * @return {number} */ var maxArea = function(height) { };",
      "python": "class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:12 PM UTC+7",
    "editorial": {
      "content": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container.\n\nHint/nhắc ý (crawl được): If you simulate the problem, it will be O(n^2) which is not efficient. Try to use two-pointers. Set one pointer to the left and one to the right of the array. Always move the pointer that points to the lower line. How can you calculate the amount of water at each step?\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Chọn quyết định cục bộ tối ưu và chứng minh rằng nó dẫn tới tối ưu toàn cục.",
      "lastUpdated": "January 13, 2026 at 3:39:12 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int maxArea(vector<int>& height) { } };",
            "java": "class Solution { public int maxArea(int[] height) { } }",
            "javascript": "/** * @param {number[]} height * @return {number} */ var maxArea = function(height) { };",
            "python": "class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "integer-to-roman",
    "title": "Integer to Roman",
    "acceptance": 0.7013604293794907,
    "difficulty": "Medium",
    "likes": 8373,
    "dislikes": 5708,
    "stars": null,
    "tags": [
      "hash-table",
      "math",
      "string"
    ],
    "description": "Bảy khác nhau các ký hiệu biểu diễn Roman numerals với sau đây các giá trị: Ký hiệu Giá trị I 1 V 5 X 10 L 50 C 100 D 500 M 1000 Roman numerals là tạo thành bởi appending conversions của decimal place các giá trị từ cao nhất để lowest. Chuyển đổi một decimal place giá trị thành một Roman numeral có sau đây rules: Nếu giá trị không bắt đầu với 4 hoặc 9, chọn ký hiệu của maximal giá trị đó có thể là trừ từ đầu vào, append đó ký hiệu để kết quả, trừ nó giá trị, và chuyển đổi remainder để một Roman numeral. Nếu giá trị bắt đầu với 4 hoặc 9 dùng subtractive tạo thành biểu diễn một ký hiệu trừ từ sau đây ký hiệu, Ví dụ, 4 là 1 (I) nhỏ hơn 5 (V): IV và 9 là 1 (I) nhỏ hơn 10 (X): IX. Chỉ sau đây subtractive tạo thành là được dùng: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) và 900 (CM). Chỉ powers của 10 (I, X, C, M) có thể là appended consecutively Nhiều nhất 3 lần để biểu diễn nhiều của 10. Bạn không thể append 5 (V), 50 (L), hoặc 500 (D) nhiều lần. Nếu bạn need để append một ký hiệu 4 lần dùng subtractive tạo thành. Cho một số nguyên, chuyển đổi nó để một Roman numeral.",
    "constraints": [
      "1 <= num <= 3999"
    ],
    "examples": [
      {
        "input": "num = 3749",
        "output": "\"MMMDCCXLIX\"",
        "explanation": "3000 = MMM như 1000 (M) + 1000 (M) + 1000 (M) 700 = DCC như 500 (D) + 100 (C) + 100 (C) 40 = XL như 10 (X) ít hơn của 50 (L) 9 = IX như 1 (I) ít hơn của 10 (X)"
      },
      {
        "input": "num = 58",
        "output": "\"LVIII\"",
        "explanation": "50 = L 8 = VIII"
      },
      {
        "input": "num = 1994",
        "output": "\"MCMXCIV\"",
        "explanation": "1000 = M 900 = CM 90 = XC 4 = IV"
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: string intToRoman(int num) { } };",
      "java": "class Solution { public String intToRoman(int num) { } }",
      "javascript": "/** * @param {number} num * @return {string} */ var intToRoman = function(num) { };",
      "python": "class Solution(object): def intToRoman(self, num): \"\"\" :type num: int :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:13 PM UTC+7",
    "editorial": {
      "content": "Seven different symbols represent Roman numerals with the following values: Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 Roman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules: If the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral. If the value starts with 4 or 9 use the subtractive form representing one symbol subtracted from the following symbol, for example, 4 is 1 (I) less than 5 (V): IV and 9 is 1 (I) less than 10 (X): IX. Only the following subtractive forms are used: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) and 900 (CM). Only powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (V), 50 (L), or 500 (D) multiple times. If you need to append a symbol 4 times use the subtractive form. Given an integer, convert it to a Roman numeral.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
      "lastUpdated": "January 13, 2026 at 3:39:13 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: string intToRoman(int num) { } };",
            "java": "class Solution { public String intToRoman(int num) { } }",
            "javascript": "/** * @param {number} num * @return {string} */ var intToRoman = function(num) { };",
            "python": "class Solution(object): def intToRoman(self, num): \"\"\" :type num: int :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "roman-to-integer",
    "title": "Roman to Integer",
    "acceptance": 0.6601494469132418,
    "difficulty": "Easy",
    "likes": 17238,
    "dislikes": 1195,
    "stars": null,
    "tags": [
      "hash-table",
      "math",
      "string"
    ],
    "description": "Roman numerals là được biểu diễn bởi bảy khác nhau các ký hiệu: I, V, X, L, C, D và M. Ký hiệu Giá trị I 1 V 5 X 10 L 50 C 100 D 500 M 1000 Ví dụ, 2 là written như II trong Roman numeral, chỉ hai trên cộng cùng. 12 là written như XII, nào là simply X + II. số 27 là written như XXVII, nào là XX + V + II. Roman numerals là usually written lớn nhất để nhỏ nhất từ left để right. However, numeral cho bốn là không IIII. Instead, số bốn là written như IV. Vì một là trước năm chúng ta trừ nó making bốn. giống nhau principle applies để số chín, nào là written như IX. Có sáu instances ở đâu subtraction là được dùng: I có thể là placed trước V (5) và X (10) để tạo 4 và 9. X có thể là placed trước L (50) và C (100) để tạo 40 và 90. C có thể là placed trước D (500) và M (1000) để tạo 400 và 900. Cho một roman numeral, chuyển đổi nó để một số nguyên.",
    "constraints": [
      "1 <= s.length <= 15",
      "s Chỉ chứa các ký tự ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
      "Đảm bảo rằng s là một hợp lệ roman numeral Trong khoảng [1, 3999]."
    ],
    "examples": [
      {
        "input": "s = \"III\"",
        "output": "3",
        "explanation": "III = 3."
      },
      {
        "input": "s = \"LVIII\"",
        "output": "58",
        "explanation": "L = 50, V= 5, III = 3."
      },
      {
        "input": "s = \"MCMXCIV\"",
        "output": "1994",
        "explanation": "M = 1000, CM = 900, XC = 90 và IV = 4."
      }
    ],
    "content": "Problem là simpler để solve bởi working chuỗi từ back để front và using một bản đồ.",
    "defaultCode": {
      "cpp": "class Solution { public: int romanToInt(string s) { } };",
      "java": "class Solution { public int romanToInt(String s) { } }",
      "javascript": "/** * @param {string} s * @return {number} */ var romanToInt = function(s) { };",
      "python": "class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:13 PM UTC+7",
    "editorial": {
      "content": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer.\n\nHint/nhắc ý (crawl được): Problem is simpler to solve by working the string from back to front and using a map.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
      "lastUpdated": "January 13, 2026 at 3:39:13 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: int romanToInt(string s) { } };",
            "java": "class Solution { public int romanToInt(String s) { } }",
            "javascript": "/** * @param {string} s * @return {number} */ var romanToInt = function(s) { };",
            "python": "class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "longest-common-prefix",
    "title": "Longest Common Prefix",
    "acceptance": 0.46812803363030864,
    "difficulty": "Easy",
    "likes": 20741,
    "dislikes": 4875,
    "stars": null,
    "tags": [
      "array",
      "string",
      "trie"
    ],
    "description": "Viết một hàm để tìm dài nhất common tiền tố chuỗi amongst một mảng của các chuỗi. Nếu Có không common tiền tố, trả về một rỗng chuỗi \"\".",
    "constraints": [
      "1 <= strs.length <= 200",
      "0 <= strs[i].độ dài <= 200 strs[i] Gồm chỉ chữ thường Tiếng Anh các chữ cái nếu nó là không rỗng."
    ],
    "examples": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\"",
        "explanation": ""
      },
      {
        "input": "strs = [\"dog\",\"racecar\",\"car\"]",
        "output": "\"\"",
        "explanation": "Có không common tiền tố trong số đầu vào các chuỗi."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: string longestCommonPrefix(vector<string>& strs) { } };",
      "java": "class Solution { public String longestCommonPrefix(String[] strs) { } }",
      "javascript": "/** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function(strs) { };",
      "python": "class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:14 PM UTC+7",
    "editorial": {
      "content": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng Trie để lưu chuỗi và truy vấn tiền tố (prefix) hiệu quả.",
      "lastUpdated": "January 13, 2026 at 3:39:14 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Trie",
          "description": "Dùng Trie để lưu chuỗi và truy vấn tiền tố (prefix) hiệu quả.",
          "timeComplexity": "$O(T)$ (T là tổng độ dài)",
          "spaceComplexity": "$O(T)$",
          "code": {
            "cpp": "class Solution { public: string longestCommonPrefix(vector<string>& strs) { } };",
            "java": "class Solution { public String longestCommonPrefix(String[] strs) { } }",
            "javascript": "/** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function(strs) { };",
            "python": "class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "3sum",
    "title": "3Sum",
    "acceptance": 0.38301122875463023,
    "difficulty": "Medium",
    "likes": 34819,
    "dislikes": 3236,
    "stars": null,
    "tags": [
      "array",
      "two-pointers",
      "sorting"
    ],
    "description": "Cho một số nguyên mảng nums, trả về tất cả các bộ ba [nums[i], nums[j], nums[k]] Sao cho i!= j, i!= k, và j!= k, và nums[i] + nums[j] + nums[k] == 0. Lưu ý rằng lời giải tập hợp phải không chứa trùng lặp các bộ ba.",
    "constraints": [
      "3 <= nums.length <= 3000",
      "-105 <= nums[i] <= 105"
    ],
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]",
        "explanation": "nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. phân biệt các bộ ba là [-1,0,1] và [-1,-1,2]. Lưu ý rằng thứ tự của đầu ra và thứ tự của các bộ ba không matter."
      },
      {
        "input": "nums = [0,1,1]",
        "output": "[]",
        "explanation": "chỉ có thể bộ ba không tổng ra để 0."
      },
      {
        "input": "nums = [0,0,0]",
        "output": "[[0,0,0]]",
        "explanation": "chỉ có thể bộ ba tổng ra để 0."
      }
    ],
    "content": "Vì vậy, chúng ta essentially need để tìm ba các số x, y, và z Sao cho họ cộng ra để cho giá trị. Nếu chúng ta fix một của các số say x, chúng ta là left với hai-tổng problem tại hand! Cho hai-tổng problem, nếu chúng ta fix một của các số, say x, chúng ta có để scan toàn bộ mảng để tìm next số y, nào là giá trị - x ở đâu giá trị là đầu vào parameter. Chúng ta có thể change our mảng somehow vì vậy đó điều này tìm kiếm becomes faster? thứ hai train của thought cho hai-tổng là, không changing mảng, Chúng ta có thể dùng additional bộ nhớ somehow? Like maybe một băm bản đồ để speed ra tìm kiếm?",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> threeSum(vector<int>& nums) { } };",
      "java": "class Solution { public List<List<Integer>> threeSum(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number[][]} */ var threeSum = function(nums) { };",
      "python": "class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:15 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.\n\nHint/nhắc ý (crawl được): So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand! For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster? The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
      "lastUpdated": "January 13, 2026 at 3:39:15 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> threeSum(vector<int>& nums) { } };",
            "java": "class Solution { public List<List<Integer>> threeSum(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number[][]} */ var threeSum = function(nums) { };",
            "python": "class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "3sum-closest",
    "title": "3Sum Closest",
    "acceptance": 0.4780199599769488,
    "difficulty": "Medium",
    "likes": 11447,
    "dislikes": 613,
    "stars": null,
    "tags": [
      "array",
      "two-pointers",
      "sorting"
    ],
    "description": "Cho một số nguyên mảng nums của độ dài n và một số nguyên target, tìm ba các số nguyên tại phân biệt các chỉ số trong nums Sao cho tổng là gần nhất để target. Trả về tổng của ba các số nguyên. Bạn có thể giả sử rằng each đầu vào sẽ có chính xác một lời giải.",
    "constraints": [
      "3 <= nums.length <= 500",
      "-1000 <= nums[i] <= 1000",
      "-104 <= target <= 104"
    ],
    "examples": [
      {
        "input": "nums = [-1,2,1,-4], target = 1",
        "output": "2",
        "explanation": "tổng đó là gần nhất để target là 2. (-1 + 2 + 1 = 2)."
      },
      {
        "input": "nums = [0,0,0], target = 1",
        "output": "0",
        "explanation": "tổng đó là gần nhất để target là 0. (0 + 0 + 0 = 0)."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int threeSumClosest(vector<int>& nums, int target) { } };",
      "java": "class Solution { public int threeSumClosest(int[] nums, int target) { } }",
      "javascript": "/** * @param {number[]} nums * @param {number} target * @return {number} */ var threeSumClosest = function(nums, target) { };",
      "python": "class Solution(object): def threeSumClosest(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:16 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums of length n and an integer target, find three integers at distinct indices in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
      "lastUpdated": "January 13, 2026 at 3:39:16 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int threeSumClosest(vector<int>& nums, int target) { } };",
            "java": "class Solution { public int threeSumClosest(int[] nums, int target) { } }",
            "javascript": "/** * @param {number[]} nums * @param {number} target * @return {number} */ var threeSumClosest = function(nums, target) { };",
            "python": "class Solution(object): def threeSumClosest(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "letter-combinations-of-a-phone-number",
    "title": "Letter Combinations of a Phone Number",
    "acceptance": 0.6520469344836687,
    "difficulty": "Medium",
    "likes": 20617,
    "dislikes": 1118,
    "stars": null,
    "tags": [
      "hash-table",
      "string",
      "backtracking"
    ],
    "description": "Cho một chuỗi chứa digits từ 2-9 inclusive, trả về tất cả có thể chữ cái các tổ hợp đó số có thể biểu diễn. Trả về đáp án Theo bất kỳ thứ tự nào. Một bản đồ của digits để các chữ cái (chỉ like trên telephone buttons) là cho bên dưới. Lưu ý rằng 1 không bản đồ để bất kỳ các chữ cái.",
    "constraints": [
      "1 <= digits.length <= 4 digits[i] là một chữ số Trong khoảng ['2', '9']."
    ],
    "examples": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "explanation": ""
      },
      {
        "input": "digits = \"2\"",
        "output": "[\"a\",\"b\",\"c\"]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<string> letterCombinations(string digits) { } };",
      "java": "class Solution { public List<String> letterCombinations(String digits) { } }",
      "javascript": "/** * @param {string} digits * @return {string[]} */ var letterCombinations = function(digits) { };",
      "python": "class Solution(object): def letterCombinations(self, digits): \"\"\" :type digits: str :rtype: List[str] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:16 PM UTC+7",
    "editorial": {
      "content": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:16 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: vector<string> letterCombinations(string digits) { } };",
            "java": "class Solution { public List<String> letterCombinations(String digits) { } }",
            "javascript": "/** * @param {string} digits * @return {string[]} */ var letterCombinations = function(digits) { };",
            "python": "class Solution(object): def letterCombinations(self, digits): \"\"\" :type digits: str :rtype: List[str] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "4sum",
    "title": "4Sum",
    "acceptance": 0.39657146580894304,
    "difficulty": "Medium",
    "likes": 12656,
    "dislikes": 1525,
    "stars": null,
    "tags": [
      "array",
      "two-pointers",
      "sorting"
    ],
    "description": "Cho một mảng nums của n các số nguyên, trả về một mảng của tất cả không trùng lặp quadruplets [nums[một], nums[b], nums[c], nums[d]] Sao cho: 0 <= một, b, c, d < n một, b, c, và d là phân biệt. nums[một] + nums[b] + nums[c] + nums[d] == target Bạn có thể trả về đáp án Theo bất kỳ thứ tự nào.",
    "constraints": [
      "1 <= nums.length <= 200",
      "-109 <= nums[i] <= 109",
      "-109 <= target <= 109"
    ],
    "examples": [
      {
        "input": "nums = [1,0,-1,0,-2,2], target = 0",
        "output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
        "explanation": ""
      },
      {
        "input": "nums = [2,2,2,2,2], target = 8",
        "output": "[[2,2,2,2]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> fourSum(vector<int>& nums, int target) { } };",
      "java": "class Solution { public List<List<Integer>> fourSum(int[] nums, int target) { } }",
      "javascript": "/** * @param {number[]} nums * @param {number} target * @return {number[][]} */ var fourSum = function(nums, target) { };",
      "python": "class Solution(object): def fourSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:17 PM UTC+7",
    "editorial": {
      "content": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 0 <= a, b, c, d < n a, b, c, and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
      "lastUpdated": "January 13, 2026 at 3:39:17 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> fourSum(vector<int>& nums, int target) { } };",
            "java": "class Solution { public List<List<Integer>> fourSum(int[] nums, int target) { } }",
            "javascript": "/** * @param {number[]} nums * @param {number} target * @return {number[][]} */ var fourSum = function(nums, target) { };",
            "python": "class Solution(object): def fourSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "remove-nth-node-from-end-of-list",
    "title": "Remove Nth Node From End of List",
    "acceptance": 0.5065179916880962,
    "difficulty": "Medium",
    "likes": 20930,
    "dislikes": 886,
    "stars": null,
    "tags": [
      "linked-list",
      "two-pointers"
    ],
    "description": "Cho head của một danh sách liên kết, loại bỏ nth nút từ kết thúc của danh sách và trả về nó head.",
    "constraints": [
      "số của các nút trong danh sách là sz.",
      "1 <= sz <= 30",
      "0 <= Node.val <= 100",
      "1 <= n <= sz Câu hỏi thêm: Bạn có thể làm điều này trong một lần duyệt?"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], n = 2",
        "output": "[1,2,3,5]",
        "explanation": ""
      },
      {
        "input": "head = [1], n = 1",
        "output": "[]",
        "explanation": ""
      },
      {
        "input": "head = [1,2], n = 1",
        "output": "[1]",
        "explanation": ""
      }
    ],
    "content": "Maintain hai các con trỏ và cập nhật một với một delay của n các bước.",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ var removeNthFromEnd = function(head, n) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def removeNthFromEnd(self, head, n): \"\"\" :type head: Optional[ListNode] :type n: int :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:18 PM UTC+7",
    "editorial": {
      "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\nHint/nhắc ý (crawl được): Maintain two pointers and update one with a delay of n steps.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
      "lastUpdated": "January 13, 2026 at 3:39:18 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ var removeNthFromEnd = function(head, n) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def removeNthFromEnd(self, head, n): \"\"\" :type head: Optional[ListNode] :type n: int :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "valid-parentheses",
    "title": "Valid Parentheses",
    "acceptance": 0.4345280317354158,
    "difficulty": "Easy",
    "likes": 27270,
    "dislikes": 1976,
    "stars": null,
    "tags": [
      "string",
      "stack"
    ],
    "description": "Cho một chuỗi s chứa chỉ các ký tự '(', ')', '{', '}', '[' và ']', xác định nếu đầu vào chuỗi là hợp lệ. Một đầu vào chuỗi là hợp lệ nếu: Mở các ngoặc phải là được đóng bởi giống nhau type của các ngoặc. Mở các ngoặc phải là được đóng trong correct thứ tự. Mỗi đóng ngoặc có một corresponding mở ngoặc của giống nhau type.",
    "constraints": [
      "1 <= s.length <= 104 s Gồm dấu ngoặc chỉ '()[]{}'."
    ],
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": ""
      },
      {
        "input": "s = \"([])\"",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "s = \"([)]\"",
        "output": "false",
        "explanation": ""
      }
    ],
    "content": "Dùng một ngăn xếp của các ký tự. Khi nào bạn encounter một mở ngoặc, push nó để top của ngăn xếp. Khi nào bạn encounter một đóng ngoặc, kiểm tra nếu top của ngăn xếp là mở cho nó. Nếu có, pop nó từ ngăn xếp. Otherwise, trả về sai.",
    "defaultCode": {
      "cpp": "class Solution { public: bool isValid(string s) { } };",
      "java": "class Solution { public boolean isValid(String s) { } }",
      "javascript": "/** * @param {string} s * @return {boolean} */ var isValid = function(s) { };",
      "python": "class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:18 PM UTC+7",
    "editorial": {
      "content": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.\n\nHint/nhắc ý (crawl được): Use a stack of characters. When you encounter an opening bracket, push it to the top of the stack. When you encounter a closing bracket, check if the top of the stack was the opening for it. If yes, pop it from the stack. Otherwise, return false.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
      "lastUpdated": "January 13, 2026 at 3:39:18 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: bool isValid(string s) { } };",
            "java": "class Solution { public boolean isValid(String s) { } }",
            "javascript": "/** * @param {string} s * @return {boolean} */ var isValid = function(s) { };",
            "python": "class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "merge-two-sorted-lists",
    "title": "Merge Two Sorted Lists",
    "acceptance": 0.6772722598947815,
    "difficulty": "Easy",
    "likes": 24526,
    "dislikes": 2410,
    "stars": null,
    "tags": [
      "linked-list",
      "recursion"
    ],
    "description": "Bạn được cho heads của hai đã sắp xếp liên kết các danh sách list1 và list2. Gộp hai các danh sách thành một đã sắp xếp danh sách. danh sách nên là made bởi splicing cùng các nút của đầu tiên hai các danh sách. Trả về head của merged danh sách liên kết.",
    "constraints": [
      "số của các nút trong both các danh sách là Trong khoảng [0, 50].",
      "-100 <= Node.val <= 100 Both list1 và list2 là đã sắp xếp trong thứ tự không giảm."
    ],
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": ""
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": ""
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} list1 * @param {ListNode} list2 * @return {ListNode} */ var mergeTwoLists = function(list1, list2) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def mergeTwoLists(self, list1, list2): \"\"\" :type list1: Optional[ListNode] :type list2: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:19 PM UTC+7",
    "editorial": {
      "content": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng đệ quy để biểu diễn bài toán con; có thể kết hợp memoization để tránh lặp.",
      "lastUpdated": "January 13, 2026 at 3:39:19 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers trên Linked List",
          "description": "Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} list1 * @param {ListNode} list2 * @return {ListNode} */ var mergeTwoLists = function(list1, list2) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def mergeTwoLists(self, list1, list2): \"\"\" :type list1: Optional[ListNode] :type list2: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "generate-parentheses",
    "title": "Generate Parentheses",
    "acceptance": 0.7807463648116361,
    "difficulty": "Medium",
    "likes": 22981,
    "dislikes": 1066,
    "stars": null,
    "tags": [
      "string",
      "dynamic-programming",
      "backtracking"
    ],
    "description": "Cho n các cặp của dấu ngoặc, viết một hàm để generate tất cả các tổ hợp của well-tạo thành dấu ngoặc.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
        "explanation": ""
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<string> generateParenthesis(int n) { } };",
      "java": "class Solution { public List<String> generateParenthesis(int n) { } }",
      "javascript": "/** * @param {number} n * @return {string[]} */ var generateParenthesis = function(n) { };",
      "python": "class Solution(object): def generateParenthesis(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:20 PM UTC+7",
    "editorial": {
      "content": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:39:20 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: vector<string> generateParenthesis(int n) { } };",
            "java": "class Solution { public List<String> generateParenthesis(int n) { } }",
            "javascript": "/** * @param {number} n * @return {string[]} */ var generateParenthesis = function(n) { };",
            "python": "class Solution(object): def generateParenthesis(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "merge-k-sorted-lists",
    "title": "Merge k Sorted Lists",
    "acceptance": 0.5851631586446809,
    "difficulty": "Hard",
    "likes": 21042,
    "dislikes": 783,
    "stars": null,
    "tags": [
      "linked-list",
      "divide-and-conquer",
      "heap-priority-queue",
      "merge-sort"
    ],
    "description": "Bạn được cho một mảng của k liên kết-lists lists, each liên kết-danh sách là đã sắp xếp trong thứ tự tăng dần. Gộp tất cả liên kết-lists thành một đã sắp xếp liên kết-danh sách và trả về nó.",
    "constraints": [
      "k == lists.length",
      "0 <= k <= 104",
      "0 <= lists[i].độ dài <= 500",
      "-104 <= lists[i][j] <= 104 lists[i] là đã sắp xếp trong thứ tự tăng dần. tổng của lists[i].độ dài sẽ không exceed 104."
    ],
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "liên kết-lists là: [ 1->4->5, 1->3->4, 2->6 ] merging chúng thành một đã sắp xếp danh sách liên kết: 1->1->2->3->4->4->5->6"
      },
      {
        "input": "lists = []",
        "output": "[]",
        "explanation": ""
      },
      {
        "input": "lists = [[]]",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeKLists(vector<ListNode*>& lists) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeKLists(ListNode[] lists) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode[]} lists * @return {ListNode} */ var mergeKLists = function(lists) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def mergeKLists(self, lists): \"\"\" :type lists: List[Optional[ListNode]] :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:20 PM UTC+7",
    "editorial": {
      "content": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả.",
      "lastUpdated": "January 13, 2026 at 3:39:20 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Heap / Priority Queue",
          "description": "Dùng heap để luôn lấy phần tử nhỏ/lớn nhất theo nhu cầu (top-k, merge, streaming).",
          "timeComplexity": "$O(n\\log n)$ hoặc $O(n\\log k)$",
          "spaceComplexity": "$O(n)$ hoặc $O(k)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeKLists(vector<ListNode*>& lists) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeKLists(ListNode[] lists) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode[]} lists * @return {ListNode} */ var mergeKLists = function(lists) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def mergeKLists(self, lists): \"\"\" :type lists: List[Optional[ListNode]] :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "swap-nodes-in-pairs",
    "title": "Swap Nodes in Pairs",
    "acceptance": 0.68642812698923,
    "difficulty": "Medium",
    "likes": 12966,
    "dislikes": 504,
    "stars": null,
    "tags": [
      "linked-list",
      "recursion"
    ],
    "description": "Cho một danh sách liên kết, hoán đổi mỗi hai kề nhau các nút và trả về nó head. Bạn phải solve problem không modifying các giá trị trong list's các nút (i.e., chỉ các nút themselves có thể là changed.)",
    "constraints": [
      "số của các nút trong danh sách là Trong khoảng [0, 100].",
      "0 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4]",
        "output": "[2,1,4,3]",
        "explanation": ""
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": ""
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": ""
      },
      {
        "input": "head = [1,2,3]",
        "output": "[2,1,3]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var swapPairs = function(head) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def swapPairs(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:21 PM UTC+7",
    "editorial": {
      "content": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng đệ quy để biểu diễn bài toán con; có thể kết hợp memoization để tránh lặp.",
      "lastUpdated": "January 13, 2026 at 3:39:21 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers trên Linked List",
          "description": "Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var swapPairs = function(head) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def swapPairs(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "reverse-nodes-in-k-group",
    "title": "Reverse Nodes in k-Group",
    "acceptance": 0.6494666389969517,
    "difficulty": "Hard",
    "likes": 15394,
    "dislikes": 793,
    "stars": null,
    "tags": [
      "linked-list",
      "recursion"
    ],
    "description": "Cho head của một danh sách liên kết, đảo ngược các nút của danh sách k tại một thời gian, và trả về modified danh sách. k là một dương số nguyên và là nhỏ hơn hoặc bằng để độ dài của danh sách liên kết. Nếu số của các nút là không một nhiều của k thì left-out các nút, trong kết thúc, nên remain như nó là. Bạn không được alter các giá trị trong list's các nút, chỉ các nút themselves có thể là changed.",
    "constraints": [
      "số của các nút trong danh sách là n.",
      "1 <= k <= n <= 5000",
      "0 <= Node.val <= 1000 Câu hỏi thêm: Bạn có thể solve problem trong O(1) extra bộ nhớ bộ nhớ?"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[2,1,4,3,5]",
        "explanation": ""
      },
      {
        "input": "head = [1,2,3,4,5], k = 3",
        "output": "[3,2,1,4,5]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseKGroup(ListNode head, int k) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} k * @return {ListNode} */ var reverseKGroup = function(head, k) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def reverseKGroup(self, head, k): \"\"\" :type head: Optional[ListNode] :type k: int :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:21 PM UTC+7",
    "editorial": {
      "content": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list's nodes, only nodes themselves may be changed.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng đệ quy để biểu diễn bài toán con; có thể kết hợp memoization để tránh lặp.",
      "lastUpdated": "January 13, 2026 at 3:39:21 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers trên Linked List",
          "description": "Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseKGroup(ListNode head, int k) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} k * @return {ListNode} */ var reverseKGroup = function(head, k) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def reverseKGroup(self, head, k): \"\"\" :type head: Optional[ListNode] :type k: int :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "remove-duplicates-from-sorted-array",
    "title": "Remove Duplicates from Sorted Array",
    "acceptance": 0.619144581759781,
    "difficulty": "Easy",
    "likes": 18388,
    "dislikes": 20368,
    "stars": null,
    "tags": [
      "array",
      "two-pointers"
    ],
    "description": "Cho một số nguyên mảng nums đã sắp xếp trong thứ tự không giảm, loại bỏ trùng lặp trong-place Sao cho each không trùng lặp phần tử appears chỉ một lần. relative thứ tự của các phần tử nên là kept giống nhau. Consider số của không trùng lặp các phần tử trong nums để là k. Sau removing trùng lặp, trả về số của không trùng lặp các phần tử k. đầu tiên k các phần tử của nums nên chứa không trùng lặp các số trong đã sắp xếp thứ tự. remaining các phần tử beyond chỉ số k - 1 có thể là ignored. Custom Judge: judge sẽ test của bạn lời giải với sau đây code: int[] nums = [...]; // Đầu vào mảng int[] expectedNums = [...]; // expected đáp án với correct độ dài int k = removeDuplicates(nums); // Calls của bạn implementation assert k == expectedNums.length; cho (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; } Nếu tất cả assertions lần duyệt, thì của bạn lời giải sẽ là accepted.",
    "constraints": [
      "1 <= nums.length <= 3 * 104",
      "-100 <= nums[i] <= 100 nums là đã sắp xếp trong thứ tự không giảm."
    ],
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "2, nums = [1,2,_]",
        "explanation": "Của bạn hàm nên trả về k = 2, với đầu tiên hai các phần tử của nums là 1 và 2 tương ứng. Nó không matter điều gì bạn leave beyond trả về k (do đó họ là underscores)."
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
        "explanation": "Của bạn hàm nên trả về k = 5, với đầu tiên năm các phần tử của nums là 0, 1, 2, 3, và 4 tương ứng. Nó không matter điều gì bạn leave beyond trả về k (do đó họ là underscores)."
      }
    ],
    "content": "Trong điều này problem, khóa point để focus trên là đầu vào mảng là đã sắp xếp. Như far như trùng lặp các phần tử là concerned, điều gì là their vị trí trong mảng khi nào cho mảng là đã sắp xếp? Look tại image bên dưới cho đáp án. Nếu chúng ta know vị trí của một của các phần tử, làm chúng ta cũng know vị trí của tất cả trùng lặp các phần tử? <br> <img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_rem_dup.png\" width=\"500\"/> Chúng ta need để modify mảng trong-place và kích thước của final mảng sẽ potentially là nhỏ hơn hơn kích thước của đầu vào mảng. Vì vậy, chúng ta ought để dùng một hai-con trỏ approach here. Một, đó sẽ giữ track của hiện tại phần tử trong original mảng và another một cho chỉ không trùng lặp các phần tử. Essentially, một lần một phần tử là encountered, bạn simply need để <b>bypass</b> nó trùng lặp và di chuyển trên để next không trùng lặp phần tử.",
    "defaultCode": {
      "cpp": "class Solution { public: int removeDuplicates(vector<int>& nums) { } };",
      "java": "class Solution { public int removeDuplicates(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var removeDuplicates = function(nums) { };",
      "python": "class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:22 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Consider the number of unique elements in nums to be k. After removing duplicates, return the number of unique elements k. The first k elements of nums should contain the unique numbers in sorted order. The remaining elements beyond index k - 1 can be ignored. Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\n\nHint/nhắc ý (crawl được): In this problem, the key point to focus on is the input array being sorted. As far as duplicate elements are concerned, what is their positioning in the array when the given array is sorted? Look at the image below for the answer. If we know the position of one of the elements, do we also know the positioning of all the duplicate elements? <br> <img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_rem_dup.png\" width=\"500\"/> We need to modify the array in-place and the size of the final array would potentially be smaller than the size of the input array. So, we ought to use a two-pointer approach here. One, that would keep track of the current element in the original array and another one for just the unique elements. Essentially, once an element is encountered, you simply need to <b>bypass</b> its duplicates and move on to the next unique element.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
      "lastUpdated": "January 13, 2026 at 3:39:22 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int removeDuplicates(vector<int>& nums) { } };",
            "java": "class Solution { public int removeDuplicates(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var removeDuplicates = function(nums) { };",
            "python": "class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "remove-element",
    "title": "Remove Element",
    "acceptance": 0.611086637500241,
    "difficulty": "Easy",
    "likes": 4767,
    "dislikes": 5220,
    "stars": null,
    "tags": [
      "array",
      "two-pointers"
    ],
    "description": "Cho một số nguyên mảng nums và một số nguyên val, loại bỏ tất cả occurrences của val trong nums trong-place. thứ tự của các phần tử có thể là changed. Thì trả về số của các phần tử trong nums nào là không bằng để val. Consider số của các phần tử trong nums nào là không bằng để val là k, để get accepted, bạn need để làm sau đây things: Change mảng nums Sao cho đầu tiên k các phần tử của nums chứa các phần tử nào là không bằng để val. remaining các phần tử của nums là không important như well như kích thước của nums. Trả về k. Custom Judge: judge sẽ test của bạn lời giải với sau đây code: int[] nums = [...]; // Đầu vào mảng int val =...; // Giá trị để loại bỏ int[] expectedNums = [...]; // expected đáp án với correct độ dài. // Nó là đã sắp xếp với không các giá trị bằng val. int k = removeElement(nums, val); // Calls của bạn implementation assert k == expectedNums.length; sắp xếp(nums, 0, k); // Sắp xếp đầu tiên k các phần tử của nums cho (int i = 0; i < actualLength; i++) { assert nums[i] == expectedNums[i]; } Nếu tất cả assertions lần duyệt, thì của bạn lời giải sẽ là accepted.",
    "constraints": [
      "0 <= nums.length <= 100",
      "0 <= nums[i] <= 50",
      "0 <= val <= 100"
    ],
    "examples": [
      {
        "input": "nums = [3,2,2,3], val = 3",
        "output": "2, nums = [2,2,_,_]",
        "explanation": "Của bạn hàm nên trả về k = 2, với đầu tiên hai các phần tử của nums là 2. Nó không matter điều gì bạn leave beyond trả về k (do đó họ là underscores)."
      },
      {
        "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
        "output": "5, nums = [0,1,4,0,3,_,_,_]",
        "explanation": "Của bạn hàm nên trả về k = 5, với đầu tiên năm các phần tử của nums chứa 0, 0, 1, 3, và 4."
      }
    ],
    "content": "problem statement clearly asks us để modify mảng trong-place và nó cũng says đó phần tử beyond new độ dài của mảng có thể là anything. Cho một phần tử, chúng ta need để loại bỏ tất cả occurrences của nó từ mảng. Chúng ta don't technically need để <b>remove</b> đó phần tử per se, right? Chúng ta có thể di chuyển tất cả occurrences của điều này phần tử để kết thúc của mảng. Dùng hai các con trỏ! <br><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png\" width=\"500\"/> Yet another direction của thought là để consider các phần tử để là removed như không-existent. Trong một một lần duyệt, nếu chúng ta giữ copying visible các phần tử trong-place, đó nên cũng solve điều này problem cho us.",
    "defaultCode": {
      "cpp": "class Solution { public: int removeElement(vector<int>& nums, int val) { } };",
      "java": "class Solution { public int removeElement(int[] nums, int val) { } }",
      "javascript": "/** * @param {number[]} nums * @param {number} val * @return {number} */ var removeElement = function(nums, val) { };",
      "python": "class Solution(object): def removeElement(self, nums, val): \"\"\" :type nums: List[int] :type val: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:23 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val. Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things: Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i < actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\n\nHint/nhắc ý (crawl được): The problem statement clearly asks us to modify the array in-place and it also says that the element beyond the new length of the array can be anything. Given an element, we need to remove all the occurrences of it from the array. We don't technically need to <b>remove</b> that element per se, right? We can move all the occurrences of this element to the end of the array. Use two pointers! <br><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png\" width=\"500\"/> Yet another direction of thought is to consider the elements to be removed as non-existent. In a single pass, if we keep copying the visible elements in-place, that should also solve this problem for us.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
      "lastUpdated": "January 13, 2026 at 3:39:23 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int removeElement(vector<int>& nums, int val) { } };",
            "java": "class Solution { public int removeElement(int[] nums, int val) { } }",
            "javascript": "/** * @param {number[]} nums * @param {number} val * @return {number} */ var removeElement = function(nums, val) { };",
            "python": "class Solution(object): def removeElement(self, nums, val): \"\"\" :type nums: List[int] :type val: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "find-the-index-of-the-first-occurrence-in-a-string",
    "title": "Find the Index of the First Occurrence in a String",
    "acceptance": 0.46040112015134804,
    "difficulty": "Easy",
    "likes": 7367,
    "dislikes": 559,
    "stars": null,
    "tags": [
      "two-pointers",
      "string",
      "string-matching"
    ],
    "description": "Cho hai các chuỗi needle và haystack, trả về chỉ số của đầu tiên occurrence của needle trong haystack, hoặc -1 nếu needle là không part của haystack.",
    "constraints": [
      "1 <= haystack.length, needle.length <= 104 haystack và needle consist của chỉ chữ thường Tiếng Anh các ký tự."
    ],
    "examples": [
      {
        "input": "haystack = \"sadbutsad\", needle = \"sad\"",
        "output": "0",
        "explanation": "\"sad\" occurs tại chỉ số 0 và 6. đầu tiên occurrence là tại chỉ số 0, vì vậy chúng ta trả về 0."
      },
      {
        "input": "haystack = \"leetcode\", needle = \"leeto\"",
        "output": "-1",
        "explanation": "\"leeto\" did không occur trong \"leetcode\", vì vậy chúng ta trả về -1."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int strStr(string haystack, string needle) { } };",
      "java": "class Solution { public int strStr(String haystack, String needle) { } }",
      "javascript": "/** * @param {string} haystack * @param {string} needle * @return {number} */ var strStr = function(haystack, needle) { };",
      "python": "class Solution(object): def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:23 PM UTC+7",
    "editorial": {
      "content": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:23 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int strStr(string haystack, string needle) { } };",
            "java": "class Solution { public int strStr(String haystack, String needle) { } }",
            "javascript": "/** * @param {string} haystack * @param {string} needle * @return {number} */ var strStr = function(haystack, needle) { };",
            "python": "class Solution(object): def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "divide-two-integers",
    "title": "Divide Two Integers",
    "acceptance": 0.19208281084541812,
    "difficulty": "Medium",
    "likes": 5987,
    "dislikes": 15243,
    "stars": null,
    "tags": [
      "math",
      "bit-manipulation"
    ],
    "description": "Cho hai các số nguyên dividend và divisor, chia hai các số nguyên không using multiplication, division, và mod operator. số nguyên division nên truncate toward 0, nào means losing nó fractional part. Ví dụ, 8.345 sẽ là truncated để 8, và -2.7335 sẽ là truncated để -2. Trả về quotient sau dividing dividend bởi divisor. Lưu ý: Giả sử chúng ta là dealing với một environment đó có thể chỉ lưu các số nguyên trong 32-bit có dấu số nguyên khoảng: [−231, 231 − 1]. Cho điều này problem, nếu quotient là strictly lớn hơn 231 - 1, thì trả về 231 - 1, và nếu quotient là strictly nhỏ hơn -231, thì trả về -231.",
    "constraints": [
      "-231 <= dividend, divisor <= 231 - 1 divisor!= 0"
    ],
    "examples": [
      {
        "input": "dividend = 10, divisor = 3",
        "output": "3",
        "explanation": "10/3 = 3.33333.. nào là truncated để 3."
      },
      {
        "input": "dividend = 7, divisor = -3",
        "output": "-2",
        "explanation": "7/-3 = -2.33333.. nào là truncated để -2."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int divide(int dividend, int divisor) { } };",
      "java": "class Solution { public int divide(int dividend, int divisor) { } }",
      "javascript": "/** * @param {number} dividend * @param {number} divisor * @return {number} */ var divide = function(dividend, divisor) { };",
      "python": "class Solution(object): def divide(self, dividend, divisor): \"\"\" :type dividend: int :type divisor: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:24 PM UTC+7",
    "editorial": {
      "content": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator. The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2. Return the quotient after dividing dividend by divisor. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
      "lastUpdated": "January 13, 2026 at 3:39:24 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Bit Manipulation",
          "description": "Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int divide(int dividend, int divisor) { } };",
            "java": "class Solution { public int divide(int dividend, int divisor) { } }",
            "javascript": "/** * @param {number} dividend * @param {number} divisor * @return {number} */ var divide = function(dividend, divisor) { };",
            "python": "class Solution(object): def divide(self, dividend, divisor): \"\"\" :type dividend: int :type divisor: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "substring-with-concatenation-of-all-words",
    "title": "Substring with Concatenation of All Words",
    "acceptance": 0.3376433914388881,
    "difficulty": "Hard",
    "likes": 2537,
    "dislikes": 415,
    "stars": null,
    "tags": [
      "hash-table",
      "string",
      "sliding-window"
    ],
    "description": "Bạn được cho một chuỗi s và một mảng của các chuỗi words. Tất cả các chuỗi của words là của giống nhau độ dài. Một concatenated chuỗi là một chuỗi đó chính xác chứa tất cả các chuỗi của bất kỳ hoán vị của words concatenated. Ví dụ, nếu words = [\"ab\",\"cd\",\"ef\"], thì \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", và \"efcdab\" là tất cả concatenated các chuỗi. \"acdbef\" là không một concatenated chuỗi vì nó là không concatenation của bất kỳ hoán vị của words. Trả về một mảng của bắt đầu các chỉ số của tất cả concatenated chuỗi con trong s. Bạn có thể trả về đáp án Theo bất kỳ thứ tự nào.",
    "constraints": [
      "1 <= s.length <= 104",
      "1 <= words.length <= 5000",
      "1 <= words[i].độ dài <= 30 s và words[i] consist của chữ thường Tiếng Anh các chữ cái."
    ],
    "examples": [
      {
        "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
        "output": "[0,9]",
        "explanation": "chuỗi con bắt đầu tại 0 là \"barfoo\". Nó là concatenation của [\"bar\",\"foo\"] nào là một hoán vị của words. chuỗi con bắt đầu tại 9 là \"foobar\". Nó là concatenation của [\"foo\",\"bar\"] nào là một hoán vị của words."
      },
      {
        "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
        "output": "[]",
        "explanation": "Có không concatenated chuỗi con."
      },
      {
        "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
        "output": "[6,9,12]",
        "explanation": "chuỗi con bắt đầu tại 6 là \"foobarthe\". Nó là concatenation của [\"foo\",\"bar\",\"the\"]. chuỗi con bắt đầu tại 9 là \"barthefoo\". Nó là concatenation của [\"bar\",\"the\",\"foo\"]. chuỗi con bắt đầu tại 12 là \"thefoobar\". Nó là concatenation của [\"the\",\"foo\",\"bar\"]."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<int> findSubstring(string s, vector<string>& words) { } };",
      "java": "class Solution { public List<Integer> findSubstring(String s, String[] words) { } }",
      "javascript": "/** * @param {string} s * @param {string[]} words * @return {number[]} */ var findSubstring = function(s, words) { };",
      "python": "class Solution(object): def findSubstring(self, s, words): \"\"\" :type s: str :type words: List[str] :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:26 PM UTC+7",
    "editorial": {
      "content": "You are given a string s and an array of strings words. All the strings of words are of the same length. A concatenated string is a string that exactly contains all the strings of any permutation of words concatenated. For example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated string because it is not the concatenation of any permutation of words. Return an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:26 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: vector<int> findSubstring(string s, vector<string>& words) { } };",
            "java": "class Solution { public List<Integer> findSubstring(String s, String[] words) { } }",
            "javascript": "/** * @param {string} s * @param {string[]} words * @return {number[]} */ var findSubstring = function(s, words) { };",
            "python": "class Solution(object): def findSubstring(self, s, words): \"\"\" :type s: str :type words: List[str] :rtype: List[int] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "next-permutation",
    "title": "Next Permutation",
    "acceptance": 0.44458640616458295,
    "difficulty": "Medium",
    "likes": 20991,
    "dislikes": 5073,
    "stars": null,
    "tags": [
      "array",
      "two-pointers"
    ],
    "description": "Một hoán vị của một mảng của các số nguyên là một arrangement của nó members thành một dãy hoặc linear thứ tự. Ví dụ, cho arr = [1,2,3], sau đây là tất cả các hoán vị của arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]. next hoán vị của một mảng của các số nguyên là next lexicographically lớn hơn hoán vị của nó số nguyên. Nhiều hơn formally, nếu tất cả các hoán vị của mảng là đã sắp xếp trong một bình chứa according để their lexicographical thứ tự, thì next hoán vị của đó mảng là hoán vị đó theo nó trong đã sắp xếp bình chứa. Nếu such arrangement là không có thể, mảng phải là rearranged như lowest có thể thứ tự (i.e., đã sắp xếp trong thứ tự tăng dần). Ví dụ, next hoán vị của arr = [1,2,3] là [1,3,2]. Similarly, next hoán vị của arr = [2,3,1] là [3,1,2]. Trong khi next hoán vị của arr = [3,2,1] là [1,2,3] vì [3,2,1] không có một lexicographical lớn hơn rearrangement. Cho một mảng của các số nguyên nums, tìm next hoán vị của nums. replacement phải là trong place và dùng chỉ constant extra bộ nhớ.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 100"
    ],
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[1,3,2]",
        "explanation": ""
      },
      {
        "input": "nums = [3,2,1]",
        "output": "[1,2,3]",
        "explanation": ""
      },
      {
        "input": "nums = [1,1,5]",
        "output": "[1,5,1]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: void nextPermutation(vector<int>& nums) { } };",
      "java": "class Solution { public void nextPermutation(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var nextPermutation = function(nums) { };",
      "python": "class Solution(object): def nextPermutation(self, nums): \"\"\" :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:27 PM UTC+7",
    "editorial": {
      "content": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr = [1,2,3] is [1,3,2]. Similarly, the next permutation of arr = [2,3,1] is [3,1,2]. While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement. Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
      "lastUpdated": "January 13, 2026 at 3:39:27 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: void nextPermutation(vector<int>& nums) { } };",
            "java": "class Solution { public void nextPermutation(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var nextPermutation = function(nums) { };",
            "python": "class Solution(object): def nextPermutation(self, nums): \"\"\" :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "longest-valid-parentheses",
    "title": "Longest Valid Parentheses",
    "acceptance": 0.3772503178071181,
    "difficulty": "Hard",
    "likes": 13170,
    "dislikes": 461,
    "stars": null,
    "tags": [
      "string",
      "dynamic-programming",
      "stack"
    ],
    "description": "Cho một chuỗi chứa chỉ các ký tự '(' và ')', trả về độ dài của dài nhất hợp lệ (well-tạo thành) dấu ngoặc chuỗi con.",
    "constraints": [
      "0 <= s.length <= 3 * 104 s[i] là '(', hoặc ')'."
    ],
    "examples": [
      {
        "input": "s = \"(()\"",
        "output": "2",
        "explanation": "dài nhất hợp lệ dấu ngoặc chuỗi con là \"()\"."
      },
      {
        "input": "s = \")()())\"",
        "output": "4",
        "explanation": "dài nhất hợp lệ dấu ngoặc chuỗi con là \"()()\"."
      },
      {
        "input": "s = \"\"",
        "output": "0",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int longestValidParentheses(string s) { } };",
      "java": "class Solution { public int longestValidParentheses(String s) { } }",
      "javascript": "/** * @param {string} s * @return {number} */ var longestValidParentheses = function(s) { };",
      "python": "class Solution(object): def longestValidParentheses(self, s): \"\"\" :type s: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:27 PM UTC+7",
    "editorial": {
      "content": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:39:27 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: int longestValidParentheses(string s) { } };",
            "java": "class Solution { public int longestValidParentheses(String s) { } }",
            "javascript": "/** * @param {string} s * @return {number} */ var longestValidParentheses = function(s) { };",
            "python": "class Solution(object): def longestValidParentheses(self, s): \"\"\" :type s: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "search-in-rotated-sorted-array",
    "title": "Search in Rotated Sorted Array",
    "acceptance": 0.43881976511915,
    "difficulty": "Medium",
    "likes": 29425,
    "dislikes": 1783,
    "stars": null,
    "tags": [
      "array",
      "binary-search"
    ],
    "description": "Có một số nguyên mảng nums đã sắp xếp trong thứ tự tăng dần (với phân biệt các giá trị). Prior để là lần duyệt để của bạn hàm, nums là possibly left rotated tại một unknown chỉ số k (1 <= k < nums.length) Sao cho kết quả mảng là [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-chỉ số). Ví dụ, [0,1,2,4,5,6,7] might là left rotated bởi 3 các chỉ số và become [4,5,6,7,0,1,2]. Cho mảng nums sau có thể rotation và một số nguyên target, trả về chỉ số của target nếu nó là trong nums, hoặc -1 nếu nó là không trong nums. Bạn phải viết một thuật toán với O(log n) runtime độ phức tạp.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-104 <= nums[i] <= 104 Tất cả các giá trị của nums là không trùng lặp. nums là một tăng dần mảng đó là possibly rotated.",
      "-104 <= target <= 104"
    ],
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": ""
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": ""
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int search(vector<int>& nums, int target) { } };",
      "java": "class Solution { public int search(int[] nums, int target) { } }",
      "javascript": "/** * @param {number[]} nums * @param {number} target * @return {number} */ var search = function(nums, target) { };",
      "python": "class Solution(object): def search(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:28 PM UTC+7",
    "editorial": {
      "content": "There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly left rotated at an unknown index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be left rotated by 3 indices and become [4,5,6,7,0,1,2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity.\n\nGợi ý hướng giải: Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
      "lastUpdated": "January 13, 2026 at 3:39:28 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Binary Search",
          "description": "Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
          "timeComplexity": "$O(\\log n)$ hoặc $O(n\\log M)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int search(vector<int>& nums, int target) { } };",
            "java": "class Solution { public int search(int[] nums, int target) { } }",
            "javascript": "/** * @param {number[]} nums * @param {number} target * @return {number} */ var search = function(nums, target) { };",
            "python": "class Solution(object): def search(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "find-first-and-last-position-of-element-in-sorted-array",
    "title": "Find First and Last Position of Element in Sorted Array",
    "acceptance": 0.48060791686534726,
    "difficulty": "Medium",
    "likes": 22869,
    "dislikes": 623,
    "stars": null,
    "tags": [
      "array",
      "binary-search"
    ],
    "description": "Cho một mảng của các số nguyên nums đã sắp xếp trong thứ tự không giảm, tìm bắt đầu và kết thúc vị trí của một cho target giá trị. Nếu target là không found trong mảng, trả về [-1, -1]. Bạn phải viết một thuật toán với O(log n) runtime độ phức tạp.",
    "constraints": [
      "0 <= nums.length <= 105",
      "-109 <= nums[i] <= 109 nums là một không-giảm mảng.",
      "-109 <= target <= 109"
    ],
    "examples": [
      {
        "input": "nums = [5,7,7,8,8,10], target = 8",
        "output": "[3,4]",
        "explanation": ""
      },
      {
        "input": "nums = [5,7,7,8,8,10], target = 6",
        "output": "[-1,-1]",
        "explanation": ""
      },
      {
        "input": "nums = [], target = 0",
        "output": "[-1,-1]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<int> searchRange(vector<int>& nums, int target) { } };",
      "java": "class Solution { public int[] searchRange(int[] nums, int target) { } }",
      "javascript": "/** * @param {number[]} nums * @param {number} target * @return {number[]} */ var searchRange = function(nums, target) { };",
      "python": "class Solution(object): def searchRange(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:29 PM UTC+7",
    "editorial": {
      "content": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.\n\nGợi ý hướng giải: Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
      "lastUpdated": "January 13, 2026 at 3:39:29 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Binary Search",
          "description": "Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
          "timeComplexity": "$O(\\log n)$ hoặc $O(n\\log M)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: vector<int> searchRange(vector<int>& nums, int target) { } };",
            "java": "class Solution { public int[] searchRange(int[] nums, int target) { } }",
            "javascript": "/** * @param {number[]} nums * @param {number} target * @return {number[]} */ var searchRange = function(nums, target) { };",
            "python": "class Solution(object): def searchRange(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "search-insert-position",
    "title": "Search Insert Position",
    "acceptance": 0.5037033871505372,
    "difficulty": "Easy",
    "likes": 18413,
    "dislikes": 877,
    "stars": null,
    "tags": [
      "array",
      "binary-search"
    ],
    "description": "Cho một đã sắp xếp mảng của phân biệt các số nguyên và một target giá trị, trả về chỉ số nếu target là found. Nếu không, trả về chỉ số ở đâu nó sẽ là nếu nó là chèn trong thứ tự. Bạn phải viết một thuật toán với O(log n) runtime độ phức tạp.",
    "constraints": [
      "1 <= nums.length <= 104",
      "-104 <= nums[i] <= 104",
      "nums chứa phân biệt các giá trị đã sắp xếp trong thứ tự tăng dần.",
      "-104 <= target <= 104"
    ],
    "examples": [
      {
        "input": "nums = [1,3,5,6], target = 5",
        "output": "2",
        "explanation": ""
      },
      {
        "input": "nums = [1,3,5,6], target = 2",
        "output": "1",
        "explanation": ""
      },
      {
        "input": "nums = [1,3,5,6], target = 7",
        "output": "4",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int searchInsert(vector<int>& nums, int target) { } };",
      "java": "class Solution { public int searchInsert(int[] nums, int target) { } }",
      "javascript": "/** * @param {number[]} nums * @param {number} target * @return {number} */ var searchInsert = function(nums, target) { };",
      "python": "class Solution(object): def searchInsert(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:29 PM UTC+7",
    "editorial": {
      "content": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity.\n\nGợi ý hướng giải: Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
      "lastUpdated": "January 13, 2026 at 3:39:29 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Binary Search",
          "description": "Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
          "timeComplexity": "$O(\\log n)$ hoặc $O(n\\log M)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int searchInsert(vector<int>& nums, int target) { } };",
            "java": "class Solution { public int searchInsert(int[] nums, int target) { } }",
            "javascript": "/** * @param {number[]} nums * @param {number} target * @return {number} */ var searchInsert = function(nums, target) { };",
            "python": "class Solution(object): def searchInsert(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "valid-sudoku",
    "title": "Valid Sudoku",
    "acceptance": 0.6395866944060731,
    "difficulty": "Medium",
    "likes": 12297,
    "dislikes": 1252,
    "stars": null,
    "tags": [
      "array",
      "hash-table",
      "matrix"
    ],
    "description": "Xác định nếu một 9 x 9 Sudoku board là hợp lệ. Chỉ filled cells need để là validated according để sau đây rules: Each hàng phải chứa các chữ số 1-9 không repetition. Each cột phải chứa các chữ số 1-9 không repetition. Each của chín 3 x 3 sub-boxes của lưới phải chứa các chữ số 1-9 không repetition. Lưu ý: Một Sudoku board (một phần filled) có thể là hợp lệ but là không necessarily solvable. Chỉ filled cells need để là validated according để mentioned rules.",
    "constraints": [
      "board.length == 9 board[i].độ dài == 9 board[i][j] là một chữ số 1-9 hoặc '.'."
    ],
    "examples": [
      {
        "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
        "output": "false",
        "explanation": "Giống nhau như Ví dụ 1, ngoại trừ với 5 trong top left corner là modified để 8. Vì Có hai 8's trong top left 3x3 sub-box, nó là không hợp lệ."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool isValidSudoku(vector<vector<char>>& board) { } };",
      "java": "class Solution { public boolean isValidSudoku(char[][] board) { } }",
      "javascript": "/** * @param {character[][]} board * @return {boolean} */ var isValidSudoku = function(board) { };",
      "python": "class Solution(object): def isValidSudoku(self, board): \"\"\" :type board: List[List[str]] :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:30 PM UTC+7",
    "editorial": {
      "content": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Duyệt ma trận theo hàng/cột/biên; dùng đánh dấu hoặc visited nếu cần.",
      "lastUpdated": "January 13, 2026 at 3:39:30 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: bool isValidSudoku(vector<vector<char>>& board) { } };",
            "java": "class Solution { public boolean isValidSudoku(char[][] board) { } }",
            "javascript": "/** * @param {character[][]} board * @return {boolean} */ var isValidSudoku = function(board) { };",
            "python": "class Solution(object): def isValidSudoku(self, board): \"\"\" :type board: List[List[str]] :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "sudoku-solver",
    "title": "Sudoku Solver",
    "acceptance": 0.6535652333001285,
    "difficulty": "Hard",
    "likes": 10926,
    "dislikes": 337,
    "stars": null,
    "tags": [
      "array",
      "hash-table",
      "backtracking",
      "matrix"
    ],
    "description": "Viết một program để solve một Sudoku puzzle bởi filling rỗng cells. Một sudoku lời giải phải satisfy tất cả của sau đây rules: Each của các chữ số 1-9 phải occur chính xác một lần trong each hàng. Each của các chữ số 1-9 phải occur chính xác một lần trong each cột. Each của các chữ số 1-9 phải occur chính xác một lần trong each của 9 3x3 sub-boxes của lưới. '.' ký tự indicates rỗng cells.",
    "constraints": [
      "board.length == 9 board[i].độ dài == 9 board[i][j] là một chữ số hoặc '.'.",
      "Đảm bảo rằng đầu vào board có chỉ một lời giải."
    ],
    "examples": [
      {
        "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
        "output": "[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]",
        "explanation": "đầu vào board là shown bên trên và chỉ hợp lệ"
      }
    ],
    "content": "Cho each cell, place một hợp lệ số và Hãy thử solving cho remaining rỗng cells. Nếu stuck, undo (backtrack) và Hãy thử another hợp lệ số.",
    "defaultCode": {
      "cpp": "class Solution { public: void solveSudoku(vector<vector<char>>& board) { } };",
      "java": "class Solution { public void solveSudoku(char[][] board) { } }",
      "javascript": "/** * @param {character[][]} board * @return {void} Do not return anything, modify board in-place instead. */ var solveSudoku = function(board) { };",
      "python": "class Solution(object): def solveSudoku(self, board): \"\"\" :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:31 PM UTC+7",
    "editorial": {
      "content": "Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The '.' character indicates empty cells.\n\nHint/nhắc ý (crawl được): For each cell, place a valid number and try solving for the remaining empty cells. If stuck, undo (backtrack) and try another valid number.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
      "lastUpdated": "January 13, 2026 at 3:39:31 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: void solveSudoku(vector<vector<char>>& board) { } };",
            "java": "class Solution { public void solveSudoku(char[][] board) { } }",
            "javascript": "/** * @param {character[][]} board * @return {void} Do not return anything, modify board in-place instead. */ var solveSudoku = function(board) { };",
            "python": "class Solution(object): def solveSudoku(self, board): \"\"\" :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "count-and-say",
    "title": "Count and Say",
    "acceptance": 0.6202783336699286,
    "difficulty": "Medium",
    "likes": 5023,
    "dislikes": 9010,
    "stars": null,
    "tags": [
      "string"
    ],
    "description": "count-và-say dãy là một dãy của chữ số các chuỗi defined bởi recursive formula: countAndSay(1) = \"1\" countAndSay(n) là run-độ dài encoding của countAndSay(n - 1). Run-độ dài encoding (RLE) là một chuỗi compression method đó works bởi replacing consecutive identical các ký tự (repeated 2 hoặc nhiều hơn lần) với concatenation của ký tự và số marking count của các ký tự (độ dài của run). Ví dụ, để compress chuỗi \"3322251\" chúng ta thay thế \"33\" với \"23\", thay thế \"222\" với \"32\", thay thế \"5\" với \"15\" và thay thế \"1\" với \"11\". Thus compressed chuỗi becomes \"23321511\". Cho một dương số nguyên n, trả về nth phần tử của count-và-say dãy.",
    "constraints": [
      "1 <= n <= 30 Câu hỏi thêm: Bạn có thể solve nó iteratively?"
    ],
    "examples": [
      {
        "input": "n = 4",
        "output": "\"1211\"",
        "explanation": "countAndSay(1) = \"1\" countAndSay(2) = RLE của \"1\" = \"11\" countAndSay(3) = RLE của \"11\" = \"21\" countAndSay(4) = RLE của \"21\" = \"1211\""
      },
      {
        "input": "n = 1",
        "output": "\"1\"",
        "explanation": "Điều này là base trường hợp."
      }
    ],
    "content": "Tạo một helper hàm đó bản đồ một số nguyên để các cặp của nó các chữ số và their frequencies. Ví dụ, nếu bạn call điều này hàm với \"223314444411\", thì nó bản đồ nó để một mảng của các cặp [[2,2], [3,2], [1,1], [4,5], [1, 2]]. Tạo another helper hàm đó takes mảng của các cặp và tạo một new số nguyên. Ví dụ, nếu bạn call điều này hàm với [[2,2], [3,2], [1,1], [4,5], [1, 2]], nó nên tạo \"22\"+\"23\"+\"11\"+\"54\"+\"21\" = \"2223115421\". Now, với hai helper hàm, Bạn có thể bắt đầu với \"1\" và call hai hàm alternatively n-1 lần. Đáp án là last số nguyên bạn sẽ obtain.",
    "defaultCode": {
      "cpp": "class Solution { public: string countAndSay(int n) { } };",
      "java": "class Solution { public String countAndSay(int n) { } }",
      "javascript": "/** * @param {number} n * @return {string} */ var countAndSay = function(n) { };",
      "python": "class Solution(object): def countAndSay(self, n): \"\"\" :type n: int :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:31 PM UTC+7",
    "editorial": {
      "content": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula: countAndSay(1) = \"1\" countAndSay(n) is the run-length encoding of countAndSay(n - 1). Run-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string \"3322251\" we replace \"33\" with \"23\", replace \"222\" with \"32\", replace \"5\" with \"15\" and replace \"1\" with \"11\". Thus the compressed string becomes \"23321511\". Given a positive integer n, return the nth element of the count-and-say sequence.\n\nHint/nhắc ý (crawl được): Create a helper function that maps an integer to pairs of its digits and their frequencies. For example, if you call this function with \"223314444411\", then it maps it to an array of pairs [[2,2], [3,2], [1,1], [4,5], [1, 2]]. Create another helper function that takes the array of pairs and creates a new integer. For example, if you call this function with [[2,2], [3,2], [1,1], [4,5], [1, 2]], it should create \"22\"+\"23\"+\"11\"+\"54\"+\"21\" = \"2223115421\". Now, with the two helper functions, you can start with \"1\" and call the two functions alternatively n-1 times. The answer is the last integer you will obtain.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:31 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "String Processing",
          "description": "Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(n)$",
          "code": {
            "cpp": "class Solution { public: string countAndSay(int n) { } };",
            "java": "class Solution { public String countAndSay(int n) { } }",
            "javascript": "/** * @param {number} n * @return {string} */ var countAndSay = function(n) { };",
            "python": "class Solution(object): def countAndSay(self, n): \"\"\" :type n: int :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "combination-sum",
    "title": "Combination Sum",
    "acceptance": 0.7584881623569227,
    "difficulty": "Medium",
    "likes": 20678,
    "dislikes": 525,
    "stars": null,
    "tags": [
      "array",
      "backtracking"
    ],
    "description": "Cho một mảng của phân biệt các số nguyên candidates và một target số nguyên target, trả về một danh sách của tất cả không trùng lặp các tổ hợp của candidates ở đâu chosen các số tổng để target. Bạn có thể trả về các tổ hợp Theo bất kỳ thứ tự nào. giống nhau số có thể là chosen từ candidates một unlimited số của lần. Hai các tổ hợp là không trùng lặp nếu frequency của Ít nhất một của chosen các số là khác nhau. test trường hợp là generated Sao cho số của không trùng lặp các tổ hợp đó tổng ra để target là nhỏ hơn 150 các tổ hợp cho cho đầu vào.",
    "constraints": [
      "1 <= candidates.length <= 30",
      "2 <= candidates[i] <= 40 Tất cả các phần tử của candidates là phân biệt.",
      "1 <= target <= 40"
    ],
    "examples": [
      {
        "input": "candidates = [2,3,6,7], target = 7",
        "output": "[[2,2,3],[7]]",
        "explanation": "2 và 3 là candidates, và 2 + 2 + 3 = 7."
      },
      {
        "input": "candidates = [2,3,5], target = 8",
        "output": "[[2,2,2,2],[2,3,3],[3,5]]",
        "explanation": ""
      },
      {
        "input": "candidates = [2], target = 1",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> combinationSum(vector<int>& candidates, int target) { } };",
      "java": "class Solution { public List<List<Integer>> combinationSum(int[] candidates, int target) { } }",
      "javascript": "/** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ var combinationSum = function(candidates, target) { };",
      "python": "class Solution(object): def combinationSum(self, candidates, target): \"\"\" :type candidates: List[int] :type target: int :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:32 PM UTC+7",
    "editorial": {
      "content": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\nGợi ý hướng giải: Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
      "lastUpdated": "January 13, 2026 at 3:39:32 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> combinationSum(vector<int>& candidates, int target) { } };",
            "java": "class Solution { public List<List<Integer>> combinationSum(int[] candidates, int target) { } }",
            "javascript": "/** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ var combinationSum = function(candidates, target) { };",
            "python": "class Solution(object): def combinationSum(self, candidates, target): \"\"\" :type candidates: List[int] :type target: int :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "combination-sum-ii",
    "title": "Combination Sum II",
    "acceptance": 0.5873647333821594,
    "difficulty": "Medium",
    "likes": 12065,
    "dislikes": 377,
    "stars": null,
    "tags": [
      "array",
      "backtracking"
    ],
    "description": "Cho một collection của candidate các số (candidates) và một target số (target), tìm tất cả không trùng lặp các tổ hợp trong candidates ở đâu candidate các số tổng để target. Each số trong candidates có thể chỉ là được dùng một lần trong tổ hợp. Lưu ý: lời giải tập hợp phải không chứa trùng lặp các tổ hợp.",
    "constraints": [
      "1 <= candidates.length <= 100",
      "1 <= candidates[i] <= 50",
      "1 <= target <= 30"
    ],
    "examples": [
      {
        "input": "candidates = [10,1,2,7,6,1,5], target = 8",
        "output": "[ [1,1,6], [1,2,5], [1,7], [2,6] ]",
        "explanation": ""
      },
      {
        "input": "candidates = [2,5,2,1,2], target = 5",
        "output": "[ [1,2,2], [5] ]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> combinationSum2(vector<int>& candidates, int target) { } };",
      "java": "class Solution { public List<List<Integer>> combinationSum2(int[] candidates, int target) { } }",
      "javascript": "/** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ var combinationSum2 = function(candidates, target) { };",
      "python": "class Solution(object): def combinationSum2(self, candidates, target): \"\"\" :type candidates: List[int] :type target: int :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:33 PM UTC+7",
    "editorial": {
      "content": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations.\n\nGợi ý hướng giải: Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
      "lastUpdated": "January 13, 2026 at 3:39:33 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> combinationSum2(vector<int>& candidates, int target) { } };",
            "java": "class Solution { public List<List<Integer>> combinationSum2(int[] candidates, int target) { } }",
            "javascript": "/** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ var combinationSum2 = function(candidates, target) { };",
            "python": "class Solution(object): def combinationSum2(self, candidates, target): \"\"\" :type candidates: List[int] :type target: int :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "first-missing-positive",
    "title": "First Missing Positive",
    "acceptance": 0.4217920278427099,
    "difficulty": "Hard",
    "likes": 18138,
    "dislikes": 1970,
    "stars": null,
    "tags": [
      "array",
      "hash-table"
    ],
    "description": "Cho một unsorted số nguyên mảng nums. Trả về nhỏ nhất dương số nguyên đó là không present trong nums. Bạn phải cài đặt một thuật toán đó runs trong O(n) thời gian và dùng O(1) auxiliary bộ nhớ.",
    "constraints": [
      "1 <= nums.length <= 105",
      "-231 <= nums[i] <= 231 - 1"
    ],
    "examples": [
      {
        "input": "nums = [1,2,0]",
        "output": "3",
        "explanation": "các số Trong khoảng [1,2] là tất cả trong mảng."
      },
      {
        "input": "nums = [3,4,-1,1]",
        "output": "2",
        "explanation": "1 là trong mảng but 2 là missing."
      },
      {
        "input": "nums = [7,8,9,11,12]",
        "output": "1",
        "explanation": "nhỏ nhất dương số nguyên 1 là missing."
      }
    ],
    "content": "Think about làm thế nào bạn sẽ solve problem trong không-constant bộ nhớ. Bạn có thể apply đó logic để tồn tại bộ nhớ? Chúng ta don't care about trùng lặp hoặc không-dương các số nguyên Remember đó O(2n) = O(n)",
    "defaultCode": {
      "cpp": "class Solution { public: int firstMissingPositive(vector<int>& nums) { } };",
      "java": "class Solution { public int firstMissingPositive(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var firstMissingPositive = function(nums) { };",
      "python": "class Solution(object): def firstMissingPositive(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:33 PM UTC+7",
    "editorial": {
      "content": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums. You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n\nHint/nhắc ý (crawl được): Think about how you would solve the problem in non-constant space. Can you apply that logic to the existing space? We don't care about duplicates or non-positive integers Remember that O(2n) = O(n)\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
      "lastUpdated": "January 13, 2026 at 3:39:33 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: int firstMissingPositive(vector<int>& nums) { } };",
            "java": "class Solution { public int firstMissingPositive(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var firstMissingPositive = function(nums) { };",
            "python": "class Solution(object): def firstMissingPositive(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "trapping-rain-water",
    "title": "Trapping Rain Water",
    "acceptance": 0.664896710782123,
    "difficulty": "Hard",
    "likes": 35744,
    "dislikes": 671,
    "stars": null,
    "tags": [
      "array",
      "two-pointers",
      "dynamic-programming",
      "stack",
      "monotonic-stack"
    ],
    "description": "Cho n không âm các số nguyên biểu diễn một elevation bản đồ ở đâu chiều rộng của each bar là 1, tính làm thế nào much nước nó có thể trap sau raining.",
    "constraints": [
      "n == height.length",
      "1 <= n <= 2 * 104",
      "0 <= height[i] <= 105"
    ],
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "bên trên elevation bản đồ (black section) là được biểu diễn bởi mảng [0,1,0,2,1,0,1,3,2,1,2,1]. Trong điều này trường hợp, 6 units của rain nước (blue section) là là trapped."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int trap(vector<int>& height) { } };",
      "java": "class Solution { public int trap(int[] height) { } }",
      "javascript": "/** * @param {number[]} height * @return {number} */ var trap = function(height) { };",
      "python": "class Solution(object): def trap(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:34 PM UTC+7",
    "editorial": {
      "content": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:39:34 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int trap(vector<int>& height) { } };",
            "java": "class Solution { public int trap(int[] height) { } }",
            "javascript": "/** * @param {number[]} height * @return {number} */ var trap = function(height) { };",
            "python": "class Solution(object): def trap(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "multiply-strings",
    "title": "Multiply Strings",
    "acceptance": 0.4335462667295392,
    "difficulty": "Medium",
    "likes": 7647,
    "dislikes": 3651,
    "stars": null,
    "tags": [
      "math",
      "string",
      "simulation"
    ],
    "description": "Cho hai không âm các số nguyên num1 và num2 được biểu diễn như các chuỗi, trả về product của num1 và num2, cũng được biểu diễn như một chuỗi. Lưu ý: Bạn phải không dùng bất kỳ built-trong BigInteger library hoặc chuyển đổi đầu vào để số nguyên directly.",
    "constraints": [
      "1 <= num1.length, num2.length <= 200 num1 và num2 consist của các chữ số chỉ. Both num1 và num2 làm không chứa bất kỳ ở đầu 0, ngoại trừ số 0 chính nó."
    ],
    "examples": [
      {
        "input": "num1 = \"2\", num2 = \"3\"",
        "output": "\"6\"",
        "explanation": ""
      },
      {
        "input": "num1 = \"123\", num2 = \"456\"",
        "output": "\"56088\"",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: string multiply(string num1, string num2) { } };",
      "java": "class Solution { public String multiply(String num1, String num2) { } }",
      "javascript": "/** * @param {string} num1 * @param {string} num2 * @return {string} */ var multiply = function(num1, num2) { };",
      "python": "class Solution(object): def multiply(self, num1, num2): \"\"\" :type num1: str :type num2: str :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:35 PM UTC+7",
    "editorial": {
      "content": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:35 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Math / Simulation",
          "description": "Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: string multiply(string num1, string num2) { } };",
            "java": "class Solution { public String multiply(String num1, String num2) { } }",
            "javascript": "/** * @param {string} num1 * @param {string} num2 * @return {string} */ var multiply = function(num1, num2) { };",
            "python": "class Solution(object): def multiply(self, num1, num2): \"\"\" :type num1: str :type num2: str :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "wildcard-matching",
    "title": "Wildcard Matching",
    "acceptance": 0.31130349555253106,
    "difficulty": "Hard",
    "likes": 9024,
    "dislikes": 409,
    "stars": null,
    "tags": [
      "string",
      "dynamic-programming",
      "greedy",
      "recursion"
    ],
    "description": "Cho một đầu vào chuỗi (s) và một mẫu (p), cài đặt wildcard mẫu khớp với support cho '?' và '*' ở đâu: '?' Khớp bất kỳ một ký tự. '*' Khớp bất kỳ dãy của các ký tự (including rỗng dãy). khớp nên bao phủ toàn bộ đầu vào chuỗi (không một phần).",
    "constraints": [
      "0 <= s.length, p.length <= 2000",
      "s Chỉ chứa chữ thường Tiếng Anh các chữ cái.",
      "p Chỉ chứa chữ thường Tiếng Anh các chữ cái, '?' hoặc '*'."
    ],
    "examples": [
      {
        "input": "s = \"aa\", p = \"a\"",
        "output": "false",
        "explanation": "\"a\" không khớp toàn bộ chuỗi \"aa\"."
      },
      {
        "input": "s = \"aa\", p = \"*\"",
        "output": "true",
        "explanation": "'*' khớp bất kỳ dãy."
      },
      {
        "input": "s = \"cb\", p = \"?a\"",
        "output": "false",
        "explanation": "'?' khớp 'c', but thứ hai chữ cái là 'một', nào không khớp 'b'."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool isMatch(string s, string p) { } };",
      "java": "class Solution { public boolean isMatch(String s, String p) { } }",
      "javascript": "/** * @param {string} s * @param {string} p * @return {boolean} */ var isMatch = function(s, p) { };",
      "python": "class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:35 PM UTC+7",
    "editorial": {
      "content": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where: '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial).\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:39:35 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: bool isMatch(string s, string p) { } };",
            "java": "class Solution { public boolean isMatch(String s, String p) { } }",
            "javascript": "/** * @param {string} s * @param {string} p * @return {boolean} */ var isMatch = function(s, p) { };",
            "python": "class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "jump-game-ii",
    "title": "Jump Game II",
    "acceptance": 0.42302193907831426,
    "difficulty": "Medium",
    "likes": 16242,
    "dislikes": 696,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming",
      "greedy"
    ],
    "description": "Bạn được cho một 0-chỉ số mảng của các số nguyên nums của độ dài n. Bạn là initially vị trí tại chỉ số 0. Each phần tử nums[i] biểu diễn lớn nhất độ dài của một forward jump từ chỉ số i. Trong other words, nếu bạn là tại chỉ số i, Bạn có thể jump để bất kỳ chỉ số (i + j) ở đâu: 0 <= j <= nums[i] và i + j < n Trả về nhỏ nhất số của jumps để reach chỉ số n - 1. test trường hợp là generated Sao cho Bạn có thể reach chỉ số n - 1.",
    "constraints": [
      "1 <= nums.length <= 104",
      "0 <= nums[i] <= 1000 It's được đảm bảo đó Bạn có thể reach nums[n - 1]."
    ],
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "2",
        "explanation": "nhỏ nhất số của jumps để reach last chỉ số là 2. Jump 1 bước từ chỉ số 0 để 1, thì 3 các bước để last chỉ số."
      },
      {
        "input": "nums = [2,3,0,1,4]",
        "output": "2",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int jump(vector<int>& nums) { } };",
      "java": "class Solution { public int jump(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var jump = function(nums) { };",
      "python": "class Solution(object): def jump(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:36 PM UTC+7",
    "editorial": {
      "content": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at index 0. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at index i, you can jump to any index (i + j) where: 0 <= j <= nums[i] and i + j < n Return the minimum number of jumps to reach index n - 1. The test cases are generated such that you can reach index n - 1.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn. Chọn quyết định cục bộ tối ưu và chứng minh rằng nó dẫn tới tối ưu toàn cục.",
      "lastUpdated": "January 13, 2026 at 3:39:36 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int jump(vector<int>& nums) { } };",
            "java": "class Solution { public int jump(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var jump = function(nums) { };",
            "python": "class Solution(object): def jump(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "permutations",
    "title": "Permutations",
    "acceptance": 0.8147342452339355,
    "difficulty": "Medium",
    "likes": 20620,
    "dislikes": 379,
    "stars": null,
    "tags": [
      "array",
      "backtracking"
    ],
    "description": "Cho một mảng nums của phân biệt các số nguyên, trả về tất cả có thể các hoán vị. Bạn có thể trả về đáp án Theo bất kỳ thứ tự nào.",
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 <= nums[i] <= 10 Tất cả các số nguyên của nums là không trùng lặp."
    ],
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": ""
      },
      {
        "input": "nums = [0,1]",
        "output": "[[0,1],[1,0]]",
        "explanation": ""
      },
      {
        "input": "nums = [1]",
        "output": "[[1]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> permute(vector<int>& nums) { } };",
      "java": "class Solution { public List<List<Integer>> permute(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number[][]} */ var permute = function(nums) { };",
      "python": "class Solution(object): def permute(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:37 PM UTC+7",
    "editorial": {
      "content": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n\nGợi ý hướng giải: Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
      "lastUpdated": "January 13, 2026 at 3:39:37 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> permute(vector<int>& nums) { } };",
            "java": "class Solution { public List<List<Integer>> permute(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number[][]} */ var permute = function(nums) { };",
            "python": "class Solution(object): def permute(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "permutations-ii",
    "title": "Permutations II",
    "acceptance": 0.6274564354440634,
    "difficulty": "Medium",
    "likes": 9054,
    "dislikes": 161,
    "stars": null,
    "tags": [
      "array",
      "backtracking",
      "sorting"
    ],
    "description": "Cho một collection của các số, nums, đó might chứa trùng lặp, trả về tất cả có thể không trùng lặp các hoán vị Theo bất kỳ thứ tự nào.",
    "constraints": [
      "1 <= nums.length <= 8",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "[[1,1,2], [1,2,1], [2,1,1]]",
        "explanation": ""
      },
      {
        "input": "nums = [1,2,3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> permuteUnique(vector<int>& nums) { } };",
      "java": "class Solution { public List<List<Integer>> permuteUnique(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number[][]} */ var permuteUnique = function(nums) { };",
      "python": "class Solution(object): def permuteUnique(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:38 PM UTC+7",
    "editorial": {
      "content": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\nGợi ý hướng giải: Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu). Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
      "lastUpdated": "January 13, 2026 at 3:39:38 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Sorting",
          "description": "Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
          "timeComplexity": "$O(n\\log n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(n)$",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> permuteUnique(vector<int>& nums) { } };",
            "java": "class Solution { public List<List<Integer>> permuteUnique(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number[][]} */ var permuteUnique = function(nums) { };",
            "python": "class Solution(object): def permuteUnique(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "rotate-image",
    "title": "Rotate Image",
    "acceptance": 0.7910672472702076,
    "difficulty": "Medium",
    "likes": 19576,
    "dislikes": 945,
    "stars": null,
    "tags": [
      "array",
      "math",
      "matrix"
    ],
    "description": "Bạn được cho một n x n 2D matrix biểu diễn một image, xoay image bởi 90 degrees (clockwise). Bạn có để xoay image trong-place, nào means bạn có để modify đầu vào 2D matrix directly. Làm Không allocate another 2D matrix và làm rotation.",
    "constraints": [
      "n == matrix.length == matrix[i].độ dài",
      "1 <= n <= 20",
      "-1000 <= matrix[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]",
        "explanation": ""
      },
      {
        "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
        "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: void rotate(vector<vector<int>>& matrix) { } };",
      "java": "class Solution { public void rotate(int[][] matrix) { } }",
      "javascript": "/** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */ var rotate = function(matrix) { };",
      "python": "class Solution(object): def rotate(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: None Do not return anything, modify matrix in-place instead. \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:38 PM UTC+7",
    "editorial": {
      "content": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Duyệt ma trận theo hàng/cột/biên; dùng đánh dấu hoặc visited nếu cần.",
      "lastUpdated": "January 13, 2026 at 3:39:38 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Math / Simulation",
          "description": "Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: void rotate(vector<vector<int>>& matrix) { } };",
            "java": "class Solution { public void rotate(int[][] matrix) { } }",
            "javascript": "/** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */ var rotate = function(matrix) { };",
            "python": "class Solution(object): def rotate(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: None Do not return anything, modify matrix in-place instead. \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "group-anagrams",
    "title": "Group Anagrams",
    "acceptance": 0.7195709108764077,
    "difficulty": "Medium",
    "likes": 21646,
    "dislikes": 742,
    "stars": null,
    "tags": [
      "array",
      "hash-table",
      "string",
      "sorting"
    ],
    "description": "Cho một mảng của các chuỗi strs, group anagrams cùng. Bạn có thể trả về đáp án Theo bất kỳ thứ tự nào.",
    "constraints": [
      "1 <= strs.length <= 104",
      "0 <= strs[i].độ dài <= 100 strs[i] Gồm chữ thường Tiếng Anh các chữ cái."
    ],
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": "Có không chuỗi trong strs đó có thể là rearranged để tạo thành \"bat\". các chuỗi \"nat\" và \"tan\" là anagrams như họ có thể là rearranged để tạo thành each other. các chuỗi \"ate\", \"eat\", và \"tea\" là anagrams như họ có thể là rearranged để tạo thành each other."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": ""
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<string>> groupAnagrams(vector<string>& strs) { } };",
      "java": "class Solution { public List<List<String>> groupAnagrams(String[] strs) { } }",
      "javascript": "/** * @param {string[]} strs * @return {string[][]} */ var groupAnagrams = function(strs) { };",
      "python": "class Solution(object): def groupAnagrams(self, strs): \"\"\" :type strs: List[str] :rtype: List[List[str]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:39 PM UTC+7",
    "editorial": {
      "content": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:39 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: vector<vector<string>> groupAnagrams(vector<string>& strs) { } };",
            "java": "class Solution { public List<List<String>> groupAnagrams(String[] strs) { } }",
            "javascript": "/** * @param {string[]} strs * @return {string[][]} */ var groupAnagrams = function(strs) { };",
            "python": "class Solution(object): def groupAnagrams(self, strs): \"\"\" :type strs: List[str] :rtype: List[List[str]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "powx-n",
    "title": "Pow(x, n)",
    "acceptance": 0.38050756996263646,
    "difficulty": "Medium",
    "likes": 11418,
    "dislikes": 10477,
    "stars": null,
    "tags": [
      "math",
      "recursion"
    ],
    "description": "Cài đặt pow(x, n), nào tính x raised để power n (i.e., xn).",
    "constraints": [
      "-100.0 < x < 100.0",
      "-231 <= n <= 231-1 n is an integer. Either x is not zero or n > 0.",
      "-104 <= xn <= 104"
    ],
    "examples": [
      {
        "input": "x = 2.00000, n = 10",
        "output": "1024.00000",
        "explanation": ""
      },
      {
        "input": "x = 2.10000, n = 3",
        "output": "9.26100",
        "explanation": ""
      },
      {
        "input": "x = 2.00000, n = -2",
        "output": "0.25000",
        "explanation": "2-2 = 1/22 = 1/4 = 0.25"
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: double myPow(double x, int n) { } };",
      "java": "class Solution { public double myPow(double x, int n) { } }",
      "javascript": "/** * @param {number} x * @param {number} n * @return {number} */ var myPow = function(x, n) { };",
      "python": "class Solution(object): def myPow(self, x, n): \"\"\" :type x: float :type n: int :rtype: float \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:40 PM UTC+7",
    "editorial": {
      "content": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Dùng đệ quy để biểu diễn bài toán con; có thể kết hợp memoization để tránh lặp.",
      "lastUpdated": "January 13, 2026 at 3:39:40 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Math / Simulation",
          "description": "Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: double myPow(double x, int n) { } };",
            "java": "class Solution { public double myPow(double x, int n) { } }",
            "javascript": "/** * @param {number} x * @param {number} n * @return {number} */ var myPow = function(x, n) { };",
            "python": "class Solution(object): def myPow(self, x, n): \"\"\" :type x: float :type n: int :rtype: float \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "n-queens",
    "title": "N-Queens",
    "acceptance": 0.7464166102557303,
    "difficulty": "Hard",
    "likes": 14037,
    "dislikes": 341,
    "stars": null,
    "tags": [
      "array",
      "backtracking"
    ],
    "description": "n-queens puzzle là problem của placing n queens trên một n x n chessboard Sao cho không hai queens attack each other. Cho một số nguyên n, trả về tất cả phân biệt các lời giải để n-queens puzzle. Bạn có thể trả về đáp án Theo bất kỳ thứ tự nào. Each lời giải chứa một phân biệt bảng configuration của n-queens' placement, ở đâu 'Q' và '.' both indicate một queen và một rỗng bộ nhớ, tương ứng.",
    "constraints": [
      "1 <= n <= 9"
    ],
    "examples": [
      {
        "input": "n = 4",
        "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
        "explanation": "Có tồn tại hai phân biệt các lời giải để 4-queens puzzle như shown bên trên"
      },
      {
        "input": "n = 1",
        "output": "[[\"Q\"]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<string>> solveNQueens(int n) { } };",
      "java": "class Solution { public List<List<String>> solveNQueens(int n) { } }",
      "javascript": "/** * @param {number} n * @return {string[][]} */ var solveNQueens = function(n) { };",
      "python": "class Solution(object): def solveNQueens(self, n): \"\"\" :type n: int :rtype: List[List[str]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:41 PM UTC+7",
    "editorial": {
      "content": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n\nGợi ý hướng giải: Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
      "lastUpdated": "January 13, 2026 at 3:39:41 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "class Solution { public: vector<vector<string>> solveNQueens(int n) { } };",
            "java": "class Solution { public List<List<String>> solveNQueens(int n) { } }",
            "javascript": "/** * @param {number} n * @return {string[][]} */ var solveNQueens = function(n) { };",
            "python": "class Solution(object): def solveNQueens(self, n): \"\"\" :type n: int :rtype: List[List[str]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "n-queens-ii",
    "title": "N-Queens II",
    "acceptance": 0.779347269683596,
    "difficulty": "Hard",
    "likes": 4228,
    "dislikes": 282,
    "stars": null,
    "tags": [
      "backtracking"
    ],
    "description": "n-queens puzzle là problem của placing n queens trên một n x n chessboard Sao cho không hai queens attack each other. Cho một số nguyên n, trả về số của phân biệt các lời giải để n-queens puzzle.",
    "constraints": [
      "1 <= n <= 9"
    ],
    "examples": [
      {
        "input": "n = 4",
        "output": "2",
        "explanation": "Có hai phân biệt các lời giải để 4-queens puzzle như shown."
      },
      {
        "input": "n = 1",
        "output": "1",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int totalNQueens(int n) { } };",
      "java": "class Solution { public int totalNQueens(int n) { } }",
      "javascript": "/** * @param {number} n * @return {number} */ var totalNQueens = function(n) { };",
      "python": "class Solution(object): def totalNQueens(self, n): \"\"\" :type n: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:42 PM UTC+7",
    "editorial": {
      "content": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n\nGợi ý hướng giải: Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
      "lastUpdated": "January 13, 2026 at 3:39:42 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "class Solution { public: int totalNQueens(int n) { } };",
            "java": "class Solution { public int totalNQueens(int n) { } }",
            "javascript": "/** * @param {number} n * @return {number} */ var totalNQueens = function(n) { };",
            "python": "class Solution(object): def totalNQueens(self, n): \"\"\" :type n: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "maximum-subarray",
    "title": "Maximum Subarray",
    "acceptance": 0.5280851651225026,
    "difficulty": "Medium",
    "likes": 37216,
    "dislikes": 1579,
    "stars": null,
    "tags": [
      "array",
      "divide-and-conquer",
      "dynamic-programming"
    ],
    "description": "Cho một số nguyên mảng nums, tìm mảng con với lớn nhất tổng, và trả về nó tổng.",
    "constraints": [
      "1 <= nums.length <= 105",
      "-104 <= nums[i] <= 104 Câu hỏi thêm: Nếu bạn có figured out O(n) lời giải, Hãy thử coding another lời giải using chia và conquer approach, nào là nhiều hơn subtle.",
      "-104 <= nums[i] <= 104 Câu hỏi thêm: Nếu bạn có figured out O(n)"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "mảng con [4,-1,2,1] có lớn nhất tổng 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "mảng con [1] có lớn nhất tổng 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "mảng con [5,4,-1,7,8] có lớn nhất tổng 23."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int maxSubArray(vector<int>& nums) { } };",
      "java": "class Solution { public int maxSubArray(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var maxSubArray = function(nums) { };",
      "python": "class Solution(object): def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:43 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nGợi ý hướng giải: Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:39:43 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int maxSubArray(vector<int>& nums) { } };",
            "java": "class Solution { public int maxSubArray(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var maxSubArray = function(nums) { };",
            "python": "class Solution(object): def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "spiral-matrix",
    "title": "Spiral Matrix",
    "acceptance": 0.5578170221219899,
    "difficulty": "Medium",
    "likes": 17071,
    "dislikes": 1534,
    "stars": null,
    "tags": [
      "array",
      "matrix",
      "simulation"
    ],
    "description": "Cho một m x n matrix, trả về tất cả các phần tử của matrix trong spiral thứ tự.",
    "constraints": [
      "m == matrix.length n == matrix[i].độ dài",
      "1 <= m, n <= 10",
      "-100 <= matrix[i][j] <= 100"
    ],
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[1,2,3,6,9,8,7,4,5]",
        "explanation": ""
      },
      {
        "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
        "output": "[1,2,3,4,8,12,11,10,9,5,6,7]",
        "explanation": ""
      }
    ],
    "content": "Well cho một số problems, tốt nhất way really là để đưa ra một số các thuật toán cho simulation. Basically, bạn need để simulate điều gì problem asks us để làm. Chúng ta go boundary bởi boundary và di chuyển inwards. Đó là essential thao tác. Đầu tiên hàng, last cột, last hàng, đầu tiên cột, và thì chúng ta di chuyển inwards bởi 1 và repeat. That's tất cả. Đó là tất cả simulation đó chúng ta need. Think about khi nào bạn want để switch progress trên một của chỉ số. Nếu bạn progress trên i out của [i, j], you'll shift trong giống nhau cột. Similarly, bởi changing các giá trị cho j, you'd là shifting trong giống nhau hàng. Cũng, giữ track của kết thúc của một boundary vì vậy đó Bạn có thể di chuyển inwards và thì giữ repeating. It's always tốt nhất để simulate cạnh trường hợp like một một cột hoặc một một hàng để see nếu anything breaks hoặc không.",
    "defaultCode": {
      "cpp": "class Solution { public: vector<int> spiralOrder(vector<vector<int>>& matrix) { } };",
      "java": "class Solution { public List<Integer> spiralOrder(int[][] matrix) { } }",
      "javascript": "/** * @param {number[][]} matrix * @return {number[]} */ var spiralOrder = function(matrix) { };",
      "python": "class Solution(object): def spiralOrder(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:43 PM UTC+7",
    "editorial": {
      "content": "Given an m x n matrix, return all elements of the matrix in spiral order.\n\nHint/nhắc ý (crawl được): Well for some problems, the best way really is to come up with some algorithms for simulation. Basically, you need to simulate what the problem asks us to do. We go boundary by boundary and move inwards. That is the essential operation. First row, last column, last row, first column, and then we move inwards by 1 and repeat. That's all. That is all the simulation that we need. Think about when you want to switch the progress on one of the indexes. If you progress on i out of [i, j], you'll shift in the same column. Similarly, by changing values for j, you'd be shifting in the same row. Also, keep track of the end of a boundary so that you can move inwards and then keep repeating. It's always best to simulate edge cases like a single column or a single row to see if anything breaks or not.\n\nGợi ý hướng giải: Duyệt ma trận theo hàng/cột/biên; dùng đánh dấu hoặc visited nếu cần. Mô phỏng đúng theo đề bài, quản lý trạng thái và các biên cẩn thận.",
      "lastUpdated": "January 13, 2026 at 3:39:43 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Matrix Traversal",
          "description": "Duyệt ma trận theo hàng/cột/biên; dùng đánh dấu hoặc visited nếu cần.",
          "timeComplexity": "$O(m\\cdot n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(m\\cdot n)$",
          "code": {
            "cpp": "class Solution { public: vector<int> spiralOrder(vector<vector<int>>& matrix) { } };",
            "java": "class Solution { public List<Integer> spiralOrder(int[][] matrix) { } }",
            "javascript": "/** * @param {number[][]} matrix * @return {number[]} */ var spiralOrder = function(matrix) { };",
            "python": "class Solution(object): def spiralOrder(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: List[int] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "jump-game",
    "title": "Jump Game",
    "acceptance": 0.40308887112203917,
    "difficulty": "Medium",
    "likes": 21427,
    "dislikes": 1469,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming",
      "greedy"
    ],
    "description": "Bạn được cho một số nguyên mảng nums. Bạn là initially vị trí tại array's đầu tiên chỉ số, và each phần tử trong mảng biểu diễn của bạn lớn nhất jump độ dài tại đó vị trí. Trả về đúng nếu Bạn có thể reach last chỉ số, hoặc sai otherwise.",
    "constraints": [
      "1 <= nums.length <= 104",
      "0 <= nums[i] <= 105"
    ],
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "true",
        "explanation": "Jump 1 bước từ chỉ số 0 để 1, thì 3 các bước để last chỉ số."
      },
      {
        "input": "nums = [3,2,1,0,4]",
        "output": "false",
        "explanation": "Bạn sẽ always arrive tại chỉ số 3 không matter điều gì. Nó lớn nhất jump độ dài là 0, nào tạo nó impossible để reach last chỉ số."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool canJump(vector<int>& nums) { } };",
      "java": "class Solution { public boolean canJump(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {boolean} */ var canJump = function(nums) { };",
      "python": "class Solution(object): def canJump(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:44 PM UTC+7",
    "editorial": {
      "content": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn. Chọn quyết định cục bộ tối ưu và chứng minh rằng nó dẫn tới tối ưu toàn cục.",
      "lastUpdated": "January 13, 2026 at 3:39:44 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: bool canJump(vector<int>& nums) { } };",
            "java": "class Solution { public boolean canJump(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {boolean} */ var canJump = function(nums) { };",
            "python": "class Solution(object): def canJump(self, nums): \"\"\" :type nums: List[int] :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "merge-intervals",
    "title": "Merge Intervals",
    "acceptance": 0.5083243830445073,
    "difficulty": "Medium",
    "likes": 24279,
    "dislikes": 891,
    "stars": null,
    "tags": [
      "array",
      "sorting"
    ],
    "description": "Cho một mảng của intervals ở đâu intervals[i] = [starti, endi], gộp tất cả overlapping intervals, và trả về một mảng của không-overlapping intervals đó bao phủ tất cả intervals trong đầu vào.",
    "constraints": [
      "1 <= intervals.length <= 104 intervals[i].độ dài == 2",
      "0 <= starti <= endi <= 104"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Vì intervals [1,3] và [2,6] overlap, gộp chúng thành [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] và [4,5] là considered overlapping."
      },
      {
        "input": "intervals = [[4,7],[1,4]]",
        "output": "[[1,7]]",
        "explanation": "Intervals [1,4] và [4,7] là considered overlapping."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> merge(vector<vector<int>>& intervals) { } };",
      "java": "class Solution { public int[][] merge(int[][] intervals) { } }",
      "javascript": "/** * @param {number[][]} intervals * @return {number[][]} */ var merge = function(intervals) { };",
      "python": "class Solution(object): def merge(self, intervals): \"\"\" :type intervals: List[List[int]] :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:45 PM UTC+7",
    "editorial": {
      "content": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nGợi ý hướng giải: Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
      "lastUpdated": "January 13, 2026 at 3:39:45 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Sorting",
          "description": "Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
          "timeComplexity": "$O(n\\log n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(n)$",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> merge(vector<vector<int>>& intervals) { } };",
            "java": "class Solution { public int[][] merge(int[][] intervals) { } }",
            "javascript": "/** * @param {number[][]} intervals * @return {number[][]} */ var merge = function(intervals) { };",
            "python": "class Solution(object): def merge(self, intervals): \"\"\" :type intervals: List[List[int]] :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "insert-interval",
    "title": "Insert Interval",
    "acceptance": 0.4454541319140624,
    "difficulty": "Medium",
    "likes": 11647,
    "dislikes": 908,
    "stars": null,
    "tags": [
      "array"
    ],
    "description": "Bạn được cho một mảng của không-overlapping intervals intervals ở đâu intervals[i] = [starti, endi] biểu diễn bắt đầu và kết thúc của ith interval và intervals là đã sắp xếp trong thứ tự tăng dần bởi starti. Bạn là cũng cho một interval newInterval = [bắt đầu, kết thúc] đó biểu diễn bắt đầu và kết thúc của another interval. Chèn newInterval thành intervals Sao cho intervals là still đã sắp xếp trong thứ tự tăng dần bởi starti và intervals still không có bất kỳ overlapping intervals (gộp overlapping intervals nếu necessary). Trả về intervals sau insertion. Lưu ý rằng bạn don't need để modify intervals trong-place. Bạn có thể tạo một new mảng và trả về nó.",
    "constraints": [
      "0 <= intervals.length <= 104 intervals[i].độ dài == 2",
      "0 <= starti <= endi <= 105 intervals là đã sắp xếp bởi starti trong thứ tự tăng dần. newInterval.length == 2",
      "0 <= bắt đầu <= kết thúc <= 105"
    ],
    "examples": [
      {
        "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
        "output": "[[1,5],[6,9]]",
        "explanation": ""
      },
      {
        "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
        "output": "[[1,2],[3,10],[12,16]]",
        "explanation": "Vì new interval [4,8] overlaps với [3,5],[6,7],[8,10]."
      }
    ],
    "content": "Intervals Mảng là đã sắp xếp. Bạn có thể dùng Nhị phân Tìm kiếm để tìm correct vị trí để chèn new Interval.? Bạn có thể Hãy thử merging overlapping intervals trong khi chèn new interval? Điều này có thể là done bởi comparing kết thúc của last interval với bắt đầu của new interval và vice versa.",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) { } };",
      "java": "class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { } }",
      "javascript": "/** * @param {number[][]} intervals * @param {number[]} newInterval * @return {number[][]} */ var insert = function(intervals, newInterval) { };",
      "python": "class Solution(object): def insert(self, intervals, newInterval): \"\"\" :type intervals: List[List[int]] :type newInterval: List[int] :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:46 PM UTC+7",
    "editorial": {
      "content": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Note that you don't need to modify intervals in-place. You can make a new array and return it.\n\nHint/nhắc ý (crawl được): Intervals Array is sorted. Can you use Binary Search to find the correct position to insert the new Interval.? Can you try merging the overlapping intervals while inserting the new interval? This can be done by comparing the end of the last interval with the start of the new interval and vice versa.",
      "lastUpdated": "January 13, 2026 at 3:39:46 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) { } };",
            "java": "class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { } }",
            "javascript": "/** * @param {number[][]} intervals * @param {number[]} newInterval * @return {number[][]} */ var insert = function(intervals, newInterval) { };",
            "python": "class Solution(object): def insert(self, intervals, newInterval): \"\"\" :type intervals: List[List[int]] :type newInterval: List[int] :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "length-of-last-word",
    "title": "Length of Last Word",
    "acceptance": 0.5794796669531413,
    "difficulty": "Easy",
    "likes": 6231,
    "dislikes": 350,
    "stars": null,
    "tags": [
      "string"
    ],
    "description": "Cho một chuỗi s consisting của words và dấu cách, trả về độ dài của last word trong chuỗi. Một word là một maximal chuỗi con consisting của không-bộ nhớ các ký tự chỉ.",
    "constraints": [
      "1 <= s.length <= 104 s Gồm chỉ Tiếng Anh các chữ cái và dấu cách ' '.",
      "Có sẽ là Ít nhất một word trong s."
    ],
    "examples": [
      {
        "input": "s = \"Hello World\"",
        "output": "5",
        "explanation": "last word là \"World\" với độ dài 5."
      },
      {
        "input": "s = \" fly me to the moon \"",
        "output": "4",
        "explanation": "last word là \"moon\" với độ dài 4."
      },
      {
        "input": "s = \"luffy is still joyboy\"",
        "output": "6",
        "explanation": "last word là \"joyboy\" với độ dài 6."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int lengthOfLastWord(string s) { } };",
      "java": "class Solution { public int lengthOfLastWord(String s) { } }",
      "javascript": "/** * @param {string} s * @return {number} */ var lengthOfLastWord = function(s) { };",
      "python": "class Solution(object): def lengthOfLastWord(self, s): \"\"\" :type s: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:47 PM UTC+7",
    "editorial": {
      "content": "Given a string s consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:47 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "String Processing",
          "description": "Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(n)$",
          "code": {
            "cpp": "class Solution { public: int lengthOfLastWord(string s) { } };",
            "java": "class Solution { public int lengthOfLastWord(String s) { } }",
            "javascript": "/** * @param {string} s * @return {number} */ var lengthOfLastWord = function(s) { };",
            "python": "class Solution(object): def lengthOfLastWord(self, s): \"\"\" :type s: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "spiral-matrix-ii",
    "title": "Spiral Matrix II",
    "acceptance": 0.744464135300171,
    "difficulty": "Medium",
    "likes": 6846,
    "dislikes": 283,
    "stars": null,
    "tags": [
      "array",
      "matrix",
      "simulation"
    ],
    "description": "Cho một dương số nguyên n, generate một n x n ma trận filled với các phần tử từ 1 để n2 trong spiral thứ tự.",
    "constraints": [
      "1 <= n <= 20"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1,2,3],[8,9,4],[7,6,5]]",
        "explanation": ""
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> generateMatrix(int n) { } };",
      "java": "class Solution { public int[][] generateMatrix(int n) { } }",
      "javascript": "/** * @param {number} n * @return {number[][]} */ var generateMatrix = function(n) { };",
      "python": "class Solution(object): def generateMatrix(self, n): \"\"\" :type n: int :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:47 PM UTC+7",
    "editorial": {
      "content": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n\nGợi ý hướng giải: Duyệt ma trận theo hàng/cột/biên; dùng đánh dấu hoặc visited nếu cần. Mô phỏng đúng theo đề bài, quản lý trạng thái và các biên cẩn thận.",
      "lastUpdated": "January 13, 2026 at 3:39:47 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Matrix Traversal",
          "description": "Duyệt ma trận theo hàng/cột/biên; dùng đánh dấu hoặc visited nếu cần.",
          "timeComplexity": "$O(m\\cdot n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(m\\cdot n)$",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> generateMatrix(int n) { } };",
            "java": "class Solution { public int[][] generateMatrix(int n) { } }",
            "javascript": "/** * @param {number} n * @return {number[][]} */ var generateMatrix = function(n) { };",
            "python": "class Solution(object): def generateMatrix(self, n): \"\"\" :type n: int :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "permutation-sequence",
    "title": "Permutation Sequence",
    "acceptance": 0.5176449514489637,
    "difficulty": "Hard",
    "likes": 7176,
    "dislikes": 502,
    "stars": null,
    "tags": [
      "math",
      "recursion"
    ],
    "description": "tập hợp [1, 2, 3,..., n] chứa một total của n! không trùng lặp các hoán vị. Bởi danh sách và labeling tất cả của các hoán vị trong thứ tự, chúng ta get sau đây dãy cho n = 3: \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" Cho n và k, trả về kth hoán vị dãy.",
    "constraints": [
      "1 <= n <= 9",
      "1 <= k <= n!"
    ],
    "examples": [
      {
        "input": "n = 3, k = 3",
        "output": "\"213\"",
        "explanation": ""
      },
      {
        "input": "n = 4, k = 9",
        "output": "\"2314\"",
        "explanation": ""
      },
      {
        "input": "n = 3, k = 1",
        "output": "\"123\"",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: string getPermutation(int n, int k) { } };",
      "java": "class Solution { public String getPermutation(int n, int k) { } }",
      "javascript": "/** * @param {number} n * @param {number} k * @return {string} */ var getPermutation = function(n, k) { };",
      "python": "class Solution(object): def getPermutation(self, n, k): \"\"\" :type n: int :type k: int :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:48 PM UTC+7",
    "editorial": {
      "content": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" Given n and k, return the kth permutation sequence.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Dùng đệ quy để biểu diễn bài toán con; có thể kết hợp memoization để tránh lặp.",
      "lastUpdated": "January 13, 2026 at 3:39:48 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Math / Simulation",
          "description": "Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: string getPermutation(int n, int k) { } };",
            "java": "class Solution { public String getPermutation(int n, int k) { } }",
            "javascript": "/** * @param {number} n * @param {number} k * @return {string} */ var getPermutation = function(n, k) { };",
            "python": "class Solution(object): def getPermutation(self, n, k): \"\"\" :type n: int :type k: int :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "rotate-list",
    "title": "Rotate List",
    "acceptance": 0.4096734657523992,
    "difficulty": "Medium",
    "likes": 11046,
    "dislikes": 1538,
    "stars": null,
    "tags": [
      "linked-list",
      "two-pointers"
    ],
    "description": "Cho head của một danh sách liên kết, xoay danh sách để right bởi k places.",
    "constraints": [
      "số của các nút trong danh sách là Trong khoảng [0, 500].",
      "-100 <= Node.val <= 100",
      "0 <= k <= 2 * 109"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[4,5,1,2,3]",
        "explanation": ""
      },
      {
        "input": "head = [0,1,2], k = 4",
        "output": "[2,0,1]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode rotateRight(ListNode head, int k) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} k * @return {ListNode} */ var rotateRight = function(head, k) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def rotateRight(self, head, k): \"\"\" :type head: Optional[ListNode] :type k: int :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:49 PM UTC+7",
    "editorial": {
      "content": "Given the head of a linked list, rotate the list to the right by k places.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
      "lastUpdated": "January 13, 2026 at 3:39:49 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode rotateRight(ListNode head, int k) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} k * @return {ListNode} */ var rotateRight = function(head, k) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def rotateRight(self, head, k): \"\"\" :type head: Optional[ListNode] :type k: int :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "unique-paths",
    "title": "Unique Paths",
    "acceptance": 0.6643371066625615,
    "difficulty": "Medium",
    "likes": 18145,
    "dislikes": 490,
    "stars": null,
    "tags": [
      "math",
      "dynamic-programming",
      "combinatorics"
    ],
    "description": "Có một robot trên một m x n lưới. robot là initially located tại top-left corner (i.e., lưới[0][0]). robot Trie để di chuyển để dưới cùng-right corner (i.e., lưới[m - 1][n - 1]). robot có thể chỉ di chuyển một trong hai down hoặc right tại bất kỳ point trong thời gian. Cho hai các số nguyên m và n, trả về số của có thể không trùng lặp các đường đi đó robot có thể take để reach dưới cùng-right corner. test trường hợp là generated vì vậy đó đáp án sẽ là nhỏ hơn hoặc bằng để 2 * 109.",
    "constraints": [
      "1 <= m, n <= 100"
    ],
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": ""
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "Từ top-left corner, Có một total của 3 ways để reach dưới cùng-right corner: 1. Right -> Down -> Down 2. Down -> Down -> Right 3. Down -> Right -> Down"
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int uniquePaths(int m, int n) { } };",
      "java": "class Solution { public int uniquePaths(int m, int n) { } }",
      "javascript": "/** * @param {number} m * @param {number} n * @return {number} */ var uniquePaths = function(m, n) { };",
      "python": "class Solution(object): def uniquePaths(self, m, n): \"\"\" :type m: int :type n: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:49 PM UTC+7",
    "editorial": {
      "content": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:39:49 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int uniquePaths(int m, int n) { } };",
            "java": "class Solution { public int uniquePaths(int m, int n) { } }",
            "javascript": "/** * @param {number} m * @param {number} n * @return {number} */ var uniquePaths = function(m, n) { };",
            "python": "class Solution(object): def uniquePaths(self, m, n): \"\"\" :type m: int :type n: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "unique-paths-ii",
    "title": "Unique Paths II",
    "acceptance": 0.4398465119909753,
    "difficulty": "Medium",
    "likes": 9578,
    "dislikes": 555,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming",
      "matrix"
    ],
    "description": "Bạn được cho một m x n số nguyên mảng lưới. Có một robot initially located tại top-left corner (i.e., lưới[0][0]). robot Trie để di chuyển để dưới cùng-right corner (i.e., lưới[m - 1][n - 1]). robot có thể chỉ di chuyển một trong hai down hoặc right tại bất kỳ point trong thời gian. Một obstacle và bộ nhớ là marked như 1 hoặc 0 tương ứng trong lưới. Một đường đi đó robot takes không thể include bất kỳ square đó là một obstacle. Trả về số của có thể không trùng lặp các đường đi đó robot có thể take để reach dưới cùng-right corner. testcases là generated vì vậy đó đáp án sẽ là nhỏ hơn hoặc bằng để 2 * 109.",
    "constraints": [
      "m == obstacleGrid.length n == obstacleGrid[i].độ dài",
      "1 <= m, n <= 100 obstacleGrid[i][j] là 0 hoặc 1."
    ],
    "examples": [
      {
        "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2",
        "explanation": "Có một obstacle trong middle của 3x3 lưới bên trên. Có hai ways để reach dưới cùng-right corner: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right"
      },
      {
        "input": "obstacleGrid = [[0,1],[0,0]]",
        "output": "1",
        "explanation": ""
      }
    ],
    "content": "Dùng dynamic programming vì, từ each cell, Bạn có thể di chuyển để right hoặc down. giả sử dp[i][j] là số của không trùng lặp các đường đi để reach (i, j). dp[i][j] = dp[i][j -1] + dp[i - 1][j]. Là careful khi nào bạn encounter một obstacle. tập hợp nó giá trị trong dp để 0.",
    "defaultCode": {
      "cpp": "class Solution { public: int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) { } };",
      "java": "class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { } }",
      "javascript": "/** * @param {number[][]} obstacleGrid * @return {number} */ var uniquePathsWithObstacles = function(obstacleGrid) { };",
      "python": "class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): \"\"\" :type obstacleGrid: List[List[int]] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:50 PM UTC+7",
    "editorial": {
      "content": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle. Return the number of possible unique paths that the robot can take to reach the bottom-right corner. The testcases are generated so that the answer will be less than or equal to 2 * 109.\n\nHint/nhắc ý (crawl được): Use dynamic programming since, from each cell, you can move to the right or down. assume dp[i][j] is the number of unique paths to reach (i, j). dp[i][j] = dp[i][j -1] + dp[i - 1][j]. Be careful when you encounter an obstacle. set its value in dp to 0.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn. Duyệt ma trận theo hàng/cột/biên; dùng đánh dấu hoặc visited nếu cần.",
      "lastUpdated": "January 13, 2026 at 3:39:50 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) { } };",
            "java": "class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { } }",
            "javascript": "/** * @param {number[][]} obstacleGrid * @return {number} */ var uniquePathsWithObstacles = function(obstacleGrid) { };",
            "python": "class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): \"\"\" :type obstacleGrid: List[List[int]] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "minimum-path-sum",
    "title": "Minimum Path Sum",
    "acceptance": 0.6761331165402558,
    "difficulty": "Medium",
    "likes": 13520,
    "dislikes": 196,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming",
      "matrix"
    ],
    "description": "Cho một m x n grid filled với không âm các số, tìm một đường đi từ top left để dưới cùng right, nào minimizes tổng của tất cả các số along nó đường đi. Lưu ý: Bạn có thể chỉ di chuyển một trong hai down hoặc right tại bất kỳ point trong thời gian.",
    "constraints": [
      "m == grid.length n == grid[i].độ dài",
      "1 <= m, n <= 200",
      "0 <= grid[i][j] <= 200"
    ],
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7",
        "explanation": "Vì đường đi 1 → 3 → 1 → 1 → 1 minimizes tổng."
      },
      {
        "input": "grid = [[1,2,3],[4,5,6]]",
        "output": "12",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int minPathSum(vector<vector<int>>& grid) { } };",
      "java": "class Solution { public int minPathSum(int[][] grid) { } }",
      "javascript": "/** * @param {number[][]} grid * @return {number} */ var minPathSum = function(grid) { };",
      "python": "class Solution(object): def minPathSum(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:51 PM UTC+7",
    "editorial": {
      "content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn. Duyệt ma trận theo hàng/cột/biên; dùng đánh dấu hoặc visited nếu cần.",
      "lastUpdated": "January 13, 2026 at 3:39:51 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int minPathSum(vector<vector<int>>& grid) { } };",
            "java": "class Solution { public int minPathSum(int[][] grid) { } }",
            "javascript": "/** * @param {number[][]} grid * @return {number} */ var minPathSum = function(grid) { };",
            "python": "class Solution(object): def minPathSum(self, grid): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "valid-number",
    "title": "Valid Number",
    "acceptance": 0.2243344292959789,
    "difficulty": "Hard",
    "likes": 1475,
    "dislikes": 2200,
    "stars": null,
    "tags": [
      "string"
    ],
    "description": "Cho một chuỗi s, trả về liệu s là một hợp lệ số. Ví dụ, tất cả sau đây là hợp lệ các số: \"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\", trong khi sau đây là không hợp lệ các số: \"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\". Formally, một hợp lệ số là defined using một của sau đây definitions: Một số nguyên số theo bởi một optional exponent. Một decimal số theo bởi một optional exponent. Một số nguyên số là defined với một optional dấu '-' hoặc '+' theo bởi các chữ số. Một decimal số là defined với một optional dấu '-' hoặc '+' theo bởi một của sau đây definitions: Các chữ số theo bởi một dot '.'. Các chữ số theo bởi một dot '.' theo bởi các chữ số. Một dot '.' theo bởi các chữ số. Một exponent là defined với một exponent notation 'e' hoặc 'E' theo bởi một số nguyên số. các chữ số là defined như một hoặc nhiều hơn các chữ số.",
    "constraints": [
      "1 <= s.length <= 20 s Gồm chỉ Tiếng Anh các chữ cái (both chữ hoa và chữ thường), các chữ số (0-9), plus '+', minus '-', hoặc dot '.'."
    ],
    "examples": [
      {
        "input": "s = \"0\"",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "s = \"e\"",
        "output": "false",
        "explanation": ""
      },
      {
        "input": "s = \".\"",
        "output": "false",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool isNumber(string s) { } };",
      "java": "class Solution { public boolean isNumber(String s) { } }",
      "javascript": "/** * @param {string} s * @return {boolean} */ var isNumber = function(s) { };",
      "python": "class Solution(object): def isNumber(self, s): \"\"\" :type s: str :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:51 PM UTC+7",
    "editorial": {
      "content": "Given a string s, return whether s is a valid number. For example, all the following are valid numbers: \"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\", while the following are not valid numbers: \"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\". Formally, a valid number is defined using one of the following definitions: An integer number followed by an optional exponent. A decimal number followed by an optional exponent. An integer number is defined with an optional sign '-' or '+' followed by digits. A decimal number is defined with an optional sign '-' or '+' followed by one of the following definitions: Digits followed by a dot '.'. Digits followed by a dot '.' followed by digits. A dot '.' followed by digits. An exponent is defined with an exponent notation 'e' or 'E' followed by an integer number. The digits are defined as one or more digits.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:51 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "String Processing",
          "description": "Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(n)$",
          "code": {
            "cpp": "class Solution { public: bool isNumber(string s) { } };",
            "java": "class Solution { public boolean isNumber(String s) { } }",
            "javascript": "/** * @param {string} s * @return {boolean} */ var isNumber = function(s) { };",
            "python": "class Solution(object): def isNumber(self, s): \"\"\" :type s: str :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "plus-one",
    "title": "Plus One",
    "acceptance": 0.4927213535291115,
    "difficulty": "Easy",
    "likes": 11529,
    "dislikes": 5586,
    "stars": null,
    "tags": [
      "array",
      "math"
    ],
    "description": "Bạn được cho một lớn số nguyên được biểu diễn như một số nguyên mảng digits, ở đâu each digits[i] là ith chữ số của số nguyên. digits là thứ tự từ nhiều nhất significant để ít nhất significant trong left-để-right thứ tự. lớn số nguyên Không chứa bất kỳ ở đầu 0's. Increment lớn số nguyên bởi một và trả về kết quả mảng của digits.",
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9 digits Không chứa bất kỳ ở đầu 0's."
    ],
    "examples": [
      {
        "input": "digits = [1,2,3]",
        "output": "[1,2,4]",
        "explanation": "mảng biểu diễn số nguyên 123. Incrementing bởi một gives 123 + 1 = 124. Thus, kết quả nên là [1,2,4]."
      },
      {
        "input": "digits = [4,3,2,1]",
        "output": "[4,3,2,2]",
        "explanation": "mảng biểu diễn số nguyên 4321. Incrementing bởi một gives 4321 + 1 = 4322. Thus, kết quả nên là [4,3,2,2]."
      },
      {
        "input": "digits = [9]",
        "output": "[1,0]",
        "explanation": "mảng biểu diễn số nguyên 9. Incrementing bởi một gives 9 + 1 = 10. Thus, kết quả nên là [1,0]."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<int> plusOne(vector<int>& digits) { } };",
      "java": "class Solution { public int[] plusOne(int[] digits) { } }",
      "javascript": "/** * @param {number[]} digits * @return {number[]} */ var plusOne = function(digits) { };",
      "python": "class Solution(object): def plusOne(self, digits): \"\"\" :type digits: List[int] :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:52 PM UTC+7",
    "editorial": {
      "content": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's. Increment the large integer by one and return the resulting array of digits.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
      "lastUpdated": "January 13, 2026 at 3:39:52 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Math / Simulation",
          "description": "Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: vector<int> plusOne(vector<int>& digits) { } };",
            "java": "class Solution { public int[] plusOne(int[] digits) { } }",
            "javascript": "/** * @param {number[]} digits * @return {number[]} */ var plusOne = function(digits) { };",
            "python": "class Solution(object): def plusOne(self, digits): \"\"\" :type digits: List[int] :rtype: List[int] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "add-binary",
    "title": "Add Binary",
    "acceptance": 0.5667599049098623,
    "difficulty": "Easy",
    "likes": 10347,
    "dislikes": 1090,
    "stars": null,
    "tags": [
      "math",
      "string",
      "bit-manipulation",
      "simulation"
    ],
    "description": "Cho hai nhị phân các chuỗi a và b, trả về their tổng như a nhị phân chuỗi.",
    "constraints": [
      "1 <= a.length, b.length <= 104 a và b consist chỉ của '0' hoặc '1' các ký tự. Each chuỗi Không chứa ở đầu các số 0 ngoại trừ cho 0 chính nó."
    ],
    "examples": [
      {
        "input": "a = \"11\", b = \"1\"",
        "output": "\"100\"",
        "explanation": ""
      },
      {
        "input": "a = \"1010\", b = \"1011\"",
        "output": "\"10101\"",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: string addBinary(string a, string b) { } };",
      "java": "class Solution { public String addBinary(String a, String b) { } }",
      "javascript": "/** * @param {string} a * @param {string} b * @return {string} */ var addBinary = function(a, b) { };",
      "python": "class Solution(object): def addBinary(self, a, b): \"\"\" :type a: str :type b: str :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:53 PM UTC+7",
    "editorial": {
      "content": "Given two binary strings a and b, return their sum as a binary string.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:53 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Bit Manipulation",
          "description": "Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: string addBinary(string a, string b) { } };",
            "java": "class Solution { public String addBinary(String a, String b) { } }",
            "javascript": "/** * @param {string} a * @param {string} b * @return {string} */ var addBinary = function(a, b) { };",
            "python": "class Solution(object): def addBinary(self, a, b): \"\"\" :type a: str :type b: str :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "text-justification",
    "title": "Text Justification",
    "acceptance": 0.5008265107592684,
    "difficulty": "Hard",
    "likes": 4466,
    "dislikes": 5314,
    "stars": null,
    "tags": [
      "array",
      "string",
      "simulation"
    ],
    "description": "Cho một mảng của các chuỗi words và một chiều rộng maxWidth, format text Sao cho each đường thẳng có chính xác maxWidth các ký tự và là fully (left và right) justified. Bạn nên pack của bạn words trong một greedy approach; đó là, pack như many words như Bạn có thể trong each đường thẳng. Pad extra dấu cách ' ' khi nào necessary vì vậy đó each đường thẳng có chính xác maxWidth các ký tự. Extra dấu cách giữa words nên là distributed như evenly như có thể. Nếu số của dấu cách trên một đường thẳng không chia evenly giữa words, rỗng slots trên left sẽ là assigned nhiều hơn dấu cách hơn slots trên right. Cho last đường thẳng của text, nó nên là left-justified, và không extra bộ nhớ là chèn giữa words. Lưu ý: Một word là defined như một ký tự dãy consisting của không-bộ nhớ các ký tự chỉ. Each word's độ dài là được đảm bảo để là lớn hơn 0 và không exceed maxWidth. đầu vào mảng words chứa Ít nhất một word.",
    "constraints": [
      "1 <= words.length <= 300",
      "1 <= words[i].độ dài <= 20 words[i] Gồm chỉ Tiếng Anh các chữ cái và các ký hiệu.",
      "1 <= maxWidth <= 100 words[i].độ dài <= maxWidth"
    ],
    "examples": [
      {
        "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
        "output": "[ \"This is an\", \"example of text\", \"justification. \" ]",
        "explanation": ""
      },
      {
        "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
        "output": "[ \"What must be\", \"acknowledgment \", \"shall be \" ]",
        "explanation": ""
      },
      {
        "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
        "output": "[ \"Science is what we\", \"understand well\", \"enough to explain to\", \"a computer. Art is\", \"everything else we\", \"do \" ]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<string> fullJustify(vector<string>& words, int maxWidth) { } };",
      "java": "class Solution { public List<String> fullJustify(String[] words, int maxWidth) { } }",
      "javascript": "/** * @param {string[]} words * @param {number} maxWidth * @return {string[]} */ var fullJustify = function(words, maxWidth) { };",
      "python": "class Solution(object): def fullJustify(self, words, maxWidth): \"\"\" :type words: List[str] :type maxWidth: int :rtype: List[str] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:53 PM UTC+7",
    "editorial": {
      "content": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left-justified, and no extra space is inserted between words. Note: A word is defined as a character sequence consisting of non-space characters only. Each word's length is guaranteed to be greater than 0 and not exceed maxWidth. The input array words contains at least one word.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Mô phỏng đúng theo đề bài, quản lý trạng thái và các biên cẩn thận.",
      "lastUpdated": "January 13, 2026 at 3:39:53 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "String Processing",
          "description": "Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(n)$",
          "code": {
            "cpp": "class Solution { public: vector<string> fullJustify(vector<string>& words, int maxWidth) { } };",
            "java": "class Solution { public List<String> fullJustify(String[] words, int maxWidth) { } }",
            "javascript": "/** * @param {string[]} words * @param {number} maxWidth * @return {string[]} */ var fullJustify = function(words, maxWidth) { };",
            "python": "class Solution(object): def fullJustify(self, words, maxWidth): \"\"\" :type words: List[str] :type maxWidth: int :rtype: List[str] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "sqrtx",
    "title": "Sqrt(x)",
    "acceptance": 0.41215459927540676,
    "difficulty": "Easy",
    "likes": 9462,
    "dislikes": 4626,
    "stars": null,
    "tags": [
      "math",
      "binary-search"
    ],
    "description": "Cho một không âm số nguyên x, trả về square root của x làm tròn down để nearest số nguyên. trả về số nguyên nên là không âm như well. Bạn phải không dùng bất kỳ built-trong exponent hàm hoặc operator. Ví dụ, làm không dùng pow(x, 0.5) trong c++ hoặc x ** 0.5 trong python.",
    "constraints": [
      "0 <= x <= 231 - 1"
    ],
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": "square root của 4 là 2, vì vậy chúng ta trả về 2."
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "square root của 8 là 2.82842..., và vì chúng ta làm tròn nó down để nearest số nguyên, 2 là trả về."
      }
    ],
    "content": "Hãy thử exploring tất cả các số nguyên. (Credits: @annujoshi) Dùng đã sắp xếp property của các số nguyên để reduced tìm kiếm bộ nhớ. (Credits: @annujoshi)",
    "defaultCode": {
      "cpp": "class Solution { public: int mySqrt(int x) { } };",
      "java": "class Solution { public int mySqrt(int x) { } }",
      "javascript": "/** * @param {number} x * @return {number} */ var mySqrt = function(x) { };",
      "python": "class Solution(object): def mySqrt(self, x): \"\"\" :type x: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:54 PM UTC+7",
    "editorial": {
      "content": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well. You must not use any built-in exponent function or operator. For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n\nHint/nhắc ý (crawl được): Try exploring all integers. (Credits: @annujoshi) Use the sorted property of integers to reduced the search space. (Credits: @annujoshi)\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
      "lastUpdated": "January 13, 2026 at 3:39:54 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Binary Search",
          "description": "Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
          "timeComplexity": "$O(\\log n)$ hoặc $O(n\\log M)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int mySqrt(int x) { } };",
            "java": "class Solution { public int mySqrt(int x) { } }",
            "javascript": "/** * @param {number} x * @return {number} */ var mySqrt = function(x) { };",
            "python": "class Solution(object): def mySqrt(self, x): \"\"\" :type x: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "climbing-stairs",
    "title": "Climbing Stairs",
    "acceptance": 0.538380152711153,
    "difficulty": "Easy",
    "likes": 24128,
    "dislikes": 1021,
    "stars": null,
    "tags": [
      "math",
      "dynamic-programming",
      "memoization"
    ],
    "description": "Bạn là climbing một staircase. Nó takes n các bước để reach top. Each thời gian Bạn có thể một trong hai climb 1 hoặc 2 các bước. Trong làm thế nào many phân biệt ways Bạn có thể climb để top?",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "Có hai ways để climb để top. 1. 1 bước + 1 bước 2. 2 các bước"
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "Có ba ways để climb để top. 1. 1 bước + 1 bước + 1 bước 2. 1 bước + 2 các bước 3. 2 các bước + 1 bước"
      }
    ],
    "content": "Để reach nth bước, điều gì có thể có been của bạn previous các bước? (Think about bước kích thước)",
    "defaultCode": {
      "cpp": "class Solution { public: int climbStairs(int n) { } };",
      "java": "class Solution { public int climbStairs(int n) { } }",
      "javascript": "/** * @param {number} n * @return {number} */ var climbStairs = function(n) { };",
      "python": "class Solution(object): def climbStairs(self, n): \"\"\" :type n: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:55 PM UTC+7",
    "editorial": {
      "content": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nHint/nhắc ý (crawl được): To reach nth step, what could have been your previous steps? (Think about the step sizes)\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:39:55 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int climbStairs(int n) { } };",
            "java": "class Solution { public int climbStairs(int n) { } }",
            "javascript": "/** * @param {number} n * @return {number} */ var climbStairs = function(n) { };",
            "python": "class Solution(object): def climbStairs(self, n): \"\"\" :type n: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "simplify-path",
    "title": "Simplify Path",
    "acceptance": 0.4970080349507255,
    "difficulty": "Medium",
    "likes": 6432,
    "dislikes": 1393,
    "stars": null,
    "tags": [
      "string",
      "stack"
    ],
    "description": "Bạn được cho một absolute path cho một Unix-style file system, nào always bắt đầu với một slash '/'. Của bạn task là để transform điều này absolute path thành nó simplified canonical path. rules của một Unix-style file system là như theo: Một một period '.' biểu diễn hiện tại directory. Một double period '..' biểu diễn previous/parent directory. Nhiều consecutive slashes such như '//' và '///' là treated như một một slash '/'. Bất kỳ dãy của periods đó không khớp rules bên trên nên là treated như một hợp lệ directory hoặc file tên. Ví dụ, '...' và '....' là hợp lệ directory hoặc file tên. simplified canonical path nên theo những rules: path phải bắt đầu với một một slash '/'. Directories trong path phải là separated bởi chính xác một slash '/'. path phải không kết thúc với một slash '/', unless nó là root directory. path phải không có bất kỳ một hoặc double periods ('.' và '..') được dùng để denote hiện tại hoặc parent directories. Trả về simplified canonical path.",
    "constraints": [
      "1 <= path.length <= 3000 path Gồm Tiếng Anh các chữ cái, các chữ số, period '.', slash '/' hoặc '_'. path là một hợp lệ absolute Unix path."
    ],
    "examples": [
      {
        "input": "path = \"/home/\"",
        "output": "\"/home\"",
        "explanation": "ở cuối slash nên là removed."
      },
      {
        "input": "path = \"/home//foo/\"",
        "output": "\"/home/foo\"",
        "explanation": "Nhiều consecutive slashes là replaced bởi một một một."
      },
      {
        "input": "path = \"/home/user/Documents/../Pictures\"",
        "output": "\"/home/user/Pictures\"",
        "explanation": "Một double period \"..\" refers để directory ra một mức ( parent directory)."
      },
      {
        "input": "path = \"/../\"",
        "output": "\"/\"",
        "explanation": "Going một mức ra từ root directory là không có thể."
      },
      {
        "input": "path = \"/.../a/../b/c/../d/./\"",
        "output": "\"/.../b/d\"",
        "explanation": "\"...\" là một hợp lệ tên cho một directory trong điều này problem."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: string simplifyPath(string path) { } };",
      "java": "class Solution { public String simplifyPath(String path) { } }",
      "javascript": "/** * @param {string} path * @return {string} */ var simplifyPath = function(path) { };",
      "python": "class Solution(object): def simplifyPath(self, path): \"\"\" :type path: str :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:56 PM UTC+7",
    "editorial": {
      "content": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path. The rules of a Unix-style file system are as follows: A single period '.' represents the current directory. A double period '..' represents the previous/parent directory. Multiple consecutive slashes such as '//' and '///' are treated as a single slash '/'. Any sequence of periods that does not match the rules above should be treated as a valid directory or file name. For example, '...' and '....' are valid directory or file names. The simplified canonical path should follow these rules: The path must start with a single slash '/'. Directories within the path must be separated by exactly one slash '/'. The path must not end with a slash '/', unless it is the root directory. The path must not have any single or double periods ('.' and '..') used to denote current or parent directories. Return the simplified canonical path.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
      "lastUpdated": "January 13, 2026 at 3:39:56 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: string simplifyPath(string path) { } };",
            "java": "class Solution { public String simplifyPath(String path) { } }",
            "javascript": "/** * @param {string} path * @return {string} */ var simplifyPath = function(path) { };",
            "python": "class Solution(object): def simplifyPath(self, path): \"\"\" :type path: str :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "edit-distance",
    "title": "Edit Distance",
    "acceptance": 0.5994084755725673,
    "difficulty": "Medium",
    "likes": 16229,
    "dislikes": 318,
    "stars": null,
    "tags": [
      "string",
      "dynamic-programming"
    ],
    "description": "Cho hai các chuỗi word1 và word2, trả về nhỏ nhất số của các thao tác required để chuyển đổi word1 để word2. Bạn có sau đây ba các thao tác permitted trên một word: Chèn một ký tự Xóa một ký tự Thay thế một ký tự",
    "constraints": [
      "0 <= word1.length, word2.length <= 500 word1 và word2 consist của chữ thường Tiếng Anh các chữ cái."
    ],
    "examples": [
      {
        "input": "word1 = \"horse\", word2 = \"ros\"",
        "output": "3",
        "explanation": "horse -> rorse (thay thế 'h' với 'r') rorse -> rose (loại bỏ 'r') rose -> ros (loại bỏ 'e')"
      },
      {
        "input": "word1 = \"intention\", word2 = \"execution\"",
        "output": "5",
        "explanation": "intention -> inention (loại bỏ 't') inention -> enention (thay thế 'i' với 'e') enention -> exention (thay thế 'n' với 'x') exention -> exection (thay thế 'n' với 'c') exection -> execution (chèn 'u')"
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int minDistance(string word1, string word2) { } };",
      "java": "class Solution { public int minDistance(String word1, String word2) { } }",
      "javascript": "/** * @param {string} word1 * @param {string} word2 * @return {number} */ var minDistance = function(word1, word2) { };",
      "python": "class Solution(object): def minDistance(self, word1, word2): \"\"\" :type word1: str :type word2: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:56 PM UTC+7",
    "editorial": {
      "content": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character Delete a character Replace a character\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:39:56 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int minDistance(string word1, string word2) { } };",
            "java": "class Solution { public int minDistance(String word1, String word2) { } }",
            "javascript": "/** * @param {string} word1 * @param {string} word2 * @return {number} */ var minDistance = function(word1, word2) { };",
            "python": "class Solution(object): def minDistance(self, word1, word2): \"\"\" :type word1: str :type word2: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "set-matrix-zeroes",
    "title": "Set Matrix Zeroes",
    "acceptance": 0.62153142210826,
    "difficulty": "Medium",
    "likes": 16814,
    "dislikes": 848,
    "stars": null,
    "tags": [
      "array",
      "hash-table",
      "matrix"
    ],
    "description": "Cho một m x n số nguyên matrix matrix, nếu một phần tử là 0, tập hợp nó toàn bộ hàng và cột để 0's. Bạn phải làm nó trong place.",
    "constraints": [
      "m == matrix.length n == matrix[0].độ dài",
      "1 <= m, n <= 200",
      "-231 <= matrix[i][j] <= 231 - 1 Câu hỏi thêm: Một straightforward lời giải using O(mn) bộ nhớ là probably một bad idea. Một simple improvement dùng O(m + n) bộ nhớ, but still không tốt nhất lời giải. Bạn có thể devise một constant bộ nhớ lời giải?",
      "-231 <= matrix[i][j] <= 231 - 1 Câu hỏi thêm: Một straightforward"
    ],
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": ""
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": ""
      }
    ],
    "content": "Nếu bất kỳ cell của matrix có một 0 chúng ta có thể record nó hàng và cột số using additional bộ nhớ. But nếu bạn don't want để dùng extra bộ nhớ thì Bạn có thể manipulate mảng instead. i.e. simulating chính xác điều gì question says. Tập hợp cell các giá trị để 0 trên fly trong khi iterating might lead để discrepancies. Điều gì nếu bạn dùng một số other số nguyên giá trị như của bạn marker? Có still một better approach cho điều này problem với O(1) bộ nhớ. Chúng ta có thể có được dùng 2 tập hợp để giữ một record của các hàng/các cột nào need để là tập hợp để 0. But cho một O(1) bộ nhớ lời giải, Bạn có thể dùng một của các hàng và và một của các cột để giữ track của điều này information. Chúng ta có thể dùng đầu tiên cell của mỗi hàng và cột như một flag. Điều này flag sẽ xác định liệu một hàng hoặc cột có been tập hợp để 0.",
    "defaultCode": {
      "cpp": "class Solution { public: void setZeroes(vector<vector<int>>& matrix) { } };",
      "java": "class Solution { public void setZeroes(int[][] matrix) { } }",
      "javascript": "/** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */ var setZeroes = function(matrix) { };",
      "python": "class Solution(object): def setZeroes(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: None Do not return anything, modify matrix in-place instead. \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:57 PM UTC+7",
    "editorial": {
      "content": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's. You must do it in place.\n\nHint/nhắc ý (crawl được): If any cell of the matrix has a zero we can record its row and column number using additional memory. But if you don't want to use extra memory then you can manipulate the array instead. i.e. simulating exactly what the question says. Setting cell values to zero on the fly while iterating might lead to discrepancies. What if you use some other integer value as your marker? There is still a better approach for this problem with O(1) space. We could have used 2 sets to keep a record of rows/columns which need to be set to zero. But for an O(1) space solution, you can use one of the rows and and one of the columns to keep track of this information. We can use the first cell of every row and column as a flag. This flag would determine whether a row or column has been set to zero.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Duyệt ma trận theo hàng/cột/biên; dùng đánh dấu hoặc visited nếu cần.",
      "lastUpdated": "January 13, 2026 at 3:39:57 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: void setZeroes(vector<vector<int>>& matrix) { } };",
            "java": "class Solution { public void setZeroes(int[][] matrix) { } }",
            "javascript": "/** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */ var setZeroes = function(matrix) { };",
            "python": "class Solution(object): def setZeroes(self, matrix): \"\"\" :type matrix: List[List[int]] :rtype: None Do not return anything, modify matrix in-place instead. \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "search-a-2d-matrix",
    "title": "Search a 2D Matrix",
    "acceptance": 0.5331248296128746,
    "difficulty": "Medium",
    "likes": 17603,
    "dislikes": 476,
    "stars": null,
    "tags": [
      "array",
      "binary-search",
      "matrix"
    ],
    "description": "Bạn được cho một m x n số nguyên matrix matrix với sau đây hai properties: Each hàng là đã sắp xếp trong thứ tự không giảm. đầu tiên số nguyên của each hàng là lớn hơn last số nguyên của previous hàng. Cho một số nguyên target, trả về đúng nếu target là trong matrix hoặc sai otherwise. Bạn phải viết một lời giải trong O(log(m * n)) thời gian độ phức tạp.",
    "constraints": [
      "m == matrix.length n == matrix[i].độ dài",
      "1 <= m, n <= 100",
      "-104 <= matrix[i][j], target <= 104"
    ],
    "examples": [
      {
        "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
        "output": "false",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool searchMatrix(vector<vector<int>>& matrix, int target) { } };",
      "java": "class Solution { public boolean searchMatrix(int[][] matrix, int target) { } }",
      "javascript": "/** * @param {number[][]} matrix * @param {number} target * @return {boolean} */ var searchMatrix = function(matrix, target) { };",
      "python": "class Solution(object): def searchMatrix(self, matrix, target): \"\"\" :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:58 PM UTC+7",
    "editorial": {
      "content": "You are given an m x n integer matrix matrix with the following two properties: Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise. You must write a solution in O(log(m * n)) time complexity.\n\nGợi ý hướng giải: Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer). Duyệt ma trận theo hàng/cột/biên; dùng đánh dấu hoặc visited nếu cần.",
      "lastUpdated": "January 13, 2026 at 3:39:58 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Binary Search",
          "description": "Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
          "timeComplexity": "$O(\\log n)$ hoặc $O(n\\log M)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: bool searchMatrix(vector<vector<int>>& matrix, int target) { } };",
            "java": "class Solution { public boolean searchMatrix(int[][] matrix, int target) { } }",
            "javascript": "/** * @param {number[][]} matrix * @param {number} target * @return {boolean} */ var searchMatrix = function(matrix, target) { };",
            "python": "class Solution(object): def searchMatrix(self, matrix, target): \"\"\" :type matrix: List[List[int]] :type target: int :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "sort-colors",
    "title": "Sort Colors",
    "acceptance": 0.6886761987660939,
    "difficulty": "Medium",
    "likes": 21159,
    "dislikes": 752,
    "stars": null,
    "tags": [
      "array",
      "two-pointers",
      "sorting"
    ],
    "description": "Cho một mảng nums với n đối tượng colored red, white, hoặc blue, sắp xếp chúng trong-place vì vậy đó đối tượng của giống nhau color là kề nhau, với colors trong thứ tự red, white, và blue. Chúng ta sẽ dùng các số nguyên 0, 1, và 2 để biểu diễn color red, white, và blue, tương ứng. Bạn phải solve điều này problem không using library's sắp xếp hàm.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 300 nums[i] là một trong hai 0, 1, hoặc 2. Câu hỏi thêm: Bạn có thể đưa ra một một-lần duyệt thuật toán using chỉ constant extra bộ nhớ?"
    ],
    "examples": [
      {
        "input": "nums = [2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]",
        "explanation": ""
      },
      {
        "input": "nums = [2,0,1]",
        "output": "[0,1,2]",
        "explanation": ""
      }
    ],
    "content": "Một rather straight forward lời giải là một hai-lần duyệt thuật toán using counting sắp xếp. Iterate mảng counting số của 0's, 1's, và 2's. Overwrite mảng với total số của 0's, thì 1's và theo bởi 2's.",
    "defaultCode": {
      "cpp": "class Solution { public: void sortColors(vector<int>& nums) { } };",
      "java": "class Solution { public void sortColors(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var sortColors = function(nums) { };",
      "python": "class Solution(object): def sortColors(self, nums): \"\"\" :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:59 PM UTC+7",
    "editorial": {
      "content": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function.\n\nHint/nhắc ý (crawl được): A rather straight forward solution is a two-pass algorithm using counting sort. Iterate the array counting number of 0's, 1's, and 2's. Overwrite array with the total number of 0's, then 1's and followed by 2's.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
      "lastUpdated": "January 13, 2026 at 3:39:59 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: void sortColors(vector<int>& nums) { } };",
            "java": "class Solution { public void sortColors(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var sortColors = function(nums) { };",
            "python": "class Solution(object): def sortColors(self, nums): \"\"\" :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "minimum-window-substring",
    "title": "Minimum Window Substring",
    "acceptance": 0.4666334797480265,
    "difficulty": "Hard",
    "likes": 19798,
    "dislikes": 838,
    "stars": null,
    "tags": [
      "hash-table",
      "string",
      "sliding-window"
    ],
    "description": "Cho hai các chuỗi s và t của độ dài m và n tương ứng, trả về nhỏ nhất window chuỗi con của s Sao cho mỗi ký tự trong t (including trùng lặp) là included trong window. Nếu Có không such chuỗi con, trả về rỗng chuỗi \"\". testcases sẽ là generated Sao cho Đáp án là không trùng lặp.",
    "constraints": [
      "m == s.length n == t.length",
      "1 <= m, n <= 105 s và t consist của chữ hoa và chữ thường Tiếng Anh các chữ cái. Câu hỏi thêm: Bạn có thể tìm một thuật toán đó runs trong O(m + n) thời gian?"
    ],
    "examples": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "output": "\"BANC\"",
        "explanation": "nhỏ nhất window chuỗi con \"BANC\" includes 'Một', 'B', và 'C' từ chuỗi t."
      },
      {
        "input": "s = \"a\", t = \"a\"",
        "output": "\"a\"",
        "explanation": "toàn bộ chuỗi s là nhỏ nhất window."
      },
      {
        "input": "s = \"a\", t = \"aa\"",
        "output": "\"\"",
        "explanation": "Both 'một's từ t phải là included trong window. Vì lớn nhất window của s chỉ có một 'một', trả về rỗng chuỗi."
      }
    ],
    "content": "Dùng hai các con trỏ để tạo một window của các chữ cái trong s, nào sẽ có tất cả các ký tự từ t. Expand right con trỏ cho đến khi tất cả các ký tự của t là bao phủ. Một lần tất cả các ký tự là bao phủ, di chuyển left con trỏ và ensure đó tất cả các ký tự là still bao phủ để minimize mảng con kích thước. Continue expanding right và left các con trỏ cho đến khi bạn reach kết thúc của s.",
    "defaultCode": {
      "cpp": "class Solution { public: string minWindow(string s, string t) { } };",
      "java": "class Solution { public String minWindow(String s, String t) { } }",
      "javascript": "/** * @param {string} s * @param {string} t * @return {string} */ var minWindow = function(s, t) { };",
      "python": "class Solution(object): def minWindow(self, s, t): \"\"\" :type s: str :type t: str :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:39:59 PM UTC+7",
    "editorial": {
      "content": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The testcases will be generated such that the answer is unique.\n\nHint/nhắc ý (crawl được): Use two pointers to create a window of letters in s, which would have all the characters from t. Expand the right pointer until all the characters of t are covered. Once all the characters are covered, move the left pointer and ensure that all the characters are still covered to minimize the subarray size. Continue expanding the right and left pointers until you reach the end of s.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:39:59 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: string minWindow(string s, string t) { } };",
            "java": "class Solution { public String minWindow(String s, String t) { } }",
            "javascript": "/** * @param {string} s * @param {string} t * @return {string} */ var minWindow = function(s, t) { };",
            "python": "class Solution(object): def minWindow(self, s, t): \"\"\" :type s: str :type t: str :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "combinations",
    "title": "Combinations",
    "acceptance": 0.7398010294167615,
    "difficulty": "Medium",
    "likes": 8829,
    "dislikes": 250,
    "stars": null,
    "tags": [
      "backtracking"
    ],
    "description": "Cho hai các số nguyên n và k, trả về tất cả có thể các tổ hợp của k các số chosen từ khoảng [1, n]. Bạn có thể trả về đáp án Theo bất kỳ thứ tự nào.",
    "constraints": [
      "1 <= n <= 20",
      "1 <= k <= n"
    ],
    "examples": [
      {
        "input": "n = 4, k = 2",
        "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
        "explanation": "Có 4 chọn 2 = 6 total các tổ hợp."
      },
      {
        "input": "n = 1, k = 1",
        "output": "[[1]]",
        "explanation": "Có 1 chọn 1 = 1 total tổ hợp."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> combine(int n, int k) { } };",
      "java": "class Solution { public List<List<Integer>> combine(int n, int k) { } }",
      "javascript": "/** * @param {number} n * @param {number} k * @return {number[][]} */ var combine = function(n, k) { };",
      "python": "class Solution(object): def combine(self, n, k): \"\"\" :type n: int :type k: int :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:00 PM UTC+7",
    "editorial": {
      "content": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n]. You may return the answer in any order.\n\nGợi ý hướng giải: Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
      "lastUpdated": "January 13, 2026 at 3:40:00 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> combine(int n, int k) { } };",
            "java": "class Solution { public List<List<Integer>> combine(int n, int k) { } }",
            "javascript": "/** * @param {number} n * @param {number} k * @return {number[][]} */ var combine = function(n, k) { };",
            "python": "class Solution(object): def combine(self, n, k): \"\"\" :type n: int :type k: int :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "subsets",
    "title": "Subsets",
    "acceptance": 0.8185329916390758,
    "difficulty": "Medium",
    "likes": 18943,
    "dislikes": 334,
    "stars": null,
    "tags": [
      "array",
      "backtracking",
      "bit-manipulation"
    ],
    "description": "Cho một số nguyên mảng nums của không trùng lặp các phần tử, trả về tất cả có thể các tập con ( tập lũy thừa). lời giải tập hợp phải không chứa trùng lặp các tập con. Trả về lời giải Theo bất kỳ thứ tự nào.",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10 Tất cả các số của nums là không trùng lặp."
    ],
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
        "explanation": ""
      },
      {
        "input": "nums = [0]",
        "output": "[[],[0]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> subsets(vector<int>& nums) { } };",
      "java": "class Solution { public List<List<Integer>> subsets(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number[][]} */ var subsets = function(nums) { };",
      "python": "class Solution(object): def subsets(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:01 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.\n\nGợi ý hướng giải: Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu). Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
      "lastUpdated": "January 13, 2026 at 3:40:01 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> subsets(vector<int>& nums) { } };",
            "java": "class Solution { public List<List<Integer>> subsets(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number[][]} */ var subsets = function(nums) { };",
            "python": "class Solution(object): def subsets(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "word-search",
    "title": "Word Search",
    "acceptance": 0.46583040454647423,
    "difficulty": "Medium",
    "likes": 17421,
    "dislikes": 746,
    "stars": null,
    "tags": [
      "array",
      "string",
      "backtracking",
      "depth-first-search",
      "matrix"
    ],
    "description": "Cho một m x n lưới của các ký tự board và một chuỗi word, trả về đúng nếu word tồn tại trong lưới. word có thể là constructed từ các chữ cái của sequentially kề nhau cells, ở đâu kề nhau cells là horizontally hoặc thẳng đứng neighboring. giống nhau chữ cái cell có thể không là được dùng nhiều hơn hơn một lần.",
    "constraints": [
      "m == board.length n = board[i].độ dài",
      "1 <= m, n <= 6",
      "1 <= word.length <= 15 board và word Gồm chỉ chữ thường và chữ hoa Tiếng Anh các chữ cái. Câu hỏi thêm: Bạn có thể dùng tìm kiếm pruning để tạo của bạn lời giải faster với một lớn hơn board?",
      "1 <= word.length <= 15 board và word Gồm chỉ chữ thường và chữ hoa Tiếng Anh các chữ cái. Câu hỏi thêm: Bạn có thể dùng tìm kiếm pruning để tạo của bạn"
    ],
    "examples": [
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
        "output": "false",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool exist(vector<vector<char>>& board, string word) { } };",
      "java": "class Solution { public boolean exist(char[][] board, String word) { } }",
      "javascript": "/** * @param {character[][]} board * @param {string} word * @return {boolean} */ var exist = function(board, word) { };",
      "python": "class Solution(object): def exist(self, board, word): \"\"\" :type board: List[List[str]] :type word: str :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:02 PM UTC+7",
    "editorial": {
      "content": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
      "lastUpdated": "January 13, 2026 at 3:40:02 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "class Solution { public: bool exist(vector<vector<char>>& board, string word) { } };",
            "java": "class Solution { public boolean exist(char[][] board, String word) { } }",
            "javascript": "/** * @param {character[][]} board * @param {string} word * @return {boolean} */ var exist = function(board, word) { };",
            "python": "class Solution(object): def exist(self, board, word): \"\"\" :type board: List[List[str]] :type word: str :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "remove-duplicates-from-sorted-array-ii",
    "title": "Remove Duplicates from Sorted Array II",
    "acceptance": 0.6404823399390325,
    "difficulty": "Medium",
    "likes": 8077,
    "dislikes": 1505,
    "stars": null,
    "tags": [
      "array",
      "two-pointers"
    ],
    "description": "Cho một số nguyên mảng nums đã sắp xếp trong thứ tự không giảm, loại bỏ một số trùng lặp trong-place Sao cho each không trùng lặp phần tử appears Nhiều nhất hai lần. relative thứ tự của các phần tử nên là kept giống nhau. Vì nó là impossible để change độ dài của mảng trong một số languages, bạn phải instead có kết quả là placed trong đầu tiên part của mảng nums. Nhiều hơn formally, nếu Có k các phần tử sau removing trùng lặp, thì đầu tiên k các phần tử của nums nên hold final kết quả. Nó không matter điều gì bạn leave beyond đầu tiên k các phần tử. Trả về k sau placing final kết quả trong đầu tiên k slots của nums. Làm không allocate extra bộ nhớ cho another mảng. Bạn phải làm điều này bởi modifying đầu vào mảng trong-place với O(1) extra bộ nhớ. Custom Judge: judge sẽ test của bạn lời giải với sau đây code: int[] nums = [...]; // Đầu vào mảng int[] expectedNums = [...]; // expected đáp án với correct độ dài int k = removeDuplicates(nums); // Calls của bạn implementation assert k == expectedNums.length; cho (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; } Nếu tất cả assertions lần duyệt, thì của bạn lời giải sẽ là accepted.",
    "constraints": [
      "1 <= nums.length <= 3 * 104",
      "-104 <= nums[i] <= 104 nums là đã sắp xếp trong thứ tự không giảm."
    ],
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3]",
        "output": "5, nums = [1,1,2,2,3,_]",
        "explanation": "Của bạn hàm nên trả về k = 5, với đầu tiên năm các phần tử của nums là 1, 1, 2, 2 và 3 tương ứng. Nó không matter điều gì bạn leave beyond trả về k (do đó họ là underscores)."
      },
      {
        "input": "nums = [0,0,1,1,1,1,2,3,3]",
        "output": "7, nums = [0,0,1,1,2,3,3,_,_]",
        "explanation": "Của bạn hàm nên trả về k = 7, với đầu tiên bảy các phần tử của nums là 0, 0, 1, 1, 2, 3 và 3 tương ứng. Nó không matter điều gì bạn leave beyond trả về k (do đó họ là underscores)."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int removeDuplicates(vector<int>& nums) { } };",
      "java": "class Solution { public int removeDuplicates(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var removeDuplicates = function(nums) { };",
      "python": "class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:02 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i < k; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
      "lastUpdated": "January 13, 2026 at 3:40:02 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int removeDuplicates(vector<int>& nums) { } };",
            "java": "class Solution { public int removeDuplicates(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var removeDuplicates = function(nums) { };",
            "python": "class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "search-in-rotated-sorted-array-ii",
    "title": "Search in Rotated Sorted Array II",
    "acceptance": 0.39565898500684765,
    "difficulty": "Medium",
    "likes": 9467,
    "dislikes": 1113,
    "stars": null,
    "tags": [
      "array",
      "binary-search"
    ],
    "description": "Có một số nguyên mảng nums đã sắp xếp trong thứ tự không giảm (không necessarily với phân biệt các giá trị). Trước là lần duyệt để của bạn hàm, nums là rotated tại một unknown pivot chỉ số k (0 <= k < nums.length) Sao cho kết quả mảng là [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1],..., nums[k-1]] (0-chỉ số). Ví dụ, [0,1,2,4,4,4,5,6,6,7] might là rotated tại pivot chỉ số 5 và become [4,5,6,6,7,0,1,2,4,4]. Cho mảng nums sau rotation và một số nguyên target, trả về đúng nếu target là trong nums, hoặc sai nếu nó là không trong nums. Bạn phải decrease overall thao tác các bước như much như có thể.",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-104 <= nums[i] <= 104 nums là được đảm bảo để là rotated tại một số pivot.",
      "-104 <= target <= 104 Câu hỏi thêm: Điều này problem là similar để Tìm kiếm trong Rotated Đã sắp xếp Mảng, but nums có thể chứa trùng lặp. Sẽ điều này affect runtime độ phức tạp? Làm thế nào và tại sao?"
    ],
    "examples": [
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 0",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "nums = [2,5,6,0,0,1,2], target = 3",
        "output": "false",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool search(vector<int>& nums, int target) { } };",
      "java": "class Solution { public boolean search(int[] nums, int target) { } }",
      "javascript": "/** * @param {number[]} nums * @param {number} target * @return {boolean} */ var search = function(nums, target) { };",
      "python": "class Solution(object): def search(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:03 PM UTC+7",
    "editorial": {
      "content": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values). Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4]. Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums. You must decrease the overall operation steps as much as possible.\n\nGợi ý hướng giải: Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
      "lastUpdated": "January 13, 2026 at 3:40:03 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Binary Search",
          "description": "Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
          "timeComplexity": "$O(\\log n)$ hoặc $O(n\\log M)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: bool search(vector<int>& nums, int target) { } };",
            "java": "class Solution { public boolean search(int[] nums, int target) { } }",
            "javascript": "/** * @param {number[]} nums * @param {number} target * @return {boolean} */ var search = function(nums, target) { };",
            "python": "class Solution(object): def search(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "remove-duplicates-from-sorted-list-ii",
    "title": "Remove Duplicates from Sorted List II",
    "acceptance": 0.5108810283645308,
    "difficulty": "Medium",
    "likes": 9564,
    "dislikes": 278,
    "stars": null,
    "tags": [
      "linked-list",
      "two-pointers"
    ],
    "description": "Cho head của một đã sắp xếp danh sách liên kết, xóa tất cả các nút đó có trùng lặp các số, leaving chỉ phân biệt các số từ original danh sách. Trả về danh sách liên kết đã sắp xếp như well.",
    "constraints": [
      "số của các nút trong danh sách là Trong khoảng [0, 300].",
      "-100 <= Node.val <= 100 danh sách là được đảm bảo để là đã sắp xếp trong thứ tự tăng dần."
    ],
    "examples": [
      {
        "input": "head = [1,2,3,3,4,4,5]",
        "output": "[1,2,5]",
        "explanation": ""
      },
      {
        "input": "head = [1,1,1,2,3]",
        "output": "[2,3]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function(head) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def deleteDuplicates(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:04 PM UTC+7",
    "editorial": {
      "content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
      "lastUpdated": "January 13, 2026 at 3:40:04 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function(head) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def deleteDuplicates(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "remove-duplicates-from-sorted-list",
    "title": "Remove Duplicates from Sorted List",
    "acceptance": 0.5601500833950538,
    "difficulty": "Easy",
    "likes": 9693,
    "dislikes": 357,
    "stars": null,
    "tags": [
      "linked-list"
    ],
    "description": "Cho head của một đã sắp xếp danh sách liên kết, xóa tất cả trùng lặp Sao cho each phần tử appears chỉ một lần. Trả về danh sách liên kết đã sắp xếp như well.",
    "constraints": [
      "số của các nút trong danh sách là Trong khoảng [0, 300].",
      "-100 <= Node.val <= 100 danh sách là được đảm bảo để là đã sắp xếp trong thứ tự tăng dần."
    ],
    "examples": [
      {
        "input": "head = [1,1,2]",
        "output": "[1,2]",
        "explanation": ""
      },
      {
        "input": "head = [1,1,2,3,3]",
        "output": "[1,2,3]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function(head) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def deleteDuplicates(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:04 PM UTC+7",
    "editorial": {
      "content": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
      "lastUpdated": "January 13, 2026 at 3:40:04 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers trên Linked List",
          "description": "Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var deleteDuplicates = function(head) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def deleteDuplicates(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "largest-rectangle-in-histogram",
    "title": "Largest Rectangle in Histogram",
    "acceptance": 0.4902840029072296,
    "difficulty": "Hard",
    "likes": 19237,
    "dislikes": 372,
    "stars": null,
    "tags": [
      "array",
      "stack",
      "monotonic-stack"
    ],
    "description": "Cho một mảng của các số nguyên heights biểu diễn histogram's bar chiều cao ở đâu chiều rộng của each bar là 1, trả về area của lớn nhất rectangle trong histogram.",
    "constraints": [
      "1 <= heights.length <= 105",
      "0 <= heights[i] <= 104"
    ],
    "examples": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "bên trên là một histogram ở đâu chiều rộng của each bar là 1. lớn nhất rectangle là shown trong red area, nào có một area = 10 units."
      },
      {
        "input": "heights = [2,4]",
        "output": "4",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int largestRectangleArea(vector<int>& heights) { } };",
      "java": "class Solution { public int largestRectangleArea(int[] heights) { } }",
      "javascript": "/** * @param {number[]} heights * @return {number} */ var largestRectangleArea = function(heights) { };",
      "python": "class Solution(object): def largestRectangleArea(self, heights): \"\"\" :type heights: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:05 PM UTC+7",
    "editorial": {
      "content": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n\nGợi ý hướng giải: Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
      "lastUpdated": "January 13, 2026 at 3:40:05 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: int largestRectangleArea(vector<int>& heights) { } };",
            "java": "class Solution { public int largestRectangleArea(int[] heights) { } }",
            "javascript": "/** * @param {number[]} heights * @return {number} */ var largestRectangleArea = function(heights) { };",
            "python": "class Solution(object): def largestRectangleArea(self, heights): \"\"\" :type heights: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "maximal-rectangle",
    "title": "Maximal Rectangle",
    "acceptance": 0.577369028014119,
    "difficulty": "Hard",
    "likes": 11928,
    "dislikes": 224,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming",
      "stack",
      "matrix",
      "monotonic-stack"
    ],
    "description": "Cho một các hàng x cols nhị phân matrix filled với 0's và 1's, tìm lớn nhất rectangle chứa chỉ 1's và trả về nó area.",
    "constraints": [
      "các hàng == matrix.length cols == matrix[i].độ dài",
      "1 <= các hàng, cols <= 200 matrix[i][j] là '0' hoặc '1'."
    ],
    "examples": [
      {
        "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
        "output": "6",
        "explanation": "maximal rectangle là shown trong bên trên picture."
      },
      {
        "input": "matrix = [[\"0\"]]",
        "output": "0",
        "explanation": ""
      },
      {
        "input": "matrix = [[\"1\"]]",
        "output": "1",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int maximalRectangle(vector<vector<char>>& matrix) { } };",
      "java": "class Solution { public int maximalRectangle(char[][] matrix) { } }",
      "javascript": "/** * @param {character[][]} matrix * @return {number} */ var maximalRectangle = function(matrix) { };",
      "python": "class Solution(object): def maximalRectangle(self, matrix): \"\"\" :type matrix: List[List[str]] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:06 PM UTC+7",
    "editorial": {
      "content": "Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn. Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
      "lastUpdated": "January 13, 2026 at 3:40:06 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: int maximalRectangle(vector<vector<char>>& matrix) { } };",
            "java": "class Solution { public int maximalRectangle(char[][] matrix) { } }",
            "javascript": "/** * @param {character[][]} matrix * @return {number} */ var maximalRectangle = function(matrix) { };",
            "python": "class Solution(object): def maximalRectangle(self, matrix): \"\"\" :type matrix: List[List[str]] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "partition-list",
    "title": "Partition List",
    "acceptance": 0.6034383496034103,
    "difficulty": "Medium",
    "likes": 7957,
    "dislikes": 977,
    "stars": null,
    "tags": [
      "linked-list",
      "two-pointers"
    ],
    "description": "Cho head của một danh sách liên kết và một giá trị x, partition nó Sao cho tất cả các nút nhỏ hơn x đưa ra trước các nút lớn hơn hoặc bằng để x. Bạn nên preserve original relative thứ tự của các nút trong each của hai partitions.",
    "constraints": [
      "số của các nút trong danh sách là Trong khoảng [0, 200].",
      "-100 <= Node.val <= 100",
      "-200 <= x <= 200"
    ],
    "examples": [
      {
        "input": "head = [1,4,3,2,5,2], x = 3",
        "output": "[1,2,2,4,3,5]",
        "explanation": ""
      },
      {
        "input": "head = [2,1], x = 2",
        "output": "[1,2]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* partition(ListNode* head, int x) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode partition(ListNode head, int x) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} x * @return {ListNode} */ var partition = function(head, x) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def partition(self, head, x): \"\"\" :type head: Optional[ListNode] :type x: int :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:06 PM UTC+7",
    "editorial": {
      "content": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
      "lastUpdated": "January 13, 2026 at 3:40:06 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* partition(ListNode* head, int x) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode partition(ListNode head, int x) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} x * @return {ListNode} */ var partition = function(head, x) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def partition(self, head, x): \"\"\" :type head: Optional[ListNode] :type x: int :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "scramble-string",
    "title": "Scramble String",
    "acceptance": 0.4362632124442968,
    "difficulty": "Hard",
    "likes": 3598,
    "dislikes": 1306,
    "stars": null,
    "tags": [
      "string",
      "dynamic-programming"
    ],
    "description": "Chúng ta có thể scramble một chuỗi s để get một chuỗi t using sau đây thuật toán: Nếu độ dài của chuỗi là 1, dừng. Nếu độ dài của chuỗi là > 1, làm sau đây: Tách chuỗi thành hai không rỗng chuỗi con tại một random chỉ số, i.e., nếu chuỗi là s, chia nó để x và y ở đâu s = x + y. Randomly decide để hoán đổi hai chuỗi con hoặc để giữ chúng trong giống nhau thứ tự. i.e., sau điều này bước, s có thể become s = x + y hoặc s = y + x. Apply bước 1 recursively trên each của hai chuỗi con x và y. Cho hai các chuỗi s1 và s2 của giống nhau độ dài, trả về đúng nếu s2 là một scrambled chuỗi của s1, otherwise, trả về sai.",
    "constraints": [
      "s1.length == s2.length",
      "1 <= s1.length <= 30 s1 và s2 consist của chữ thường Tiếng Anh các chữ cái."
    ],
    "examples": [
      {
        "input": "s1 = \"great\", s2 = \"rgeat\"",
        "output": "true",
        "explanation": "Một có thể scenario applied trên s1 là: \"great\" --> \"gr/eat\" // chia tại random chỉ số. \"gr/eat\" --> \"gr/eat\" // random decision là không để hoán đổi hai chuỗi con và giữ chúng trong thứ tự. \"gr/eat\" --> \"g/r / e/at\" // apply giống nhau thuật toán recursively trên both chuỗi con. chia tại random chỉ số each của chúng. \"g/r / e/at\" --> \"r/g / e/at\" // random decision là để hoán đổi đầu tiên chuỗi con và để giữ thứ hai chuỗi con trong giống nhau thứ tự. \"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply thuật toán recursively, chia \"at\" để \"a/t\". \"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision là để giữ both chuỗi con trong giống nhau thứ tự. thuật toán dừng now, và kết quả chuỗi là \"rgeat\" nào là s2. Như một có thể scenario led s1 để là scrambled để s2, chúng ta trả về đúng."
      },
      {
        "input": "s1 = \"abcde\", s2 = \"caebd\"",
        "output": "false",
        "explanation": ""
      },
      {
        "input": "s1 = \"a\", s2 = \"a\"",
        "output": "true",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool isScramble(string s1, string s2) { } };",
      "java": "class Solution { public boolean isScramble(String s1, String s2) { } }",
      "javascript": "/** * @param {string} s1 * @param {string} s2 * @return {boolean} */ var isScramble = function(s1, s2) { };",
      "python": "class Solution(object): def isScramble(self, s1, s2): \"\"\" :type s1: str :type s2: str :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:07 PM UTC+7",
    "editorial": {
      "content": "We can scramble a string s to get a string t using the following algorithm: If the length of the string is 1, stop. If the length of the string is > 1, do the following: Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y. Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x. Apply step 1 recursively on each of the two substrings x and y. Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:07 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: bool isScramble(string s1, string s2) { } };",
            "java": "class Solution { public boolean isScramble(String s1, String s2) { } }",
            "javascript": "/** * @param {string} s1 * @param {string} s2 * @return {boolean} */ var isScramble = function(s1, s2) { };",
            "python": "class Solution(object): def isScramble(self, s1, s2): \"\"\" :type s1: str :type s2: str :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "merge-sorted-array",
    "title": "Merge Sorted Array",
    "acceptance": 0.5410612839670843,
    "difficulty": "Easy",
    "likes": 18403,
    "dislikes": 2570,
    "stars": null,
    "tags": [
      "array",
      "two-pointers",
      "sorting"
    ],
    "description": "Bạn được cho hai số nguyên các mảng nums1 và nums2, đã sắp xếp trong thứ tự không giảm, và hai các số nguyên m và n, biểu diễn số của các phần tử trong nums1 và nums2 tương ứng. Gộp nums1 và nums2 thành một một mảng đã sắp xếp trong thứ tự không giảm. final đã sắp xếp mảng nên không là trả về bởi hàm, but instead là được lưu inside mảng nums1. Để accommodate điều này, nums1 có một độ dài của m + n, ở đâu đầu tiên m các phần tử denote các phần tử đó nên là merged, và last n các phần tử là tập hợp để 0 và nên là ignored. nums2 có một độ dài của n.",
    "constraints": [
      "nums1.length == m + n nums2.length == n",
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "-109 <= nums1[i], nums2[j] <= 109 Câu hỏi thêm: Bạn có thể đưa ra một thuật toán đó runs trong O(m + n) thời gian?"
    ],
    "examples": [
      {
        "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
        "output": "[1,2,2,3,5,6]",
        "explanation": "các mảng chúng ta là merging là [1,2,3] và [2,5,6]. kết quả của gộp là [1,2,2,3,5,6] với được gạch chân các phần tử coming từ nums1."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "các mảng chúng ta là merging là [1] và []. kết quả của gộp là [1]."
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]",
        "explanation": "các mảng chúng ta là merging là [] và [1]. kết quả của gộp là [1]."
      }
    ],
    "content": "Bạn có thể easily solve điều này problem nếu bạn simply think about hai các phần tử tại một thời gian rather hơn hai các mảng. Chúng ta know đó each của individual các mảng là đã sắp xếp. Điều gì chúng ta don't know là làm thế nào họ sẽ intertwine. Chúng ta có thể take một local decision và arrive tại một optimal lời giải? Nếu bạn simply consider một phần tử each tại một thời gian từ hai các mảng và tạo một decision và proceed accordingly, bạn sẽ arrive tại optimal lời giải.",
    "defaultCode": {
      "cpp": "class Solution { public: void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) { } };",
      "java": "class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { } }",
      "javascript": "/** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */ var merge = function(nums1, m, nums2, n) { };",
      "python": "class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: None Do not return anything, modify nums1 in-place instead. \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:07 PM UTC+7",
    "editorial": {
      "content": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\n\nHint/nhắc ý (crawl được): You can easily solve this problem if you simply think about two elements at a time rather than two arrays. We know that each of the individual arrays is sorted. What we don't know is how they will intertwine. Can we take a local decision and arrive at an optimal solution? If you simply consider one element each at a time from the two arrays and make a decision and proceed accordingly, you will arrive at the optimal solution.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
      "lastUpdated": "January 13, 2026 at 3:40:07 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) { } };",
            "java": "class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { } }",
            "javascript": "/** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */ var merge = function(nums1, m, nums2, n) { };",
            "python": "class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: None Do not return anything, modify nums1 in-place instead. \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "gray-code",
    "title": "Gray Code",
    "acceptance": 0.6372787516478717,
    "difficulty": "Medium",
    "likes": 2497,
    "dislikes": 2828,
    "stars": null,
    "tags": [
      "math",
      "backtracking",
      "bit-manipulation"
    ],
    "description": "Một n-bit gray code dãy là một dãy của 2n các số nguyên ở đâu: Mỗi số nguyên là trong inclusive khoảng [0, 2n - 1], đầu tiên số nguyên là 0, Một số nguyên appears không nhiều hơn hơn một lần trong dãy, nhị phân representation của mỗi cặp của kề nhau các số nguyên differs bởi chính xác một bit, và nhị phân representation của đầu tiên và last các số nguyên differs bởi chính xác một bit. Cho một số nguyên n, trả về bất kỳ hợp lệ n-bit gray code dãy.",
    "constraints": [
      "1 <= n <= 16"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "[0,1,3,2]",
        "explanation": "nhị phân representation của [0,1,3,2] là [00,01,11,10]. - 00 và 01 differ bởi một bit - 01 và 11 differ bởi một bit - 11 và 10 differ bởi một bit - 10 và 00 differ bởi một bit [0,2,3,1] là cũng một hợp lệ gray code dãy, whose nhị phân representation là [00,10,11,01]. - 00 và 10 differ bởi một bit - 10 và 11 differ bởi một bit - 11 và 01 differ bởi một bit - 01 và 00 differ bởi một bit"
      },
      {
        "input": "n = 1",
        "output": "[0,1]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<int> grayCode(int n) { } };",
      "java": "class Solution { public List<Integer> grayCode(int n) { } }",
      "javascript": "/** * @param {number} n * @return {number[]} */ var grayCode = function(n) { };",
      "python": "class Solution(object): def grayCode(self, n): \"\"\" :type n: int :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:08 PM UTC+7",
    "editorial": {
      "content": "An n-bit gray code sequence is a sequence of 2n integers where: Every integer is in the inclusive range [0, 2n - 1], The first integer is 0, An integer appears no more than once in the sequence, The binary representation of every pair of adjacent integers differs by exactly one bit, and The binary representation of the first and last integers differs by exactly one bit. Given an integer n, return any valid n-bit gray code sequence.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
      "lastUpdated": "January 13, 2026 at 3:40:08 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "class Solution { public: vector<int> grayCode(int n) { } };",
            "java": "class Solution { public List<Integer> grayCode(int n) { } }",
            "javascript": "/** * @param {number} n * @return {number[]} */ var grayCode = function(n) { };",
            "python": "class Solution(object): def grayCode(self, n): \"\"\" :type n: int :rtype: List[int] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "subsets-ii",
    "title": "Subsets II",
    "acceptance": 0.6065256633921092,
    "difficulty": "Medium",
    "likes": 10765,
    "dislikes": 402,
    "stars": null,
    "tags": [
      "array",
      "backtracking",
      "bit-manipulation"
    ],
    "description": "Cho một số nguyên mảng nums đó có thể chứa trùng lặp, trả về tất cả có thể các tập con ( tập lũy thừa). lời giải tập hợp phải không chứa trùng lặp các tập con. Trả về lời giải Theo bất kỳ thứ tự nào.",
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10"
    ],
    "examples": [
      {
        "input": "nums = [1,2,2]",
        "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
        "explanation": ""
      },
      {
        "input": "nums = [0]",
        "output": "[[],[0]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> subsetsWithDup(vector<int>& nums) { } };",
      "java": "class Solution { public List<List<Integer>> subsetsWithDup(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number[][]} */ var subsetsWithDup = function(nums) { };",
      "python": "class Solution(object): def subsetsWithDup(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:09 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.\n\nGợi ý hướng giải: Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu). Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
      "lastUpdated": "January 13, 2026 at 3:40:09 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> subsetsWithDup(vector<int>& nums) { } };",
            "java": "class Solution { public List<List<Integer>> subsetsWithDup(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number[][]} */ var subsetsWithDup = function(nums) { };",
            "python": "class Solution(object): def subsetsWithDup(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "decode-ways",
    "title": "Decode Ways",
    "acceptance": 0.3744365016480395,
    "difficulty": "Medium",
    "likes": 12747,
    "dislikes": 4608,
    "stars": null,
    "tags": [
      "string",
      "dynamic-programming"
    ],
    "description": "Bạn có intercepted một secret message encoded như một chuỗi của các số. message là decoded via sau đây bản đồ: \"1\" -> 'Một' \"2\" -> 'B'... \"25\" -> 'Y' \"26\" -> 'Z' However, trong khi decoding message, bạn realize đó Có many khác nhau ways Bạn có thể decode message vì một số codes là chứa trong other codes (\"2\" và \"5\" vs \"25\"). Ví dụ, \"11106\" có thể là decoded thành: \"AAJF\" với grouping (1, 1, 10, 6) \"KJF\" với grouping (11, 10, 6) grouping (1, 11, 06) là không hợp lệ vì \"06\" là không một hợp lệ code (chỉ \"6\" là hợp lệ). Lưu ý: có có thể là các chuỗi đó là impossible để decode. Cho một chuỗi s chứa chỉ các chữ số, trả về số của ways để decode nó. Nếu toàn bộ chuỗi không thể là decoded trong bất kỳ hợp lệ way, trả về 0. test trường hợp là generated vì vậy đó đáp án fits trong một 32-bit số nguyên.",
    "constraints": [
      "1 <= s.length <= 100",
      "s Chỉ chứa các chữ số và có thể chứa ở đầu 0(s)."
    ],
    "examples": [
      {
        "input": "s = \"12\"",
        "output": "2",
        "explanation": "\"12\" có thể là decoded như \"AB\" (1 2) hoặc \"L\" (12)."
      },
      {
        "input": "s = \"226\"",
        "output": "3",
        "explanation": "\"226\" có thể là decoded như \"BZ\" (2 26), \"VF\" (22 6), hoặc \"BBF\" (2 2 6)."
      },
      {
        "input": "s = \"06\"",
        "output": "0",
        "explanation": "\"06\" không thể là bản đồ để \"F\" vì của ở đầu 0 (\"6\" là khác nhau từ \"06\"). Trong điều này trường hợp, chuỗi là không một hợp lệ encoding, vì vậy trả về 0."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int numDecodings(string s) { } };",
      "java": "class Solution { public int numDecodings(String s) { } }",
      "javascript": "/** * @param {string} s * @return {number} */ var numDecodings = function(s) { };",
      "python": "class Solution(object): def numDecodings(self, s): \"\"\" :type s: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:10 PM UTC+7",
    "editorial": {
      "content": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping: \"1\" -> 'A' \"2\" -> 'B' ... \"25\" -> 'Y' \"26\" -> 'Z' However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\"). For example, \"11106\" can be decoded into: \"AAJF\" with the grouping (1, 1, 10, 6) \"KJF\" with the grouping (11, 10, 6) The grouping (1, 11, 06) is invalid because \"06\" is not a valid code (only \"6\" is valid). Note: there may be strings that are impossible to decode. Given a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0. The test cases are generated so that the answer fits in a 32-bit integer.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:10 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int numDecodings(string s) { } };",
            "java": "class Solution { public int numDecodings(String s) { } }",
            "javascript": "/** * @param {string} s * @return {number} */ var numDecodings = function(s) { };",
            "python": "class Solution(object): def numDecodings(self, s): \"\"\" :type s: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "reverse-linked-list-ii",
    "title": "Reverse Linked List II",
    "acceptance": 0.5074792704714213,
    "difficulty": "Medium",
    "likes": 12754,
    "dislikes": 773,
    "stars": null,
    "tags": [
      "linked-list"
    ],
    "description": "Cho head của một singly danh sách liên kết và hai các số nguyên left và right ở đâu left <= right, đảo ngược các nút của danh sách từ vị trí left để vị trí right, và trả về được đảo ngược danh sách.",
    "constraints": [
      "số của các nút trong danh sách là n.",
      "1 <= n <= 500",
      "-500 <= Node.val <= 500",
      "1 <= left <= right <= n Câu hỏi thêm: Bạn có thể làm nó trong một lần duyệt?"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5], left = 2, right = 4",
        "output": "[1,4,3,2,5]",
        "explanation": ""
      },
      {
        "input": "head = [5], left = 1, right = 1",
        "output": "[5]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int left, int right) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} left * @param {number} right * @return {ListNode} */ var reverseBetween = function(head, left, right) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def reverseBetween(self, head, left, right): \"\"\" :type head: Optional[ListNode] :type left: int :type right: int :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:11 PM UTC+7",
    "editorial": {
      "content": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
      "lastUpdated": "January 13, 2026 at 3:40:11 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers trên Linked List",
          "description": "Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int left, int right) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} left * @param {number} right * @return {ListNode} */ var reverseBetween = function(head, left, right) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def reverseBetween(self, head, left, right): \"\"\" :type head: Optional[ListNode] :type left: int :type right: int :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "restore-ip-addresses",
    "title": "Restore IP Addresses",
    "acceptance": 0.5494903447074471,
    "difficulty": "Medium",
    "likes": 5592,
    "dislikes": 818,
    "stars": null,
    "tags": [
      "string",
      "backtracking"
    ],
    "description": "Một hợp lệ IP address Gồm chính xác bốn các số nguyên separated bởi một dots. Each số nguyên là giữa 0 và 255 (inclusive) và không thể có ở đầu các số 0. Ví dụ, \"0.1.2.201\" và \"192.168.1.1\" là hợp lệ IP addresses, but \"0.011.255.245\", \"192.168.1.312\" và \"192.168@1.1\" là không hợp lệ IP addresses. Cho một chuỗi s chứa chỉ các chữ số, trả về tất cả có thể hợp lệ IP addresses đó có thể là tạo thành bởi chèn dots thành s. Bạn là không allowed để reorder hoặc loại bỏ bất kỳ các chữ số trong s. Bạn có thể trả về hợp lệ IP addresses Theo bất kỳ thứ tự nào.",
    "constraints": [
      "1 <= s.length <= 20 s Gồm các chữ số chỉ."
    ],
    "examples": [
      {
        "input": "s = \"25525511135\"",
        "output": "[\"255.255.11.135\",\"255.255.111.35\"]",
        "explanation": ""
      },
      {
        "input": "s = \"0000\"",
        "output": "[\"0.0.0.0\"]",
        "explanation": ""
      },
      {
        "input": "s = \"101023\"",
        "output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<string> restoreIpAddresses(string s) { } };",
      "java": "class Solution { public List<String> restoreIpAddresses(String s) { } }",
      "javascript": "/** * @param {string} s * @return {string[]} */ var restoreIpAddresses = function(s) { };",
      "python": "class Solution(object): def restoreIpAddresses(self, s): \"\"\" :type s: str :rtype: List[str] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:12 PM UTC+7",
    "editorial": {
      "content": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. For example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses. Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
      "lastUpdated": "January 13, 2026 at 3:40:12 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "class Solution { public: vector<string> restoreIpAddresses(string s) { } };",
            "java": "class Solution { public List<String> restoreIpAddresses(String s) { } }",
            "javascript": "/** * @param {string} s * @return {string[]} */ var restoreIpAddresses = function(s) { };",
            "python": "class Solution(object): def restoreIpAddresses(self, s): \"\"\" :type s: str :rtype: List[str] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "binary-tree-inorder-traversal",
    "title": "Binary Tree Inorder Traversal",
    "acceptance": 0.7953407564345357,
    "difficulty": "Easy",
    "likes": 14702,
    "dislikes": 883,
    "stars": null,
    "tags": [
      "stack",
      "tree",
      "depth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân, trả về inorder duyệt của nó các nút' các giá trị.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 100].",
      "-100 <= Node.val <= 100 Câu hỏi thêm: Recursive lời giải là trivial, Bạn có thể làm nó iteratively?",
      "-100 <= Node.val <= 100 Câu hỏi thêm: Recursive"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": ""
      },
      {
        "input": "root = [1,2,3,4,5,null,8,null,null,6,7,9]",
        "output": "[4,2,6,5,7,1,3,9,8]",
        "explanation": ""
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": ""
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> inorderTraversal(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<Integer> inorderTraversal(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var inorderTraversal = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def inorderTraversal(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:12 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\nGợi ý hướng giải: Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng. Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue).",
      "lastUpdated": "January 13, 2026 at 3:40:12 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> inorderTraversal(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<Integer> inorderTraversal(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var inorderTraversal = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def inorderTraversal(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[int] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "unique-binary-search-trees-ii",
    "title": "Unique Binary Search Trees II",
    "acceptance": 0.6165600438676658,
    "difficulty": "Medium",
    "likes": 7914,
    "dislikes": 581,
    "stars": null,
    "tags": [
      "dynamic-programming",
      "backtracking",
      "tree",
      "binary-search-tree",
      "binary-tree"
    ],
    "description": "Cho một số nguyên n, trả về tất cả structurally không trùng lặp BST's (nhị phân tìm kiếm cây), nào có chính xác n các nút của không trùng lặp các giá trị từ 1 để n. Trả về đáp án Theo bất kỳ thứ tự nào.",
    "constraints": [
      "1 <= n <= 8"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]",
        "explanation": ""
      },
      {
        "input": "n = 1",
        "output": "[[1]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<TreeNode*> generateTrees(int n) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<TreeNode> generateTrees(int n) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number} n * @return {TreeNode[]} */ var generateTrees = function(n) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def generateTrees(self, n): \"\"\" :type n: int :rtype: List[Optional[TreeNode]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:13 PM UTC+7",
    "editorial": {
      "content": "Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn. Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
      "lastUpdated": "January 13, 2026 at 3:40:13 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<TreeNode*> generateTrees(int n) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<TreeNode> generateTrees(int n) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number} n * @return {TreeNode[]} */ var generateTrees = function(n) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def generateTrees(self, n): \"\"\" :type n: int :rtype: List[Optional[TreeNode]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "unique-binary-search-trees",
    "title": "Unique Binary Search Trees",
    "acceptance": 0.6315353461672881,
    "difficulty": "Medium",
    "likes": 10934,
    "dislikes": 443,
    "stars": null,
    "tags": [
      "math",
      "dynamic-programming",
      "tree",
      "binary-search-tree",
      "binary-tree"
    ],
    "description": "Cho một số nguyên n, trả về số của structurally không trùng lặp BST's (nhị phân tìm kiếm cây) nào có chính xác n các nút của không trùng lặp các giá trị từ 1 để n.",
    "constraints": [
      "1 <= n <= 19"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "5",
        "explanation": ""
      },
      {
        "input": "n = 1",
        "output": "1",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int numTrees(int n) { } };",
      "java": "class Solution { public int numTrees(int n) { } }",
      "javascript": "/** * @param {number} n * @return {number} */ var numTrees = function(n) { };",
      "python": "class Solution(object): def numTrees(self, n): \"\"\" :type n: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:14 PM UTC+7",
    "editorial": {
      "content": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:14 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int numTrees(int n) { } };",
            "java": "class Solution { public int numTrees(int n) { } }",
            "javascript": "/** * @param {number} n * @return {number} */ var numTrees = function(n) { };",
            "python": "class Solution(object): def numTrees(self, n): \"\"\" :type n: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "interleaving-string",
    "title": "Interleaving String",
    "acceptance": 0.4328005599953333,
    "difficulty": "Medium",
    "likes": 8774,
    "dislikes": 548,
    "stars": null,
    "tags": [
      "string",
      "dynamic-programming"
    ],
    "description": "Cho các chuỗi s1, s2, và s3, tìm liệu s3 là tạo thành bởi một interleaving của s1 và s2. Một interleaving của hai các chuỗi s và t là một configuration ở đâu s và t là divided thành n và m chuỗi con tương ứng, Sao cho: s = s1 + s2 +... + sn t = t1 + t2 +... + tm |n - m| <= 1 interleaving là s1 + t1 + s2 + t2 + s3 + t3 +... hoặc t1 + s1 + t2 + s2 + t3 + s3 +... Lưu ý: một + b là concatenation của các chuỗi một và b.",
    "constraints": [
      "0 <= s1.length, s2.length <= 100",
      "0 <= s3.length <= 200 s1, s2, và s3 consist của chữ thường Tiếng Anh các chữ cái. Câu hỏi thêm: Bạn có thể solve nó using chỉ O(s2.length) additional bộ nhớ bộ nhớ?"
    ],
    "examples": [
      {
        "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
        "output": "true",
        "explanation": "Một way để obtain s3 là: Tách s1 thành s1 = \"aa\" + \"bc\" + \"c\", và s2 thành s2 = \"dbbc\" + \"a\". Interleaving hai tách, chúng ta get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\". Vì s3 có thể là obtained bởi interleaving s1 và s2, chúng ta trả về đúng."
      },
      {
        "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
        "output": "false",
        "explanation": "Notice làm thế nào nó là impossible để interleave s2 với bất kỳ other chuỗi để obtain s3."
      },
      {
        "input": "s1 = \"\", s2 = \"\", s3 = \"\"",
        "output": "true",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool isInterleave(string s1, string s2, string s3) { } };",
      "java": "class Solution { public boolean isInterleave(String s1, String s2, String s3) { } }",
      "javascript": "/** * @param {string} s1 * @param {string} s2 * @param {string} s3 * @return {boolean} */ var isInterleave = function(s1, s2, s3) { };",
      "python": "class Solution(object): def isInterleave(self, s1, s2, s3): \"\"\" :type s1: str :type s2: str :type s3: str :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:14 PM UTC+7",
    "editorial": {
      "content": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2. An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that: s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| <= 1 The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ... Note: a + b is the concatenation of strings a and b.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:14 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: bool isInterleave(string s1, string s2, string s3) { } };",
            "java": "class Solution { public boolean isInterleave(String s1, String s2, String s3) { } }",
            "javascript": "/** * @param {string} s1 * @param {string} s2 * @param {string} s3 * @return {boolean} */ var isInterleave = function(s1, s2, s3) { };",
            "python": "class Solution(object): def isInterleave(self, s1, s2, s3): \"\"\" :type s1: str :type s2: str :type s3: str :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "validate-binary-search-tree",
    "title": "Validate Binary Search Tree",
    "acceptance": 0.35180172422773354,
    "difficulty": "Medium",
    "likes": 18168,
    "dislikes": 1440,
    "stars": null,
    "tags": [
      "tree",
      "depth-first-search",
      "binary-search-tree",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân, xác định nếu nó là một hợp lệ cây tìm kiếm nhị phân (BST). Một hợp lệ BST là defined như theo: left subtree của một nút Chỉ chứa các nút với khóa strictly nhỏ hơn node's khóa. right subtree của một nút Chỉ chứa các nút với khóa strictly lớn hơn node's khóa. Both left và right subtrees phải cũng là nhị phân tìm kiếm cây.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [1, 104].",
      "-231 <= Node.val <= 231 - 1"
    ],
    "examples": [
      {
        "input": "root = [2,1,3]",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "root = [5,1,4,null,null,3,6]",
        "output": "false",
        "explanation": "root node's giá trị là 5 but nó right child's giá trị là 4."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isValidBST(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isValidBST(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isValidBST = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isValidBST(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:15 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys strictly less than the node's key. The right subtree of a node contains only nodes with keys strictly greater than the node's key. Both the left and right subtrees must also be binary search trees.\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
      "lastUpdated": "January 13, 2026 at 3:40:15 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "DFS",
          "description": "Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isValidBST(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isValidBST(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isValidBST = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isValidBST(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "recover-binary-search-tree",
    "title": "Recover Binary Search Tree",
    "acceptance": 0.5839643948452239,
    "difficulty": "Medium",
    "likes": 8515,
    "dislikes": 287,
    "stars": null,
    "tags": [
      "tree",
      "depth-first-search",
      "binary-search-tree",
      "binary-tree"
    ],
    "description": "Bạn được cho root của một cây tìm kiếm nhị phân (BST), ở đâu các giá trị của chính xác hai các nút của cây là hoán đổi bởi mistake. Recover cây không changing nó cấu trúc.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [2, 1000].",
      "-231 <= Node.val <= 231 - 1 Câu hỏi thêm: Một lời giải using O(n) bộ nhớ là pretty straight-forward. Bạn có thể devise một constant O(1) bộ nhớ lời giải?",
      "-231 <= Node.val <= 231 - 1 Câu hỏi thêm: Một"
    ],
    "examples": [
      {
        "input": "root = [1,3,null,null,2]",
        "output": "[3,1,null,null,2]",
        "explanation": "3 không thể là một left child của 1 vì 3 > 1. Hoán đổi 1 và 3 tạo BST hợp lệ."
      },
      {
        "input": "root = [3,1,4,null,null,2]",
        "output": "[2,1,4,null,null,3]",
        "explanation": "2 không thể là trong right subtree của 3 vì 2 < 3. Hoán đổi 2 và 3 tạo BST hợp lệ."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void recoverTree(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void recoverTree(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {void} Do not return anything, modify root in-place instead. */ var recoverTree = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def recoverTree(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: None Do not return anything, modify root in-place instead. \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:16 PM UTC+7",
    "editorial": {
      "content": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
      "lastUpdated": "January 13, 2026 at 3:40:16 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "DFS",
          "description": "Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void recoverTree(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void recoverTree(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {void} Do not return anything, modify root in-place instead. */ var recoverTree = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def recoverTree(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: None Do not return anything, modify root in-place instead. \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "same-tree",
    "title": "Same Tree",
    "acceptance": 0.6638059167564788,
    "difficulty": "Easy",
    "likes": 12696,
    "dislikes": 290,
    "stars": null,
    "tags": [
      "tree",
      "depth-first-search",
      "breadth-first-search",
      "binary-tree"
    ],
    "description": "Cho roots của hai nhị phân cây p và q, viết một hàm để kiểm tra nếu họ là giống nhau hoặc không. Hai nhị phân cây là considered giống nhau nếu họ là structurally identical, và các nút có giống nhau giá trị.",
    "constraints": [
      "số của các nút trong both cây là Trong khoảng [0, 100].",
      "-104 <= Node.val <= 104"
    ],
    "examples": [
      {
        "input": "p = [1,2,3], q = [1,2,3]",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "p = [1,2], q = [1,null,2]",
        "output": "false",
        "explanation": ""
      },
      {
        "input": "p = [1,2,1], q = [1,1,2]",
        "output": "false",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */ var isSameTree = function(p, q) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isSameTree(self, p, q): \"\"\" :type p: Optional[TreeNode] :type q: Optional[TreeNode] :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:16 PM UTC+7",
    "editorial": {
      "content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
      "lastUpdated": "January 13, 2026 at 3:40:16 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */ var isSameTree = function(p, q) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isSameTree(self, p, q): \"\"\" :type p: Optional[TreeNode] :type q: Optional[TreeNode] :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "symmetric-tree",
    "title": "Symmetric Tree",
    "acceptance": 0.6047369633077468,
    "difficulty": "Easy",
    "likes": 16636,
    "dislikes": 448,
    "stars": null,
    "tags": [
      "tree",
      "depth-first-search",
      "breadth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân, kiểm tra liệu nó là một mirror của chính nó (i.e., symmetric around nó center).",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [1, 1000].",
      "-100 <= Node.val <= 100 Câu hỏi thêm: Bạn có thể solve nó both recursively và iteratively?"
    ],
    "examples": [
      {
        "input": "root = [1,2,2,3,4,4,3]",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "root = [1,2,2,null,3,null,3]",
        "output": "false",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSymmetric(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isSymmetric = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isSymmetric(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:18 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
      "lastUpdated": "January 13, 2026 at 3:40:18 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSymmetric(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isSymmetric = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isSymmetric(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "binary-tree-level-order-traversal",
    "title": "Binary Tree Level Order Traversal",
    "acceptance": 0.7191674707975583,
    "difficulty": "Medium",
    "likes": 16808,
    "dislikes": 366,
    "stars": null,
    "tags": [
      "tree",
      "breadth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân, trả về mức thứ tự duyệt của nó các nút' các giá trị. (i.e., từ left để right, mức bởi mức).",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]",
        "explanation": ""
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": ""
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "Dùng một hàng đợi để perform BFS.",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> levelOrder(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<List<Integer>> levelOrder(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrder(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:19 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\n\nHint/nhắc ý (crawl được): Use a queue to perform BFS.\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
      "lastUpdated": "January 13, 2026 at 3:40:19 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> levelOrder(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<List<Integer>> levelOrder(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrder = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrder(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "binary-tree-zigzag-level-order-traversal",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "acceptance": 0.629219754820518,
    "difficulty": "Medium",
    "likes": 11875,
    "dislikes": 348,
    "stars": null,
    "tags": [
      "tree",
      "breadth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân, trả về zigzag mức thứ tự duyệt của nó các nút' các giá trị. (i.e., từ left để right, thì right để left cho next mức và alternate giữa).",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 2000].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]",
        "explanation": ""
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": ""
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> zigzagLevelOrder(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<List<Integer>> zigzagLevelOrder(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var zigzagLevelOrder = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def zigzagLevelOrder(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:19 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
      "lastUpdated": "January 13, 2026 at 3:40:19 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> zigzagLevelOrder(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<List<Integer>> zigzagLevelOrder(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var zigzagLevelOrder = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def zigzagLevelOrder(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "maximum-depth-of-binary-tree",
    "title": "Maximum Depth of Binary Tree",
    "acceptance": 0.7778624060879986,
    "difficulty": "Easy",
    "likes": 14100,
    "dislikes": 282,
    "stars": null,
    "tags": [
      "tree",
      "depth-first-search",
      "breadth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân, trả về nó lớn nhất độ sâu. Một cây nhị phân's lớn nhất độ sâu là số của các nút along dài nhất đường đi từ root nút down để farthest leaf nút.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 104].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": ""
      },
      {
        "input": "root = [1,null,2]",
        "output": "2",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int maxDepth(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int maxDepth(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def maxDepth(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:20 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
      "lastUpdated": "January 13, 2026 at 3:40:20 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int maxDepth(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int maxDepth(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var maxDepth = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def maxDepth(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "acceptance": 0.6811035142543923,
    "difficulty": "Medium",
    "likes": 16446,
    "dislikes": 611,
    "stars": null,
    "tags": [
      "array",
      "hash-table",
      "divide-and-conquer",
      "tree",
      "binary-tree"
    ],
    "description": "Cho hai số nguyên các mảng preorder và inorder ở đâu preorder là preorder duyệt của một cây nhị phân và inorder là inorder duyệt của giống nhau cây, construct và trả về cây nhị phân.",
    "constraints": [
      "1 <= preorder.length <= 3000 inorder.length == preorder.length",
      "-3000 <= preorder[i], inorder[i] <= 3000 preorder và inorder consist của không trùng lặp các giá trị. Each giá trị của inorder cũng appears trong preorder. preorder là được đảm bảo để là preorder duyệt của cây. inorder là được đảm bảo để là inorder duyệt của cây."
    ],
    "examples": [
      {
        "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
        "output": "[3,9,20,null,null,15,7]",
        "explanation": ""
      },
      {
        "input": "preorder = [-1], inorder = [-1]",
        "output": "[-1]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[]} preorder * @param {number[]} inorder * @return {TreeNode} */ var buildTree = function(preorder, inorder) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def buildTree(self, preorder, inorder): \"\"\" :type preorder: List[int] :type inorder: List[int] :rtype: Optional[TreeNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:21 PM UTC+7",
    "editorial": {
      "content": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả.",
      "lastUpdated": "January 13, 2026 at 3:40:21 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[]} preorder * @param {number[]} inorder * @return {TreeNode} */ var buildTree = function(preorder, inorder) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def buildTree(self, preorder, inorder): \"\"\" :type preorder: List[int] :type inorder: List[int] :rtype: Optional[TreeNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "construct-binary-tree-from-inorder-and-postorder-traversal",
    "title": "Construct Binary Tree from Inorder and Postorder Traversal",
    "acceptance": 0.6773149575425248,
    "difficulty": "Medium",
    "likes": 8612,
    "dislikes": 154,
    "stars": null,
    "tags": [
      "array",
      "hash-table",
      "divide-and-conquer",
      "tree",
      "binary-tree"
    ],
    "description": "Cho hai số nguyên các mảng inorder và postorder ở đâu inorder là inorder duyệt của một cây nhị phân và postorder là postorder duyệt của giống nhau cây, construct và trả về cây nhị phân.",
    "constraints": [
      "1 <= inorder.length <= 3000 postorder.length == inorder.length",
      "-3000 <= inorder[i], postorder[i] <= 3000 inorder và postorder consist của không trùng lặp các giá trị. Each giá trị của postorder cũng appears trong inorder. inorder là được đảm bảo để là inorder duyệt của cây. postorder là được đảm bảo để là postorder duyệt của cây."
    ],
    "examples": [
      {
        "input": "inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]",
        "output": "[3,9,20,null,null,15,7]",
        "explanation": ""
      },
      {
        "input": "inorder = [-1], postorder = [-1]",
        "output": "[-1]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[]} inorder * @param {number[]} postorder * @return {TreeNode} */ var buildTree = function(inorder, postorder) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def buildTree(self, inorder, postorder): \"\"\" :type inorder: List[int] :type postorder: List[int] :rtype: Optional[TreeNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:22 PM UTC+7",
    "editorial": {
      "content": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả.",
      "lastUpdated": "January 13, 2026 at 3:40:22 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[]} inorder * @param {number[]} postorder * @return {TreeNode} */ var buildTree = function(inorder, postorder) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def buildTree(self, inorder, postorder): \"\"\" :type inorder: List[int] :type postorder: List[int] :rtype: Optional[TreeNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "binary-tree-level-order-traversal-ii",
    "title": "Binary Tree Level Order Traversal II",
    "acceptance": 0.6736743179983313,
    "difficulty": "Medium",
    "likes": 5126,
    "dislikes": 333,
    "stars": null,
    "tags": [
      "tree",
      "breadth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân, trả về dưới cùng-ra mức thứ tự duyệt của nó các nút' các giá trị. (i.e., từ left để right, mức bởi mức từ leaf để root).",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[15,7],[9,20],[3]]",
        "explanation": ""
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": ""
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> levelOrderBottom(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<List<Integer>> levelOrderBottom(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrderBottom = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrderBottom(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:23 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
      "lastUpdated": "January 13, 2026 at 3:40:23 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> levelOrderBottom(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<List<Integer>> levelOrderBottom(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[][]} */ var levelOrderBottom = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrderBottom(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "convert-sorted-array-to-binary-search-tree",
    "title": "Convert Sorted Array to Binary Search Tree",
    "acceptance": 0.7501027063874026,
    "difficulty": "Easy",
    "likes": 11790,
    "dislikes": 635,
    "stars": null,
    "tags": [
      "array",
      "divide-and-conquer",
      "tree",
      "binary-search-tree",
      "binary-tree"
    ],
    "description": "Cho một số nguyên mảng nums ở đâu các phần tử là đã sắp xếp trong thứ tự tăng dần, chuyển đổi nó để một chiều cao-balanced cây tìm kiếm nhị phân.",
    "constraints": [
      "1 <= nums.length <= 104",
      "-104 <= nums[i] <= 104 nums là đã sắp xếp trong một strictly tăng thứ tự."
    ],
    "examples": [
      {
        "input": "nums = [-10,-3,0,5,9]",
        "output": "[0,-3,9,-10,null,5]",
        "explanation": "[0,-10,5,null,-3,null,9] là cũng accepted:"
      },
      {
        "input": "nums = [1,3]",
        "output": "[3,1]",
        "explanation": "[1,null,3] và [3,1] là both chiều cao-balanced BSTs."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* sortedArrayToBST(vector<int>& nums) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode sortedArrayToBST(int[] nums) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[]} nums * @return {TreeNode} */ var sortedArrayToBST = function(nums) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def sortedArrayToBST(self, nums): \"\"\" :type nums: List[int] :rtype: Optional[TreeNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:23 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\n\nGợi ý hướng giải: Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả. Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue).",
      "lastUpdated": "January 13, 2026 at 3:40:23 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Divide and Conquer",
          "description": "Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả.",
          "timeComplexity": "$O(n\\log n)$ hoặc tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* sortedArrayToBST(vector<int>& nums) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode sortedArrayToBST(int[] nums) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {number[]} nums * @return {TreeNode} */ var sortedArrayToBST = function(nums) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def sortedArrayToBST(self, nums): \"\"\" :type nums: List[int] :rtype: Optional[TreeNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "convert-sorted-list-to-binary-search-tree",
    "title": "Convert Sorted List to Binary Search Tree",
    "acceptance": 0.6570139198879937,
    "difficulty": "Medium",
    "likes": 7829,
    "dislikes": 173,
    "stars": null,
    "tags": [
      "linked-list",
      "divide-and-conquer",
      "tree",
      "binary-search-tree",
      "binary-tree"
    ],
    "description": "Cho head của một singly danh sách liên kết ở đâu các phần tử là đã sắp xếp trong thứ tự tăng dần, chuyển đổi nó để một chiều cao-balanced cây tìm kiếm nhị phân.",
    "constraints": [
      "số của các nút trong head là Trong khoảng [0, 2 * 104].",
      "-105 <= Node.val <= 105"
    ],
    "examples": [
      {
        "input": "head = [-10,-3,0,5,9]",
        "output": "[0,-3,9,-10,null,5]",
        "explanation": "Một có thể đáp án là [0,-3,9,-10,null,5], nào biểu diễn shown chiều cao balanced BST."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* sortedListToBST(ListNode* head) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode sortedListToBST(ListNode head) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {ListNode} head * @return {TreeNode} */ var sortedListToBST = function(head) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def sortedListToBST(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[TreeNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:24 PM UTC+7",
    "editorial": {
      "content": "Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả.",
      "lastUpdated": "January 13, 2026 at 3:40:24 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Divide and Conquer",
          "description": "Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả.",
          "timeComplexity": "$O(n\\log n)$ hoặc tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* sortedListToBST(ListNode* head) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode sortedListToBST(ListNode head) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {ListNode} head * @return {TreeNode} */ var sortedListToBST = function(head) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def sortedListToBST(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[TreeNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "balanced-binary-tree",
    "title": "Balanced Binary Tree",
    "acceptance": 0.5681286635236723,
    "difficulty": "Easy",
    "likes": 11823,
    "dislikes": 820,
    "stars": null,
    "tags": [
      "tree",
      "depth-first-search",
      "binary-tree"
    ],
    "description": "Cho một cây nhị phân, xác định nếu nó là chiều cao-balanced.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 5000].",
      "-104 <= Node.val <= 104"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "true",
        "explanation": ""
      },
      {
        "input": "root = [1,2,2,3,3,null,null,4,4]",
        "output": "false",
        "explanation": ""
      },
      {
        "input": "root = []",
        "output": "true",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isBalanced(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isBalanced(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isBalanced = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isBalanced(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:25 PM UTC+7",
    "editorial": {
      "content": "Given a binary tree, determine if it is height-balanced.\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
      "lastUpdated": "January 13, 2026 at 3:40:25 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "DFS",
          "description": "Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isBalanced(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isBalanced(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {boolean} */ var isBalanced = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isBalanced(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "minimum-depth-of-binary-tree",
    "title": "Minimum Depth of Binary Tree",
    "acceptance": 0.5204629077208497,
    "difficulty": "Easy",
    "likes": 7767,
    "dislikes": 1360,
    "stars": null,
    "tags": [
      "tree",
      "depth-first-search",
      "breadth-first-search",
      "binary-tree"
    ],
    "description": "Cho một cây nhị phân, tìm nó nhỏ nhất độ sâu. nhỏ nhất độ sâu là số của các nút along ngắn nhất đường đi từ root nút down để nearest leaf nút. Lưu ý: Một leaf là một nút với không children.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 105].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "2",
        "explanation": ""
      },
      {
        "input": "root = [2,null,3,null,4,null,5,null,6]",
        "output": "5",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int minDepth(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int minDepth(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var minDepth = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def minDepth(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:26 PM UTC+7",
    "editorial": {
      "content": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children.\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
      "lastUpdated": "January 13, 2026 at 3:40:26 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int minDepth(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int minDepth(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var minDepth = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def minDepth(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "path-sum",
    "title": "Path Sum",
    "acceptance": 0.541585360420862,
    "difficulty": "Easy",
    "likes": 10567,
    "dislikes": 1207,
    "stars": null,
    "tags": [
      "tree",
      "depth-first-search",
      "breadth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân và một số nguyên targetSum, trả về đúng nếu cây có một root-để-leaf đường đi Sao cho cộng ra tất cả các giá trị along đường đi bằng targetSum. Một leaf là một nút với không children.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 5000].",
      "-1000 <= Node.val <= 1000",
      "-1000 <= targetSum <= 1000"
    ],
    "examples": [
      {
        "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
        "output": "true",
        "explanation": "root-để-leaf đường đi với target tổng là shown."
      },
      {
        "input": "root = [1,2,3], targetSum = 5",
        "output": "false",
        "explanation": "Có hai root-để-leaf các đường đi trong cây: (1 --> 2): tổng là 3. (1 --> 3): tổng là 4. Có không root-để-leaf đường đi với tổng = 5."
      },
      {
        "input": "root = [], targetSum = 0",
        "output": "false",
        "explanation": "Vì cây là rỗng, Có không root-để-leaf các đường đi."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} targetSum * @return {boolean} */ var hasPathSum = function(root, targetSum) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def hasPathSum(self, root, targetSum): \"\"\" :type root: Optional[TreeNode] :type targetSum: int :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:27 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children.\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
      "lastUpdated": "January 13, 2026 at 3:40:27 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} targetSum * @return {boolean} */ var hasPathSum = function(root, targetSum) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def hasPathSum(self, root, targetSum): \"\"\" :type root: Optional[TreeNode] :type targetSum: int :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "path-sum-ii",
    "title": "Path Sum II",
    "acceptance": 0.6153876549714342,
    "difficulty": "Medium",
    "likes": 8544,
    "dislikes": 170,
    "stars": null,
    "tags": [
      "backtracking",
      "tree",
      "depth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân và một số nguyên targetSum, trả về tất cả root-để-leaf các đường đi ở đâu tổng của nút các giá trị trong đường đi bằng targetSum. Each đường đi nên là trả về như một danh sách của nút các giá trị, không nút references. Một root-để-leaf đường đi là một đường đi bắt đầu từ root và kết thúc tại bất kỳ leaf nút. Một leaf là một nút với không children.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 5000].",
      "-1000 <= Node.val <= 1000",
      "-1000 <= targetSum <= 1000"
    ],
    "examples": [
      {
        "input": "root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22",
        "output": "[[5,4,11,2],[5,8,4,5]]",
        "explanation": "Có hai các đường đi whose tổng bằng targetSum: 5 + 4 + 11 + 2 = 22 5 + 8 + 4 + 5 = 22"
      },
      {
        "input": "root = [1,2,3], targetSum = 5",
        "output": "[]",
        "explanation": ""
      },
      {
        "input": "root = [1,2], targetSum = 0",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> pathSum(TreeNode* root, int targetSum) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<List<Integer>> pathSum(TreeNode root, int targetSum) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} targetSum * @return {number[][]} */ var pathSum = function(root, targetSum) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def pathSum(self, root, targetSum): \"\"\" :type root: Optional[TreeNode] :type targetSum: int :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:27 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.\n\nGợi ý hướng giải: Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu). Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue).",
      "lastUpdated": "January 13, 2026 at 3:40:27 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Backtracking",
          "description": "Thử các lựa chọn theo cây trạng thái; khi không hợp lệ thì quay lui (prune để tối ưu).",
          "timeComplexity": "Thường là hàm mũ",
          "spaceComplexity": "Theo độ sâu đệ quy",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<vector<int>> pathSum(TreeNode* root, int targetSum) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<List<Integer>> pathSum(TreeNode root, int targetSum) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @param {number} targetSum * @return {number[][]} */ var pathSum = function(root, targetSum) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def pathSum(self, root, targetSum): \"\"\" :type root: Optional[TreeNode] :type targetSum: int :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "flatten-binary-tree-to-linked-list",
    "title": "Flatten Binary Tree to Linked List",
    "acceptance": 0.699330010127448,
    "difficulty": "Medium",
    "likes": 13499,
    "dislikes": 597,
    "stars": null,
    "tags": [
      "linked-list",
      "stack",
      "tree",
      "depth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân, flatten cây thành một \"linked list\": \"linked list\" nên dùng giống nhau TreeNode lớp ở đâu right child con trỏ points để next nút trong danh sách và left child con trỏ là always null. \"linked list\" nên là trong giống nhau thứ tự như một pre-thứ tự duyệt của cây nhị phân.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 2000].",
      "-100 <= Node.val <= 100 Câu hỏi thêm: Bạn có thể flatten cây trong-place (với O(1) extra bộ nhớ)?"
    ],
    "examples": [
      {
        "input": "root = [1,2,5,3,4,null,6]",
        "output": "[1,null,2,null,3,null,4,null,5,null,6]",
        "explanation": ""
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": ""
      },
      {
        "input": "root = [0]",
        "output": "[0]",
        "explanation": ""
      }
    ],
    "content": "Nếu bạn notice carefully trong flattened cây, each node's right child points để next nút của một pre-thứ tự duyệt.",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void flatten(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void flatten(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {void} Do not return anything, modify root in-place instead. */ var flatten = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def flatten(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: None Do not return anything, modify root in-place instead. \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:28 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree, flatten the tree into a \"linked list\": The \"linked list\" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The \"linked list\" should be in the same order as a pre-order traversal of the binary tree.\n\nHint/nhắc ý (crawl được): If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
      "lastUpdated": "January 13, 2026 at 3:40:28 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void flatten(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void flatten(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {void} Do not return anything, modify root in-place instead. */ var flatten = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def flatten(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: None Do not return anything, modify root in-place instead. \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "distinct-subsequences",
    "title": "Distinct Subsequences",
    "acceptance": 0.5129841645308654,
    "difficulty": "Hard",
    "likes": 7312,
    "dislikes": 319,
    "stars": null,
    "tags": [
      "string",
      "dynamic-programming"
    ],
    "description": "Cho hai các chuỗi s và t, trả về số của phân biệt dãy con của s nào bằng t. test trường hợp là generated vì vậy đó đáp án fits trên một 32-bit có dấu số nguyên.",
    "constraints": [
      "1 <= s.length, t.length <= 1000 s và t consist của Tiếng Anh các chữ cái."
    ],
    "examples": [
      {
        "input": "s = \"rabbbit\", t = \"rabbit\"",
        "output": "3",
        "explanation": "Như shown bên dưới, Có 3 ways Bạn có thể generate \"rabbit\" từ s. rabbbit rabbbit rabbbit"
      },
      {
        "input": "s = \"babgbag\", t = \"bag\"",
        "output": "5",
        "explanation": "Như shown bên dưới, Có 5 ways Bạn có thể generate \"bag\" từ s. babgbag babgbag babgbag babgbag babgbag"
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int numDistinct(string s, string t) { } };",
      "java": "class Solution { public int numDistinct(String s, String t) { } }",
      "javascript": "/** * @param {string} s * @param {string} t * @return {number} */ var numDistinct = function(s, t) { };",
      "python": "class Solution(object): def numDistinct(self, s, t): \"\"\" :type s: str :type t: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:29 PM UTC+7",
    "editorial": {
      "content": "Given two strings s and t, return the number of distinct subsequences of s which equals t. The test cases are generated so that the answer fits on a 32-bit signed integer.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:29 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int numDistinct(string s, string t) { } };",
            "java": "class Solution { public int numDistinct(String s, String t) { } }",
            "javascript": "/** * @param {string} s * @param {string} t * @return {number} */ var numDistinct = function(s, t) { };",
            "python": "class Solution(object): def numDistinct(self, s, t): \"\"\" :type s: str :type t: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "populating-next-right-pointers-in-each-node",
    "title": "Populating Next Right Pointers in Each Node",
    "acceptance": 0.6663419366263149,
    "difficulty": "Medium",
    "likes": 10340,
    "dislikes": 325,
    "stars": null,
    "tags": [
      "linked-list",
      "tree",
      "depth-first-search",
      "breadth-first-search",
      "binary-tree"
    ],
    "description": "Bạn được cho một perfect cây nhị phân ở đâu tất cả leaves là trên giống nhau mức, và mỗi parent có hai children. cây nhị phân có sau đây definition: struct Nút { int val; Nút *left; Nút *right; Nút *next; } Populate each next con trỏ để point để nó next right nút. Nếu Có không next right nút, next con trỏ nên là tập hợp để NULL. Initially, tất cả next các con trỏ là tập hợp để NULL.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 212 - 1].",
      "-1000 <= Node.val <= 1000 Câu hỏi thêm: Bạn có thể chỉ dùng constant extra bộ nhớ. recursive approach là fine. Bạn có thể giả sử implicit ngăn xếp bộ nhớ không count như extra bộ nhớ cho điều này problem.",
      "-1000 <= Node.val <= 1000 Câu hỏi thêm: Bạn có thể chỉ dùng constant extra bộ nhớ. recursive"
    ],
    "examples": [
      {
        "input": "root = [1,2,3,4,5,6,7]",
        "output": "[1,#,2,3,#,4,5,6,7,#]",
        "explanation": "Cho bên trên perfect cây nhị phân (Figure Một), của bạn hàm nên populate each next con trỏ để point để nó next right nút, chỉ like trong Figure B. serialized đầu ra là trong mức thứ tự như connected bởi next các con trỏ, với '#' signifying kết thúc của each mức."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public: Node* connect(Node* root) { } };",
      "java": "/* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { } }",
      "javascript": "/** * // Definition for a _Node. * function _Node(val, left, right, next) { * this.val = val === undefined ? null : val; * this.left = left === undefined ? null : left; * this.right = right === undefined ? null : right; * this.next = next === undefined ? null : next; * }; */ /** * @param {_Node} root * @return {_Node} */ var connect = function(root) { };",
      "python": "\"\"\" # Definition for a Node. class Node(object): def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next \"\"\" class Solution(object): def connect(self, root): \"\"\" :type root: Node :rtype: Node \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:29 PM UTC+7",
    "editorial": {
      "content": "You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue).",
      "lastUpdated": "January 13, 2026 at 3:40:29 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public: Node* connect(Node* root) { } };",
            "java": "/* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { } }",
            "javascript": "/** * // Definition for a _Node. * function _Node(val, left, right, next) { * this.val = val === undefined ? null : val; * this.left = left === undefined ? null : left; * this.right = right === undefined ? null : right; * this.next = next === undefined ? null : next; * }; */ /** * @param {_Node} root * @return {_Node} */ var connect = function(root) { };",
            "python": "\"\"\" # Definition for a Node. class Node(object): def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next \"\"\" class Solution(object): def connect(self, root): \"\"\" :type root: Node :rtype: Node \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "populating-next-right-pointers-in-each-node-ii",
    "title": "Populating Next Right Pointers in Each Node II",
    "acceptance": 0.5687031100471794,
    "difficulty": "Medium",
    "likes": 6158,
    "dislikes": 341,
    "stars": null,
    "tags": [
      "linked-list",
      "tree",
      "depth-first-search",
      "breadth-first-search",
      "binary-tree"
    ],
    "description": "Cho một cây nhị phân struct Nút { int val; Nút *left; Nút *right; Nút *next; } Populate each next con trỏ để point để nó next right nút. Nếu Có không next right nút, next con trỏ nên là tập hợp để NULL. Initially, tất cả next các con trỏ là tập hợp để NULL.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 6000].",
      "-100 <= Node.val <= 100 Câu hỏi thêm: Bạn có thể chỉ dùng constant extra bộ nhớ. recursive approach là fine. Bạn có thể giả sử implicit ngăn xếp bộ nhớ không count như extra bộ nhớ cho điều này problem.",
      "-100 <= Node.val <= 100 Câu hỏi thêm: Bạn có thể chỉ dùng constant extra bộ nhớ. recursive"
    ],
    "examples": [
      {
        "input": "root = [1,2,3,4,5,null,7]",
        "output": "[1,#,2,3,#,4,5,7,#]",
        "explanation": "Cho bên trên cây nhị phân (Figure Một), của bạn hàm nên populate each next con trỏ để point để nó next right nút, chỉ like trong Figure B. serialized đầu ra là trong mức thứ tự như connected bởi next các con trỏ, với '#' signifying kết thúc của each mức."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public: Node* connect(Node* root) { } };",
      "java": "/* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { } }",
      "javascript": "/** * // Definition for a _Node. * function _Node(val, left, right, next) { * this.val = val === undefined ? null : val; * this.left = left === undefined ? null : left; * this.right = right === undefined ? null : right; * this.next = next === undefined ? null : next; * }; */ /** * @param {_Node} root * @return {_Node} */ var connect = function(root) { };",
      "python": "\"\"\" # Definition for a Node. class Node(object): def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next \"\"\" class Solution(object): def connect(self, root): \"\"\" :type root: Node :rtype: Node \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:30 PM UTC+7",
    "editorial": {
      "content": "Given a binary tree struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue).",
      "lastUpdated": "January 13, 2026 at 3:40:30 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public: Node* connect(Node* root) { } };",
            "java": "/* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { } }",
            "javascript": "/** * // Definition for a _Node. * function _Node(val, left, right, next) { * this.val = val === undefined ? null : val; * this.left = left === undefined ? null : left; * this.right = right === undefined ? null : right; * this.next = next === undefined ? null : next; * }; */ /** * @param {_Node} root * @return {_Node} */ var connect = function(root) { };",
            "python": "\"\"\" # Definition for a Node. class Node(object): def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next \"\"\" class Solution(object): def connect(self, root): \"\"\" :type root: Node :rtype: Node \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "pascals-triangle",
    "title": "Pascal's Triangle",
    "acceptance": 0.7851637176983022,
    "difficulty": "Easy",
    "likes": 14748,
    "dislikes": 559,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming"
    ],
    "description": "Cho một số nguyên numRows, trả về đầu tiên numRows của Pascal's triangle. Trong Pascal's triangle, each số là tổng của hai các số directly bên trên nó như shown:",
    "constraints": [
      "1 <= numRows <= 30"
    ],
    "examples": [
      {
        "input": "numRows = 5",
        "output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
        "explanation": ""
      },
      {
        "input": "numRows = 1",
        "output": "[[1]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<int>> generate(int numRows) { } };",
      "java": "class Solution { public List<List<Integer>> generate(int numRows) { } }",
      "javascript": "/** * @param {number} numRows * @return {number[][]} */ var generate = function(numRows) { };",
      "python": "class Solution(object): def generate(self, numRows): \"\"\" :type numRows: int :rtype: List[List[int]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:31 PM UTC+7",
    "editorial": {
      "content": "Given an integer numRows, return the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:31 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: vector<vector<int>> generate(int numRows) { } };",
            "java": "class Solution { public List<List<Integer>> generate(int numRows) { } }",
            "javascript": "/** * @param {number} numRows * @return {number[][]} */ var generate = function(numRows) { };",
            "python": "class Solution(object): def generate(self, numRows): \"\"\" :type numRows: int :rtype: List[List[int]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "pascals-triangle-ii",
    "title": "Pascal's Triangle II",
    "acceptance": 0.6692537111678415,
    "difficulty": "Easy",
    "likes": 5243,
    "dislikes": 366,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming"
    ],
    "description": "Cho một số nguyên rowIndex, trả về rowIndexth (0-chỉ số) hàng của Pascal's triangle. Trong Pascal's triangle, each số là tổng của hai các số directly bên trên nó như shown:",
    "constraints": [
      "0 <= rowIndex <= 33 Câu hỏi thêm: Bạn có thể optimize của bạn thuật toán để dùng chỉ O(rowIndex) extra bộ nhớ?"
    ],
    "examples": [
      {
        "input": "rowIndex = 3",
        "output": "[1,3,3,1]",
        "explanation": ""
      },
      {
        "input": "rowIndex = 0",
        "output": "[1]",
        "explanation": ""
      },
      {
        "input": "rowIndex = 1",
        "output": "[1,1]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<int> getRow(int rowIndex) { } };",
      "java": "class Solution { public List<Integer> getRow(int rowIndex) { } }",
      "javascript": "/** * @param {number} rowIndex * @return {number[]} */ var getRow = function(rowIndex) { };",
      "python": "class Solution(object): def getRow(self, rowIndex): \"\"\" :type rowIndex: int :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:31 PM UTC+7",
    "editorial": {
      "content": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:31 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: vector<int> getRow(int rowIndex) { } };",
            "java": "class Solution { public List<Integer> getRow(int rowIndex) { } }",
            "javascript": "/** * @param {number} rowIndex * @return {number[]} */ var getRow = function(rowIndex) { };",
            "python": "class Solution(object): def getRow(self, rowIndex): \"\"\" :type rowIndex: int :rtype: List[int] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "triangle",
    "title": "Triangle",
    "acceptance": 0.5984290539883174,
    "difficulty": "Medium",
    "likes": 10739,
    "dislikes": 607,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming"
    ],
    "description": "Cho một triangle mảng, trả về nhỏ nhất đường đi tổng từ top để dưới cùng. Cho each bước, bạn có thể di chuyển để một kề nhau số của hàng bên dưới. Nhiều hơn formally, nếu bạn là trên chỉ số i trên hiện tại hàng, bạn có thể di chuyển để một trong hai chỉ số i hoặc chỉ số i + 1 trên next hàng.",
    "constraints": [
      "1 <= triangle.length <= 200 triangle[0].độ dài == 1 triangle[i].độ dài == triangle[i - 1].độ dài + 1",
      "-104 <= triangle[i][j] <= 104 Câu hỏi thêm: Bạn có thể làm điều này using chỉ O(n) extra bộ nhớ, ở đâu n là total số của các hàng trong triangle?"
    ],
    "examples": [
      {
        "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
        "output": "11",
        "explanation": "triangle looks like: 2 3 4 6 5 7 4 1 8 3 nhỏ nhất đường đi tổng từ top để dưới cùng là 2 + 3 + 5 + 1 = 11 (được gạch chân bên trên)."
      },
      {
        "input": "triangle = [[-10]]",
        "output": "-10",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int minimumTotal(vector<vector<int>>& triangle) { } };",
      "java": "class Solution { public int minimumTotal(List<List<Integer>> triangle) { } }",
      "javascript": "/** * @param {number[][]} triangle * @return {number} */ var minimumTotal = function(triangle) { };",
      "python": "class Solution(object): def minimumTotal(self, triangle): \"\"\" :type triangle: List[List[int]] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:32 PM UTC+7",
    "editorial": {
      "content": "Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:32 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int minimumTotal(vector<vector<int>>& triangle) { } };",
            "java": "class Solution { public int minimumTotal(List<List<Integer>> triangle) { } }",
            "javascript": "/** * @param {number[][]} triangle * @return {number} */ var minimumTotal = function(triangle) { };",
            "python": "class Solution(object): def minimumTotal(self, triangle): \"\"\" :type triangle: List[List[int]] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "best-time-to-buy-and-sell-stock",
    "title": "Best Time to Buy and Sell Stock",
    "acceptance": 0.5619082102904289,
    "difficulty": "Easy",
    "likes": 34953,
    "dislikes": 1386,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming"
    ],
    "description": "Bạn được cho một mảng prices ở đâu prices[i] là price của một cho cổ phiếu trên ith ngày. Bạn want để maximize của bạn lợi nhuận bởi choosing một một ngày để buy một cổ phiếu và choosing một khác nhau ngày trong future để sell đó cổ phiếu. Trả về lớn nhất lợi nhuận Bạn có thể achieve từ điều này transaction. Nếu bạn không thể achieve bất kỳ lợi nhuận, trả về 0.",
    "constraints": [
      "1 <= prices.length <= 105",
      "0 <= prices[i] <= 104"
    ],
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy trên ngày 2 (price = 1) và sell trên ngày 5 (price = 6), lợi nhuận = 6-1 = 5."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "Trong điều này trường hợp, không transactions là done và lớn nhất lợi nhuận = 0."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int maxProfit(vector<int>& prices) { } };",
      "java": "class Solution { public int maxProfit(int[] prices) { } }",
      "javascript": "/** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { };",
      "python": "class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:33 PM UTC+7",
    "editorial": {
      "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:33 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int maxProfit(vector<int>& prices) { } };",
            "java": "class Solution { public int maxProfit(int[] prices) { } }",
            "javascript": "/** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { };",
            "python": "class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "best-time-to-buy-and-sell-stock-ii",
    "title": "Best Time to Buy and Sell Stock II",
    "acceptance": 0.7053026611883039,
    "difficulty": "Medium",
    "likes": 15147,
    "dislikes": 2803,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming",
      "greedy"
    ],
    "description": "Bạn được cho một số nguyên mảng prices ở đâu prices[i] là price của một cho cổ phiếu trên ith ngày. Trên each ngày, bạn có thể decide để buy và/hoặc sell cổ phiếu. Bạn có thể chỉ hold Nhiều nhất một share của cổ phiếu tại bất kỳ thời gian. However, Bạn có thể sell và buy cổ phiếu nhiều lần trên giống nhau ngày, ensuring bạn never hold nhiều hơn hơn một share của cổ phiếu. Tìm và trả về lớn nhất lợi nhuận Bạn có thể achieve.",
    "constraints": [
      "1 <= prices.length <= 3 * 104",
      "0 <= prices[i] <= 104"
    ],
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "7",
        "explanation": "Buy trên ngày 2 (price = 1) và sell trên ngày 3 (price = 5), lợi nhuận = 5-1 = 4. Thì buy trên ngày 4 (price = 3) và sell trên ngày 5 (price = 6), lợi nhuận = 6-3 = 3. Total lợi nhuận là 4 + 3 = 7."
      },
      {
        "input": "prices = [1,2,3,4,5]",
        "output": "4",
        "explanation": "Buy trên ngày 1 (price = 1) và sell trên ngày 5 (price = 5), lợi nhuận = 5-1 = 4. Total lợi nhuận là 4."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "Có không way để tạo một dương lợi nhuận, vì vậy chúng ta never buy cổ phiếu để achieve lớn nhất lợi nhuận của 0."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int maxProfit(vector<int>& prices) { } };",
      "java": "class Solution { public int maxProfit(int[] prices) { } }",
      "javascript": "/** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { };",
      "python": "class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:33 PM UTC+7",
    "editorial": {
      "content": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can sell and buy the stock multiple times on the same day, ensuring you never hold more than one share of the stock. Find and return the maximum profit you can achieve.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn. Chọn quyết định cục bộ tối ưu và chứng minh rằng nó dẫn tới tối ưu toàn cục.",
      "lastUpdated": "January 13, 2026 at 3:40:33 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int maxProfit(vector<int>& prices) { } };",
            "java": "class Solution { public int maxProfit(int[] prices) { } }",
            "javascript": "/** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { };",
            "python": "class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "best-time-to-buy-and-sell-stock-iii",
    "title": "Best Time to Buy and Sell Stock III",
    "acceptance": 0.5287255377054209,
    "difficulty": "Hard",
    "likes": 10477,
    "dislikes": 220,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming"
    ],
    "description": "Bạn được cho một mảng prices ở đâu prices[i] là price của một cho cổ phiếu trên ith ngày. Tìm lớn nhất lợi nhuận Bạn có thể achieve. Bạn có thể complete Nhiều nhất hai transactions. Lưu ý: Bạn không được engage trong nhiều transactions simultaneously (i.e., bạn phải sell cổ phiếu trước bạn buy again).",
    "constraints": [
      "1 <= prices.length <= 105",
      "0 <= prices[i] <= 105"
    ],
    "examples": [
      {
        "input": "prices = [3,3,5,0,0,3,1,4]",
        "output": "6",
        "explanation": "Buy trên ngày 4 (price = 0) và sell trên ngày 6 (price = 3), lợi nhuận = 3-0 = 3. Thì buy trên ngày 7 (price = 1) và sell trên ngày 8 (price = 4), lợi nhuận = 4-1 = 3."
      },
      {
        "input": "prices = [1,2,3,4,5]",
        "output": "4",
        "explanation": "Buy trên ngày 1 (price = 1) và sell trên ngày 5 (price = 5), lợi nhuận = 5-1 = 4."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "Trong điều này trường hợp, không transaction là done, i.e. lớn nhất lợi nhuận = 0."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int maxProfit(vector<int>& prices) { } };",
      "java": "class Solution { public int maxProfit(int[] prices) { } }",
      "javascript": "/** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { };",
      "python": "class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:34 PM UTC+7",
    "editorial": {
      "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit you can achieve. You may complete at most two transactions. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:34 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int maxProfit(vector<int>& prices) { } };",
            "java": "class Solution { public int maxProfit(int[] prices) { } }",
            "javascript": "/** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { };",
            "python": "class Solution(object): def maxProfit(self, prices): \"\"\" :type prices: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "binary-tree-maximum-path-sum",
    "title": "Binary Tree Maximum Path Sum",
    "acceptance": 0.41889201770361145,
    "difficulty": "Hard",
    "likes": 18222,
    "dislikes": 783,
    "stars": null,
    "tags": [
      "dynamic-programming",
      "tree",
      "depth-first-search",
      "binary-tree"
    ],
    "description": "Một đường đi trong một cây nhị phân là một dãy của các nút ở đâu each cặp của kề nhau các nút trong dãy có một cạnh connecting chúng. Một nút có thể chỉ appear trong dãy Nhiều nhất một lần. Lưu ý rằng đường đi không need để lần duyệt through root. đường đi tổng của một đường đi là tổng của node's các giá trị trong đường đi. Cho root của một cây nhị phân, trả về lớn nhất đường đi tổng của bất kỳ không rỗng đường đi.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [1, 3 * 104].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [1,2,3]",
        "output": "6",
        "explanation": "optimal đường đi là 2 -> 1 -> 3 với một đường đi tổng của 2 + 1 + 3 = 6."
      },
      {
        "input": "root = [-10,9,20,null,null,15,7]",
        "output": "42",
        "explanation": "optimal đường đi là 15 -> 20 -> 7 với một đường đi tổng của 15 + 20 + 7 = 42."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int maxPathSum(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int maxPathSum(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var maxPathSum = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def maxPathSum(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:35 PM UTC+7",
    "editorial": {
      "content": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn. Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue).",
      "lastUpdated": "January 13, 2026 at 3:40:35 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int maxPathSum(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int maxPathSum(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var maxPathSum = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def maxPathSum(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "valid-palindrome",
    "title": "Valid Palindrome",
    "acceptance": 0.5245410111399322,
    "difficulty": "Easy",
    "likes": 11218,
    "dislikes": 8616,
    "stars": null,
    "tags": [
      "two-pointers",
      "string"
    ],
    "description": "Một phrase là một đối xứng nếu, sau chuyển đổi tất cả chữ hoa các chữ cái thành chữ thường các chữ cái và removing tất cả không-chữ và số các ký tự, nó đọc giống nhau forward và backward. Chữ và số các ký tự include các chữ cái và các số. Cho một chuỗi s, trả về đúng nếu nó là một đối xứng, hoặc sai otherwise.",
    "constraints": [
      "1 <= s.length <= 2 * 105 s Chỉ gồm printable ASCII các ký tự."
    ],
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "\"amanaplanacanalpanama\" là một đối xứng."
      },
      {
        "input": "s = \"race a car\"",
        "output": "false",
        "explanation": "\"raceacar\" là không một đối xứng."
      },
      {
        "input": "s = \" \"",
        "output": "true",
        "explanation": "s là một rỗng chuỗi \"\" sau removing không-chữ và số các ký tự. Vì một rỗng chuỗi đọc giống nhau forward và backward, nó là một đối xứng."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool isPalindrome(string s) { } };",
      "java": "class Solution { public boolean isPalindrome(String s) { } }",
      "javascript": "/** * @param {string} s * @return {boolean} */ var isPalindrome = function(s) { };",
      "python": "class Solution(object): def isPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:36 PM UTC+7",
    "editorial": {
      "content": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:40:36 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: bool isPalindrome(string s) { } };",
            "java": "class Solution { public boolean isPalindrome(String s) { } }",
            "javascript": "/** * @param {string} s * @return {boolean} */ var isPalindrome = function(s) { };",
            "python": "class Solution(object): def isPalindrome(self, s): \"\"\" :type s: str :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "word-ladder-ii",
    "title": "Word Ladder II",
    "acceptance": 0.2743941225406674,
    "difficulty": "Hard",
    "likes": 6500,
    "dislikes": 828,
    "stars": null,
    "tags": [
      "hash-table",
      "string",
      "backtracking",
      "breadth-first-search"
    ],
    "description": "Một transformation dãy từ word beginWord để word endWord using một từ điển wordList là một dãy của words beginWord -> s1 -> s2 ->... -> sk Sao cho: Mỗi kề nhau cặp của words differs bởi một một chữ cái. Mỗi si cho 1 <= i <= k là trong wordList. Lưu ý rằng beginWord không need để là trong wordList. sk == endWord Cho hai words, beginWord và endWord, và một từ điển wordList, trả về tất cả ngắn nhất transformation dãy từ beginWord để endWord, hoặc một rỗng danh sách nếu không such dãy tồn tại. Each dãy nên là trả về như một danh sách của words [beginWord, s1, s2,..., sk].",
    "constraints": [
      "1 <= beginWord.length <= 5 endWord.length == beginWord.length",
      "1 <= wordList.length <= 500 wordList[i].độ dài == beginWord.length beginWord, endWord, và wordList[i] consist của chữ thường Tiếng Anh các chữ cái. beginWord!= endWord Tất cả words trong wordList là không trùng lặp. tổng của tất cả ngắn nhất transformation dãy không exceed 105."
    ],
    "examples": [
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
        "output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
        "explanation": "Có 2 ngắn nhất transformation dãy: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\" \"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\""
      },
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
        "output": "[]",
        "explanation": "endWord \"cog\" là không trong wordList, do đó Có không hợp lệ transformation dãy."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) { } };",
      "java": "class Solution { public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) { } }",
      "javascript": "/** * @param {string} beginWord * @param {string} endWord * @param {string[]} wordList * @return {string[][]} */ var findLadders = function(beginWord, endWord, wordList) { };",
      "python": "class Solution(object): def findLadders(self, beginWord, endWord, wordList): \"\"\" :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: List[List[str]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:36 PM UTC+7",
    "editorial": {
      "content": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that: Every adjacent pair of words differs by a single letter. Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:40:36 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) { } };",
            "java": "class Solution { public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) { } }",
            "javascript": "/** * @param {string} beginWord * @param {string} endWord * @param {string[]} wordList * @return {string[][]} */ var findLadders = function(beginWord, endWord, wordList) { };",
            "python": "class Solution(object): def findLadders(self, beginWord, endWord, wordList): \"\"\" :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: List[List[str]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "word-ladder",
    "title": "Word Ladder",
    "acceptance": 0.445803096816363,
    "difficulty": "Hard",
    "likes": 13327,
    "dislikes": 1957,
    "stars": null,
    "tags": [
      "hash-table",
      "string",
      "breadth-first-search"
    ],
    "description": "Một transformation dãy từ word beginWord để word endWord using một từ điển wordList là một dãy của words beginWord -> s1 -> s2 ->... -> sk Sao cho: Mỗi kề nhau cặp của words differs bởi một một chữ cái. Mỗi si cho 1 <= i <= k là trong wordList. Lưu ý rằng beginWord không need để là trong wordList. sk == endWord Cho hai words, beginWord và endWord, và một từ điển wordList, trả về số của words trong ngắn nhất transformation dãy từ beginWord để endWord, hoặc 0 nếu không such dãy tồn tại.",
    "constraints": [
      "1 <= beginWord.length <= 10 endWord.length == beginWord.length",
      "1 <= wordList.length <= 5000 wordList[i].độ dài == beginWord.length beginWord, endWord, và wordList[i] consist của chữ thường Tiếng Anh các chữ cái. beginWord!= endWord Tất cả words trong wordList là không trùng lặp."
    ],
    "examples": [
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
        "output": "5",
        "explanation": "Một ngắn nhất transformation dãy là \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", nào là 5 words long."
      },
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
        "output": "0",
        "explanation": "endWord \"cog\" là không trong wordList, do đó Có không hợp lệ transformation dãy."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int ladderLength(string beginWord, string endWord, vector<string>& wordList) { } };",
      "java": "class Solution { public int ladderLength(String beginWord, String endWord, List<String> wordList) { } }",
      "javascript": "/** * @param {string} beginWord * @param {string} endWord * @param {string[]} wordList * @return {number} */ var ladderLength = function(beginWord, endWord, wordList) { };",
      "python": "class Solution(object): def ladderLength(self, beginWord, endWord, wordList): \"\"\" :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:37 PM UTC+7",
    "editorial": {
      "content": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that: Every adjacent pair of words differs by a single letter. Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:40:37 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: int ladderLength(string beginWord, string endWord, vector<string>& wordList) { } };",
            "java": "class Solution { public int ladderLength(String beginWord, String endWord, List<String> wordList) { } }",
            "javascript": "/** * @param {string} beginWord * @param {string} endWord * @param {string[]} wordList * @return {number} */ var ladderLength = function(beginWord, endWord, wordList) { };",
            "python": "class Solution(object): def ladderLength(self, beginWord, endWord, wordList): \"\"\" :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "longest-consecutive-sequence",
    "title": "Longest Consecutive Sequence",
    "acceptance": 0.46969666977704555,
    "difficulty": "Medium",
    "likes": 22501,
    "dislikes": 1219,
    "stars": null,
    "tags": [
      "array",
      "hash-table",
      "union-find"
    ],
    "description": "Cho một unsorted mảng của các số nguyên nums, trả về độ dài của dài nhất consecutive các phần tử dãy. Bạn phải viết một thuật toán đó runs trong O(n) thời gian.",
    "constraints": [
      "0 <= nums.length <= 105",
      "-109 <= nums[i] <= 109"
    ],
    "examples": [
      {
        "input": "nums = [100,4,200,1,3,2]",
        "output": "4",
        "explanation": "dài nhất consecutive các phần tử dãy là [1, 2, 3, 4]. Do đó nó độ dài là 4."
      },
      {
        "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
        "output": "9",
        "explanation": ""
      },
      {
        "input": "nums = [1,0,1,2]",
        "output": "3",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int longestConsecutive(vector<int>& nums) { } };",
      "java": "class Solution { public int longestConsecutive(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var longestConsecutive = function(nums) { };",
      "python": "class Solution(object): def longestConsecutive(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:38 PM UTC+7",
    "editorial": {
      "content": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Dùng Disjoint Set Union để gộp/tìm thành phần liên thông nhanh.",
      "lastUpdated": "January 13, 2026 at 3:40:38 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: int longestConsecutive(vector<int>& nums) { } };",
            "java": "class Solution { public int longestConsecutive(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var longestConsecutive = function(nums) { };",
            "python": "class Solution(object): def longestConsecutive(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "sum-root-to-leaf-numbers",
    "title": "Sum Root to Leaf Numbers",
    "acceptance": 0.6940034387376234,
    "difficulty": "Medium",
    "likes": 8577,
    "dislikes": 156,
    "stars": null,
    "tags": [
      "tree",
      "depth-first-search",
      "binary-tree"
    ],
    "description": "Bạn được cho root của một cây nhị phân chứa các chữ số từ 0 để 9 chỉ. Each root-để-leaf đường đi trong cây biểu diễn một số. Ví dụ, root-để-leaf đường đi 1 -> 2 -> 3 biểu diễn số 123. Trả về total tổng của tất cả root-để-leaf các số. Test trường hợp là generated vì vậy đó đáp án sẽ fit trong một 32-bit số nguyên. Một leaf nút là một nút với không children.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [1, 1000].",
      "0 <= Node.val <= 9 độ sâu của cây sẽ không exceed 10."
    ],
    "examples": [
      {
        "input": "root = [1,2,3]",
        "output": "25",
        "explanation": "root-để-leaf đường đi 1->2 biểu diễn số 12. root-để-leaf đường đi 1->3 biểu diễn số 13. Do đó, tổng = 12 + 13 = 25."
      },
      {
        "input": "root = [4,9,0,5,1]",
        "output": "1026",
        "explanation": "root-để-leaf đường đi 4->9->5 biểu diễn số 495. root-để-leaf đường đi 4->9->1 biểu diễn số 491. root-để-leaf đường đi 4->0 biểu diễn số 40. Do đó, tổng = 495 + 491 + 40 = 1026."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int sumNumbers(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int sumNumbers(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var sumNumbers = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def sumNumbers(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:38 PM UTC+7",
    "editorial": {
      "content": "You are given the root of a binary tree containing digits from 0 to 9 only. Each root-to-leaf path in the tree represents a number. For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123. Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer. A leaf node is a node with no children.\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
      "lastUpdated": "January 13, 2026 at 3:40:38 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "DFS",
          "description": "Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int sumNumbers(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int sumNumbers(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number} */ var sumNumbers = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def sumNumbers(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "surrounded-regions",
    "title": "Surrounded Regions",
    "acceptance": 0.44471642976616915,
    "difficulty": "Medium",
    "likes": 9732,
    "dislikes": 2206,
    "stars": null,
    "tags": [
      "array",
      "depth-first-search",
      "breadth-first-search",
      "union-find",
      "matrix"
    ],
    "description": "Bạn được cho một m x n ma trận board chứa các chữ cái 'X' và 'O', capture regions đó là surrounded: Connect: Một cell là connected để kề nhau cells horizontally hoặc thẳng đứng. Region: Để tạo thành một region connect mỗi 'O' cell. Surround: region là surrounded với 'X' cells nếu Bạn có thể connect region với 'X' cells và none của region cells là trên cạnh của board. Để capture một surrounded region, thay thế tất cả 'O's với 'X's trong-place trong original board. Bạn làm không need để trả về anything.",
    "constraints": [
      "m == board.length n == board[i].độ dài",
      "1 <= m, n <= 200 board[i][j] là 'X' hoặc 'O'."
    ],
    "examples": [
      {
        "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
        "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
        "explanation": "Trong bên trên diagram, dưới cùng region là không captured vì nó là trên cạnh của board và không thể là surrounded."
      },
      {
        "input": "board = [[\"X\"]]",
        "output": "[[\"X\"]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: void solve(vector<vector<char>>& board) { } };",
      "java": "class Solution { public void solve(char[][] board) { } }",
      "javascript": "/** * @param {character[][]} board * @return {void} Do not return anything, modify board in-place instead. */ var solve = function(board) { };",
      "python": "class Solution(object): def solve(self, board): \"\"\" :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:39 PM UTC+7",
    "editorial": {
      "content": "You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded: Connect: A cell is connected to adjacent cells horizontally or vertically. Region: To form a region connect every 'O' cell. Surround: The region is surrounded with 'X' cells if you can connect the region with 'X' cells and none of the region cells are on the edge of the board. To capture a surrounded region, replace all 'O's with 'X's in-place within the original board. You do not need to return anything.\n\nGợi ý hướng giải: Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần. Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
      "lastUpdated": "January 13, 2026 at 3:40:39 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "class Solution { public: void solve(vector<vector<char>>& board) { } };",
            "java": "class Solution { public void solve(char[][] board) { } }",
            "javascript": "/** * @param {character[][]} board * @return {void} Do not return anything, modify board in-place instead. */ var solve = function(board) { };",
            "python": "class Solution(object): def solve(self, board): \"\"\" :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "palindrome-partitioning",
    "title": "Palindrome Partitioning",
    "acceptance": 0.7347770666884774,
    "difficulty": "Medium",
    "likes": 14094,
    "dislikes": 567,
    "stars": null,
    "tags": [
      "string",
      "dynamic-programming",
      "backtracking"
    ],
    "description": "Cho một chuỗi s, partition s Sao cho mỗi chuỗi con của partition là một đối xứng. Trả về tất cả có thể đối xứng partitioning của s.",
    "constraints": [
      "1 <= s.length <= 16",
      "s Chỉ chứa chữ thường Tiếng Anh các chữ cái."
    ],
    "examples": [
      {
        "input": "s = \"aab\"",
        "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
        "explanation": ""
      },
      {
        "input": "s = \"a\"",
        "output": "[[\"a\"]]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<vector<string>> partition(string s) { } };",
      "java": "class Solution { public List<List<String>> partition(String s) { } }",
      "javascript": "/** * @param {string} s * @return {string[][]} */ var partition = function(s) { };",
      "python": "class Solution(object): def partition(self, s): \"\"\" :type s: str :rtype: List[List[str]] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:40 PM UTC+7",
    "editorial": {
      "content": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:40 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: vector<vector<string>> partition(string s) { } };",
            "java": "class Solution { public List<List<String>> partition(String s) { } }",
            "javascript": "/** * @param {string} s * @return {string[][]} */ var partition = function(s) { };",
            "python": "class Solution(object): def partition(self, s): \"\"\" :type s: str :rtype: List[List[str]] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "palindrome-partitioning-ii",
    "title": "Palindrome Partitioning II",
    "acceptance": 0.36383205124114903,
    "difficulty": "Hard",
    "likes": 5876,
    "dislikes": 156,
    "stars": null,
    "tags": [
      "string",
      "dynamic-programming"
    ],
    "description": "Cho một chuỗi s, partition s Sao cho mỗi chuỗi con của partition là một đối xứng. Trả về nhỏ nhất cuts needed cho một đối xứng partitioning của s.",
    "constraints": [
      "1 <= s.length <= 2000 s Gồm chữ thường Tiếng Anh các chữ cái chỉ."
    ],
    "examples": [
      {
        "input": "s = \"aab\"",
        "output": "1",
        "explanation": "đối xứng partitioning [\"aa\",\"b\"] có thể là produced using 1 cut."
      },
      {
        "input": "s = \"a\"",
        "output": "0",
        "explanation": ""
      },
      {
        "input": "s = \"ab\"",
        "output": "1",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int minCut(string s) { } };",
      "java": "class Solution { public int minCut(String s) { } }",
      "javascript": "/** * @param {string} s * @return {number} */ var minCut = function(s) { };",
      "python": "class Solution(object): def minCut(self, s): \"\"\" :type s: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:40 PM UTC+7",
    "editorial": {
      "content": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:40 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int minCut(string s) { } };",
            "java": "class Solution { public int minCut(String s) { } }",
            "javascript": "/** * @param {string} s * @return {number} */ var minCut = function(s) { };",
            "python": "class Solution(object): def minCut(self, s): \"\"\" :type s: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "clone-graph",
    "title": "Clone Graph",
    "acceptance": 0.6433848165196016,
    "difficulty": "Medium",
    "likes": 10468,
    "dislikes": 4161,
    "stars": null,
    "tags": [
      "hash-table",
      "depth-first-search",
      "breadth-first-search",
      "graph"
    ],
    "description": "Cho một reference của một node trong một connected undirected đồ thị. Trả về một deep copy (clone) của đồ thị. Each node trong đồ thị chứa một giá trị (int) và một danh sách (Danh sách[Nút]) của nó neighbors. lớp Nút { public int val; public List<Node> neighbors; } Test trường hợp format: Cho simplicity, each node's giá trị là giống nhau như node's chỉ số (1-chỉ số). Ví dụ, đầu tiên node với val == 1, thứ hai node với val == 2, và vì vậy trên. đồ thị là được biểu diễn trong test trường hợp using một adjacency danh sách. Một adjacency danh sách là một collection của unordered các danh sách được dùng để biểu diễn một finite đồ thị. Each danh sách describes tập hợp của neighbors của một node trong đồ thị. cho node sẽ always là đầu tiên node với val = 1. Bạn phải trả về copy của cho node như một reference để cloned đồ thị.",
    "constraints": [
      "số của các nút trong đồ thị là Trong khoảng [0, 100].",
      "1 <= Node.val <= 100 Node.val là không trùng lặp cho each node. Có không repeated các cạnh và không self-loops trong đồ thị. Đồ thị là connected và tất cả các nút có thể là visited bắt đầu từ cho node."
    ],
    "examples": [
      {
        "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
        "output": "[[2,4],[1,3],[2,4],[1,3]]",
        "explanation": "Có 4 các nút trong đồ thị. 1st node (val = 1)'s neighbors là 2nd node (val = 2) và 4th node (val = 4). 2nd node (val = 2)'s neighbors là 1st node (val = 1) và 3rd node (val = 3). 3rd node (val = 3)'s neighbors là 2nd node (val = 2) và 4th node (val = 4). 4th node (val = 4)'s neighbors là 1st node (val = 1) và 3rd node (val = 3)."
      },
      {
        "input": "adjList = [[]]",
        "output": "[[]]",
        "explanation": ""
      },
      {
        "input": "adjList = []",
        "output": "[]",
        "explanation": "Điều này một rỗng đồ thị, nó không có bất kỳ các nút."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/* // Definition for a Node. class Node { public: int val; vector<Node*> neighbors; Node() { val = 0; neighbors = vector<Node*>(); } Node(int _val) { val = _val; neighbors = vector<Node*>(); } Node(int _val, vector<Node*> _neighbors) { val = _val; neighbors = _neighbors; } }; */ class Solution { public: Node* cloneGraph(Node* node) { } };",
      "java": "/* // Definition for a Node. class Node { public int val; public List<Node> neighbors; public Node() { val = 0; neighbors = new ArrayList<Node>(); } public Node(int _val) { val = _val; neighbors = new ArrayList<Node>(); } public Node(int _val, ArrayList<Node> _neighbors) { val = _val; neighbors = _neighbors; } } */ class Solution { public Node cloneGraph(Node node) { } }",
      "javascript": "/** * // Definition for a _Node. * function _Node(val, neighbors) { * this.val = val === undefined ? 0 : val; * this.neighbors = neighbors === undefined ? [] : neighbors; * }; */ /** * @param {_Node} node * @return {_Node} */ var cloneGraph = function(node) { };",
      "python": "\"\"\" # Definition for a Node. class Node(object): def __init__(self, val = 0, neighbors = None): self.val = val self.neighbors = neighbors if neighbors is not None else [] \"\"\" class Solution(object): def cloneGraph(self, node): \"\"\" :type node: Node :rtype: Node \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:41 PM UTC+7",
    "editorial": {
      "content": "Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. class Node { public int val; public List<Node> neighbors; } Test case format: For simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list. An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
      "lastUpdated": "January 13, 2026 at 3:40:41 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/* // Definition for a Node. class Node { public: int val; vector<Node*> neighbors; Node() { val = 0; neighbors = vector<Node*>(); } Node(int _val) { val = _val; neighbors = vector<Node*>(); } Node(int _val, vector<Node*> _neighbors) { val = _val; neighbors = _neighbors; } }; */ class Solution { public: Node* cloneGraph(Node* node) { } };",
            "java": "/* // Definition for a Node. class Node { public int val; public List<Node> neighbors; public Node() { val = 0; neighbors = new ArrayList<Node>(); } public Node(int _val) { val = _val; neighbors = new ArrayList<Node>(); } public Node(int _val, ArrayList<Node> _neighbors) { val = _val; neighbors = _neighbors; } } */ class Solution { public Node cloneGraph(Node node) { } }",
            "javascript": "/** * // Definition for a _Node. * function _Node(val, neighbors) { * this.val = val === undefined ? 0 : val; * this.neighbors = neighbors === undefined ? [] : neighbors; * }; */ /** * @param {_Node} node * @return {_Node} */ var cloneGraph = function(node) { };",
            "python": "\"\"\" # Definition for a Node. class Node(object): def __init__(self, val = 0, neighbors = None): self.val = val self.neighbors = neighbors if neighbors is not None else [] \"\"\" class Solution(object): def cloneGraph(self, node): \"\"\" :type node: Node :rtype: Node \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "gas-station",
    "title": "Gas Station",
    "acceptance": 0.4731900574665607,
    "difficulty": "Medium",
    "likes": 13306,
    "dislikes": 1363,
    "stars": null,
    "tags": [
      "array",
      "greedy"
    ],
    "description": "Có n gas stations along một circular route, ở đâu lượng của gas tại ith station là gas[i]. Bạn có một car với một unlimited gas tank và nó costs cost[i] của gas để di chuyển từ ith station để nó next (i + 1)th station. Bạn bắt đầu journey với một rỗng tank tại một của gas stations. Cho hai số nguyên các mảng gas và cost, trả về bắt đầu gas station's chỉ số nếu Bạn có thể di chuyển around circuit một lần trong clockwise direction, otherwise trả về -1. Nếu có tồn tại một lời giải, Đảm bảo để là không trùng lặp.",
    "constraints": [
      "n == gas.length == cost.length",
      "1 <= n <= 105",
      "0 <= gas[i], cost[i] <= 104 đầu vào là generated Sao cho Đáp án là không trùng lặp."
    ],
    "examples": [
      {
        "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
        "output": "3",
        "explanation": "Bắt đầu tại station 3 (chỉ số 3) và fill ra với 4 unit của gas. Của bạn tank = 0 + 4 = 4 Di chuyển để station 4. Của bạn tank = 4 - 1 + 5 = 8 Di chuyển để station 0. Của bạn tank = 8 - 2 + 1 = 7 Di chuyển để station 1. Của bạn tank = 7 - 3 + 2 = 6 Di chuyển để station 2. Của bạn tank = 6 - 4 + 3 = 5 Di chuyển để station 3. cost là 5. Của bạn gas là chỉ enough để di chuyển back để station 3. Do đó, trả về 3 như bắt đầu chỉ số."
      },
      {
        "input": "gas = [2,3,4], cost = [3,4,3]",
        "output": "-1",
        "explanation": "Bạn có thể't bắt đầu tại station 0 hoặc 1, như Có không enough gas để di chuyển để next station. Let's bắt đầu tại station 2 và fill ra với 4 unit của gas. Của bạn tank = 0 + 4 = 4 Di chuyển để station 0. Của bạn tank = 4 - 3 + 2 = 3 Di chuyển để station 1. Của bạn tank = 3 - 3 + 3 = 3 Bạn không thể di chuyển back để station 2, như nó requires 4 unit của gas but bạn chỉ có 3. Do đó, Bạn có thể't di chuyển around circuit một lần không matter ở đâu bạn bắt đầu."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int canCompleteCircuit(vector<int>& gas, vector<int>& cost) { } };",
      "java": "class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { } }",
      "javascript": "/** * @param {number[]} gas * @param {number[]} cost * @return {number} */ var canCompleteCircuit = function(gas, cost) { };",
      "python": "class Solution(object): def canCompleteCircuit(self, gas, cost): \"\"\" :type gas: List[int] :type cost: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:42 PM UTC+7",
    "editorial": {
      "content": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.\n\nGợi ý hướng giải: Chọn quyết định cục bộ tối ưu và chứng minh rằng nó dẫn tới tối ưu toàn cục.",
      "lastUpdated": "January 13, 2026 at 3:40:42 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Greedy",
          "description": "Chọn quyết định cục bộ tối ưu và chứng minh rằng nó dẫn tới tối ưu toàn cục.",
          "timeComplexity": "$O(n)$ hoặc $O(n\\log n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int canCompleteCircuit(vector<int>& gas, vector<int>& cost) { } };",
            "java": "class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { } }",
            "javascript": "/** * @param {number[]} gas * @param {number[]} cost * @return {number} */ var canCompleteCircuit = function(gas, cost) { };",
            "python": "class Solution(object): def canCompleteCircuit(self, gas, cost): \"\"\" :type gas: List[int] :type cost: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "candy",
    "title": "Candy",
    "acceptance": 0.4772637429246595,
    "difficulty": "Hard",
    "likes": 9195,
    "dislikes": 840,
    "stars": null,
    "tags": [
      "array",
      "greedy"
    ],
    "description": "Có n children standing trong một đường thẳng. Each child là assigned một rating giá trị cho trong số nguyên mảng ratings. Bạn là giving candies để những children subjected để sau đây requirements: Each child phải có Ít nhất một candy. Children với một higher rating get nhiều hơn candies hơn their neighbors. Trả về nhỏ nhất số của candies bạn need để có để distribute candies để children.",
    "constraints": [
      "n == ratings.length",
      "1 <= n <= 2 * 104",
      "0 <= ratings[i] <= 2 * 104"
    ],
    "examples": [
      {
        "input": "ratings = [1,0,2]",
        "output": "5",
        "explanation": "Bạn có thể allocate để đầu tiên, thứ hai và thứ ba child với 2, 1, 2 candies tương ứng."
      },
      {
        "input": "ratings = [1,2,2]",
        "output": "4",
        "explanation": "Bạn có thể allocate để đầu tiên, thứ hai và thứ ba child với 1, 2, 1 candies tương ứng. thứ ba child gets 1 candy vì nó satisfies bên trên hai conditions."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int candy(vector<int>& ratings) { } };",
      "java": "class Solution { public int candy(int[] ratings) { } }",
      "javascript": "/** * @param {number[]} ratings * @return {number} */ var candy = function(ratings) { };",
      "python": "class Solution(object): def candy(self, ratings): \"\"\" :type ratings: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:43 PM UTC+7",
    "editorial": {
      "content": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children.\n\nGợi ý hướng giải: Chọn quyết định cục bộ tối ưu và chứng minh rằng nó dẫn tới tối ưu toàn cục.",
      "lastUpdated": "January 13, 2026 at 3:40:43 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Greedy",
          "description": "Chọn quyết định cục bộ tối ưu và chứng minh rằng nó dẫn tới tối ưu toàn cục.",
          "timeComplexity": "$O(n)$ hoặc $O(n\\log n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int candy(vector<int>& ratings) { } };",
            "java": "class Solution { public int candy(int[] ratings) { } }",
            "javascript": "/** * @param {number[]} ratings * @return {number} */ var candy = function(ratings) { };",
            "python": "class Solution(object): def candy(self, ratings): \"\"\" :type ratings: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "single-number",
    "title": "Single Number",
    "acceptance": 0.7710032074972338,
    "difficulty": "Easy",
    "likes": 18480,
    "dislikes": 879,
    "stars": null,
    "tags": [
      "array",
      "bit-manipulation"
    ],
    "description": "Cho một không rỗng mảng của các số nguyên nums, mỗi phần tử appears hai lần ngoại trừ cho một. Tìm đó một một. Bạn phải cài đặt một lời giải với một linear runtime độ phức tạp và dùng chỉ constant extra bộ nhớ.",
    "constraints": [
      "1 <= nums.length <= 3 * 104 -3 *",
      "104 <= nums[i] <= 3 * 104 Each phần tử trong mảng appears hai lần ngoại trừ cho một phần tử nào appears chỉ một lần."
    ],
    "examples": [
      {
        "input": "nums = [2,2,1]",
        "output": "1",
        "explanation": ""
      },
      {
        "input": "nums = [4,1,2,1,2]",
        "output": "4",
        "explanation": ""
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": ""
      }
    ],
    "content": "Think about XOR (^) operator's property.",
    "defaultCode": {
      "cpp": "class Solution { public: int singleNumber(vector<int>& nums) { } };",
      "java": "class Solution { public int singleNumber(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var singleNumber = function(nums) { };",
      "python": "class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:44 PM UTC+7",
    "editorial": {
      "content": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.\n\nHint/nhắc ý (crawl được): Think about the XOR (^) operator's property.\n\nGợi ý hướng giải: Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
      "lastUpdated": "January 13, 2026 at 3:40:44 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Bit Manipulation",
          "description": "Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int singleNumber(vector<int>& nums) { } };",
            "java": "class Solution { public int singleNumber(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var singleNumber = function(nums) { };",
            "python": "class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "single-number-ii",
    "title": "Single Number II",
    "acceptance": 0.6645136096590718,
    "difficulty": "Medium",
    "likes": 8562,
    "dislikes": 746,
    "stars": null,
    "tags": [
      "array",
      "bit-manipulation"
    ],
    "description": "Cho một số nguyên mảng nums ở đâu mỗi phần tử appears ba lần ngoại trừ cho một, nào appears chính xác một lần. Tìm một phần tử và trả về nó. Bạn phải cài đặt một lời giải với một linear runtime độ phức tạp và dùng chỉ constant extra bộ nhớ.",
    "constraints": [
      "1 <= nums.length <= 3 * 104",
      "-231 <= nums[i] <= 231 - 1 Each phần tử trong nums appears chính xác ba lần ngoại trừ cho một phần tử nào appears một lần."
    ],
    "examples": [
      {
        "input": "nums = [2,2,3,2]",
        "output": "3",
        "explanation": ""
      },
      {
        "input": "nums = [0,1,0,1,0,1,99]",
        "output": "99",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int singleNumber(vector<int>& nums) { } };",
      "java": "class Solution { public int singleNumber(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var singleNumber = function(nums) { };",
      "python": "class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:44 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space.\n\nGợi ý hướng giải: Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
      "lastUpdated": "January 13, 2026 at 3:40:44 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Bit Manipulation",
          "description": "Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int singleNumber(vector<int>& nums) { } };",
            "java": "class Solution { public int singleNumber(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var singleNumber = function(nums) { };",
            "python": "class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "copy-list-with-random-pointer",
    "title": "Copy List with Random Pointer",
    "acceptance": 0.6211345980324517,
    "difficulty": "Medium",
    "likes": 15320,
    "dislikes": 1663,
    "stars": null,
    "tags": [
      "hash-table",
      "linked-list"
    ],
    "description": "Một danh sách liên kết của độ dài n là cho Sao cho each nút chứa một additional random con trỏ, nào có thể point để bất kỳ nút trong danh sách, hoặc null. Construct một deep copy của danh sách. deep copy nên consist của chính xác n brand new các nút, ở đâu each new nút có nó giá trị tập hợp để giá trị của nó corresponding original nút. Both next và random con trỏ của new các nút nên point để new các nút trong copied danh sách Sao cho các con trỏ trong original danh sách và copied danh sách biểu diễn giống nhau danh sách state. None của các con trỏ trong new danh sách nên point để các nút trong original danh sách. Ví dụ, nếu Có hai các nút X và Y trong original danh sách, ở đâu X.random --> Y, thì cho corresponding hai các nút x và y trong copied danh sách, x.random --> y. Trả về head của copied danh sách liên kết. danh sách liên kết là được biểu diễn trong đầu vào/đầu ra như một danh sách của n các nút. Each nút là được biểu diễn như một cặp của [val, random_index] ở đâu: val: một số nguyên biểu diễn Node.val random_index: chỉ số của nút (khoảng từ 0 để n-1) đó random con trỏ points để, hoặc null nếu nó không point để bất kỳ nút. Của bạn code sẽ chỉ là cho head của original danh sách liên kết.",
    "constraints": [
      "0 <= n <= 1000",
      "-104 <= Node.val <= 104 Node.random là null hoặc là pointing để một số nút trong danh sách liên kết."
    ],
    "examples": [
      {
        "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "explanation": ""
      },
      {
        "input": "head = [[1,1],[2,1]]",
        "output": "[[1,1],[2,1]]",
        "explanation": ""
      },
      {
        "input": "head = [[3,null],[3,0],[3,null]]",
        "output": "[[3,null],[3,0],[3,null]]",
        "explanation": ""
      }
    ],
    "content": "Chỉ iterate danh sách liên kết và tạo copies của các nút trên go. Vì một nút có thể là referenced từ nhiều các nút due để random các con trỏ, ensure bạn là không making nhiều copies của giống nhau nút. Bạn có thể want để dùng extra bộ nhớ để giữ old_node ---> new_node bản đồ để prevent creating nhiều copies của giống nhau nút. Chúng ta có thể avoid using extra bộ nhớ cho old_node ---> new_node bản đồ bởi tweaking original danh sách liên kết. Simply interweave các nút của old và copied danh sách. Ví dụ: Old Danh sách: Một --> B --> C --> D InterWeaved Danh sách: Một --> Một' --> B --> B' --> C --> C' --> D --> D' interweaving là done using next</b> các con trỏ và chúng ta có thể tạo dùng của interweaved cấu trúc để get correct reference các nút cho random</b> các con trỏ.",
    "defaultCode": {
      "cpp": "/* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public: Node* copyRandomList(Node* head) { } };",
      "java": "/* // Definition for a Node. class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } */ class Solution { public Node copyRandomList(Node head) { } }",
      "javascript": "/** * // Definition for a _Node. * function _Node(val, next, random) { * this.val = val; * this.next = next; * this.random = random; * }; */ /** * @param {_Node} head * @return {_Node} */ var copyRandomList = function(head) { };",
      "python": "\"\"\" # Definition for a Node. class Node: def __init__(self, x, next=None, random=None): self.val = int(x) self.next = next self.random = random \"\"\" class Solution(object): def copyRandomList(self, head): \"\"\" :type head: Node :rtype: Node \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:45 PM UTC+7",
    "editorial": {
      "content": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. Your code will only be given the head of the original linked list.\n\nHint/nhắc ý (crawl được): Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node. You may want to use extra space to keep old_node ---> new_node mapping to prevent creating multiple copies of the same node. We can avoid using extra space for old_node ---> new_node mapping by tweaking the original linked list. Simply interweave the nodes of the old and copied list. For example: Old List: A --> B --> C --> D InterWeaved List: A --> A' --> B --> B' --> C --> C' --> D --> D' The interweaving is done using next</b> pointers and we can make use of interweaved structure to get the correct reference nodes for random</b> pointers.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
      "lastUpdated": "January 13, 2026 at 3:40:45 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public: Node* copyRandomList(Node* head) { } };",
            "java": "/* // Definition for a Node. class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } */ class Solution { public Node copyRandomList(Node head) { } }",
            "javascript": "/** * // Definition for a _Node. * function _Node(val, next, random) { * this.val = val; * this.next = next; * this.random = random; * }; */ /** * @param {_Node} head * @return {_Node} */ var copyRandomList = function(head) { };",
            "python": "\"\"\" # Definition for a Node. class Node: def __init__(self, x, next=None, random=None): self.val = int(x) self.next = next self.random = random \"\"\" class Solution(object): def copyRandomList(self, head): \"\"\" :type head: Node :rtype: Node \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "word-break",
    "title": "Word Break",
    "acceptance": 0.4899621726268585,
    "difficulty": "Medium",
    "likes": 18496,
    "dislikes": 889,
    "stars": null,
    "tags": [
      "array",
      "hash-table",
      "string",
      "dynamic-programming",
      "trie",
      "memoization"
    ],
    "description": "Cho một chuỗi s và một từ điển của các chuỗi wordDict, trả về đúng nếu s có thể là segmented thành một bộ nhớ-separated dãy của một hoặc nhiều hơn từ điển words. Lưu ý rằng giống nhau word trong từ điển có thể là reused nhiều lần trong segmentation.",
    "constraints": [
      "1 <= s.length <= 300",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].độ dài <= 20 s và wordDict[i] consist của chỉ chữ thường Tiếng Anh các chữ cái. Tất cả các chuỗi của wordDict là không trùng lặp."
    ],
    "examples": [
      {
        "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
        "output": "true",
        "explanation": "Trả về đúng vì \"leetcode\" có thể là segmented như \"leet code\"."
      },
      {
        "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
        "output": "true",
        "explanation": "Trả về đúng vì \"applepenapple\" có thể là segmented như \"apple pen apple\"."
      },
      {
        "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
        "output": "false",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool wordBreak(string s, vector<string>& wordDict) { } };",
      "java": "class Solution { public boolean wordBreak(String s, List<String> wordDict) { } }",
      "javascript": "/** * @param {string} s * @param {string[]} wordDict * @return {boolean} */ var wordBreak = function(s, wordDict) { };",
      "python": "class Solution(object): def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: List[str] :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:46 PM UTC+7",
    "editorial": {
      "content": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:40:46 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: bool wordBreak(string s, vector<string>& wordDict) { } };",
            "java": "class Solution { public boolean wordBreak(String s, List<String> wordDict) { } }",
            "javascript": "/** * @param {string} s * @param {string[]} wordDict * @return {boolean} */ var wordBreak = function(s, wordDict) { };",
            "python": "class Solution(object): def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: List[str] :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "word-break-ii",
    "title": "Word Break II",
    "acceptance": 0.5486626294952616,
    "difficulty": "Hard",
    "likes": 7516,
    "dislikes": 545,
    "stars": null,
    "tags": [
      "array",
      "hash-table",
      "string",
      "dynamic-programming",
      "backtracking",
      "trie",
      "memoization"
    ],
    "description": "Cho một chuỗi s và một từ điển của các chuỗi wordDict, cộng dấu cách trong s để construct một sentence ở đâu each word là một hợp lệ từ điển word. Trả về tất cả such có thể sentences Theo bất kỳ thứ tự nào. Lưu ý rằng giống nhau word trong từ điển có thể là reused nhiều lần trong segmentation.",
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= wordDict.length <= 1000",
      "1 <= wordDict[i].độ dài <= 10 s và wordDict[i] consist của chỉ chữ thường Tiếng Anh các chữ cái. Tất cả các chuỗi của wordDict là không trùng lặp. Đầu vào là generated trong một way đó độ dài của đáp án doesn't exceed 105."
    ],
    "examples": [
      {
        "input": "s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]",
        "output": "[\"cats and dog\",\"cat sand dog\"]",
        "explanation": ""
      },
      {
        "input": "s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]",
        "output": "[\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]",
        "explanation": ""
      },
      {
        "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<string> wordBreak(string s, vector<string>& wordDict) { } };",
      "java": "class Solution { public List<String> wordBreak(String s, List<String> wordDict) { } }",
      "javascript": "/** * @param {string} s * @param {string[]} wordDict * @return {string[]} */ var wordBreak = function(s, wordDict) { };",
      "python": "class Solution(object): def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: List[str] :rtype: List[str] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:47 PM UTC+7",
    "editorial": {
      "content": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order. Note that the same word in the dictionary may be reused multiple times in the segmentation.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:40:47 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: vector<string> wordBreak(string s, vector<string>& wordDict) { } };",
            "java": "class Solution { public List<String> wordBreak(String s, List<String> wordDict) { } }",
            "javascript": "/** * @param {string} s * @param {string[]} wordDict * @return {string[]} */ var wordBreak = function(s, wordDict) { };",
            "python": "class Solution(object): def wordBreak(self, s, wordDict): \"\"\" :type s: str :type wordDict: List[str] :rtype: List[str] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "linked-list-cycle",
    "title": "Linked List Cycle",
    "acceptance": 0.5365930231630835,
    "difficulty": "Easy",
    "likes": 17237,
    "dislikes": 1564,
    "stars": null,
    "tags": [
      "hash-table",
      "linked-list",
      "two-pointers"
    ],
    "description": "Cho head, head của một danh sách liên kết, xác định nếu danh sách liên kết có một cycle trong nó. Có một cycle trong một danh sách liên kết nếu Có một số nút trong danh sách đó có thể là reached again bởi continuously sau đây next con trỏ. Internally, pos là được dùng để denote chỉ số của nút đó tail's next con trỏ là connected để. Lưu ý rằng pos là không lần duyệt như một parameter. Trả về đúng nếu Có một cycle trong danh sách liên kết. Otherwise, trả về sai.",
    "constraints": [
      "số của các nút trong danh sách là Trong khoảng [0, 104].",
      "-105 <= Node.val <= 105 pos là -1 hoặc một hợp lệ chỉ số trong liên kết-danh sách. Câu hỏi thêm: Bạn có thể solve nó using O(1) (i.e. constant) bộ nhớ?"
    ],
    "examples": [
      {
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "true",
        "explanation": "Có một cycle trong danh sách liên kết, ở đâu tail connects để 1st nút (0-chỉ số)."
      },
      {
        "input": "head = [1,2], pos = 0",
        "output": "true",
        "explanation": "Có một cycle trong danh sách liên kết, ở đâu tail connects để 0th nút."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "Có không cycle trong danh sách liên kết."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { } };",
      "java": "/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {boolean} */ var hasCycle = function(head) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:47 PM UTC+7",
    "editorial": {
      "content": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
      "lastUpdated": "January 13, 2026 at 3:40:47 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { } };",
            "java": "/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {boolean} */ var hasCycle = function(head) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "linked-list-cycle-ii",
    "title": "Linked List Cycle II",
    "acceptance": 0.5684464869417536,
    "difficulty": "Medium",
    "likes": 14943,
    "dislikes": 1076,
    "stars": null,
    "tags": [
      "hash-table",
      "linked-list",
      "two-pointers"
    ],
    "description": "Cho head của một danh sách liên kết, trả về nút ở đâu cycle bắt đầu. Nếu Có không cycle, trả về null. Có một cycle trong một danh sách liên kết nếu Có một số nút trong danh sách đó có thể là reached again bởi continuously sau đây next con trỏ. Internally, pos là được dùng để denote chỉ số của nút đó tail's next con trỏ là connected để (0-chỉ số). Nó là -1 nếu Có không cycle. Lưu ý rằng pos là không lần duyệt như một parameter. Làm không modify danh sách liên kết.",
    "constraints": [
      "số của các nút trong danh sách là Trong khoảng [0, 104].",
      "-105 <= Node.val <= 105 pos là -1 hoặc một hợp lệ chỉ số trong liên kết-danh sách. Câu hỏi thêm: Bạn có thể solve nó using O(1) (i.e. constant) bộ nhớ?"
    ],
    "examples": [
      {
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "tail connects to node index 1",
        "explanation": "Có một cycle trong danh sách liên kết, ở đâu tail connects để thứ hai nút."
      },
      {
        "input": "head = [1,2], pos = 0",
        "output": "tail connects to node index 0",
        "explanation": "Có một cycle trong danh sách liên kết, ở đâu tail connects để đầu tiên nút."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "no cycle",
        "explanation": "Có không cycle trong danh sách liên kết."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { } };",
      "java": "/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var detectCycle = function(head) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def detectCycle(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:48 PM UTC+7",
    "editorial": {
      "content": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
      "lastUpdated": "January 13, 2026 at 3:40:48 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { } };",
            "java": "/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @return {ListNode} */ var detectCycle = function(head) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def detectCycle(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "reorder-list",
    "title": "Reorder List",
    "acceptance": 0.6421572535349069,
    "difficulty": "Medium",
    "likes": 12309,
    "dislikes": 501,
    "stars": null,
    "tags": [
      "linked-list",
      "two-pointers",
      "stack",
      "recursion"
    ],
    "description": "Bạn được cho head của một singly liên kết-danh sách. danh sách có thể là được biểu diễn như: L0 → L1 → … → Ln - 1 → Ln Reorder danh sách để là trên sau đây tạo thành: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … Bạn không được modify các giá trị trong list's các nút. Chỉ các nút themselves có thể là changed.",
    "constraints": [
      "số của các nút trong danh sách là Trong khoảng [1, 5 * 104].",
      "1 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4]",
        "output": "[1,4,2,3]",
        "explanation": ""
      },
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[1,5,2,4,3]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: void reorderList(ListNode* head) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public void reorderList(ListNode head) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {void} Do not return anything, modify head in-place instead. */ var reorderList = function(head) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def reorderList(self, head): \"\"\" :type head: Optional[ListNode] :rtype: None Do not return anything, modify head in-place instead. \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:49 PM UTC+7",
    "editorial": {
      "content": "You are given the head of a singly linked-list. The list can be represented as: L0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
      "lastUpdated": "January 13, 2026 at 3:40:49 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: void reorderList(ListNode* head) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public void reorderList(ListNode head) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {void} Do not return anything, modify head in-place instead. */ var reorderList = function(head) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def reorderList(self, head): \"\"\" :type head: Optional[ListNode] :rtype: None Do not return anything, modify head in-place instead. \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "binary-tree-preorder-traversal",
    "title": "Binary Tree Preorder Traversal",
    "acceptance": 0.748554715177773,
    "difficulty": "Easy",
    "likes": 8749,
    "dislikes": 233,
    "stars": null,
    "tags": [
      "stack",
      "tree",
      "depth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân, trả về preorder duyệt của nó các nút' các giá trị.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 100].",
      "-100 <= Node.val <= 100 Câu hỏi thêm: Recursive lời giải là trivial, Bạn có thể làm nó iteratively?",
      "-100 <= Node.val <= 100 Câu hỏi thêm: Recursive"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,2,3]",
        "explanation": ""
      },
      {
        "input": "root = [1,2,3,4,5,null,8,null,null,6,7,9]",
        "output": "[1,2,4,5,6,7,3,8,9]",
        "explanation": ""
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": ""
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> preorderTraversal(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<Integer> preorderTraversal(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var preorderTraversal = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def preorderTraversal(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:49 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree, return the preorder traversal of its nodes' values.\n\nGợi ý hướng giải: Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng. Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue).",
      "lastUpdated": "January 13, 2026 at 3:40:49 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> preorderTraversal(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<Integer> preorderTraversal(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var preorderTraversal = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def preorderTraversal(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[int] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "binary-tree-postorder-traversal",
    "title": "Binary Tree Postorder Traversal",
    "acceptance": 0.7730817363854247,
    "difficulty": "Easy",
    "likes": 7681,
    "dislikes": 222,
    "stars": null,
    "tags": [
      "stack",
      "tree",
      "depth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân, trả về postorder duyệt của nó các nút' các giá trị.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 100].",
      "-100 <= Node.val <= 100 Câu hỏi thêm: Recursive lời giải là trivial, Bạn có thể làm nó iteratively?",
      "-100 <= Node.val <= 100 Câu hỏi thêm: Recursive"
    ],
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[3,2,1]",
        "explanation": ""
      },
      {
        "input": "root = [1,2,3,4,5,null,8,null,null,6,7,9]",
        "output": "[4,6,7,5,2,9,8,3,1]",
        "explanation": ""
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": ""
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> postorderTraversal(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<Integer> postorderTraversal(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var postorderTraversal = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def postorderTraversal(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:50 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree, return the postorder traversal of its nodes' values.\n\nGợi ý hướng giải: Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng. Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue).",
      "lastUpdated": "January 13, 2026 at 3:40:50 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> postorderTraversal(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<Integer> postorderTraversal(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var postorderTraversal = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def postorderTraversal(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[int] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "lru-cache",
    "title": "LRU Cache",
    "acceptance": 0.4657615461802982,
    "difficulty": "Medium",
    "likes": 22770,
    "dislikes": 1206,
    "stars": null,
    "tags": [
      "hash-table",
      "linked-list",
      "design",
      "doubly-linked-list"
    ],
    "description": "Thiết kế một cấu trúc dữ liệu đó theo constraints của một Ít nhất Recently Được dùng (LRU) cache. Cài đặt LRUCache lớp: LRUCache(int capacity) Khởi tạo LRU cache với dương kích thước capacity. int get(int khóa) Trả về giá trị của khóa nếu khóa tồn tại, otherwise trả về -1. void put(int khóa, int giá trị) Cập nhật giá trị của khóa nếu khóa tồn tại. Otherwise, cộng khóa-giá trị cặp để cache. Nếu số của khóa exceeds capacity từ điều này thao tác, evict ít nhất recently được dùng khóa. hàm get và put phải each run trong O(1) trung bình thời gian độ phức tạp.",
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= khóa <= 104",
      "0 <= giá trị <= 105 Nhiều nhất 2 * 105 calls sẽ là made để get và put."
    ],
    "examples": [],
    "content": "",
    "defaultCode": {
      "cpp": "class LRUCache { public: LRUCache(int capacity) { } int get(int key) { } void put(int key, int value) { } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */",
      "java": "class LRUCache { public LRUCache(int capacity) { } public int get(int key) { } public void put(int key, int value) { } } /** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */",
      "javascript": "/** * @param {number} capacity */ var LRUCache = function(capacity) { }; /** * @param {number} key * @return {number} */ LRUCache.prototype.get = function(key) { }; /** * @param {number} key * @param {number} value * @return {void} */ LRUCache.prototype.put = function(key, value) { }; /** * Your LRUCache object will be instantiated and called as such: * var obj = new LRUCache(capacity) * var param_1 = obj.get(key) * obj.put(key,value) */",
      "python": "class LRUCache(object): def __init__(self, capacity): \"\"\" :type capacity: int \"\"\" def get(self, key): \"\"\" :type key: int :rtype: int \"\"\" def put(self, key, value): \"\"\" :type key: int :type value: int :rtype: None \"\"\" # Your LRUCache object will be instantiated and called as such: # obj = LRUCache(capacity) # param_1 = obj.get(key) # obj.put(key,value)"
    },
    "createdAt": "January 13, 2026 at 3:40:51 PM UTC+7",
    "editorial": {
      "content": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
      "lastUpdated": "January 13, 2026 at 3:40:51 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class LRUCache { public: LRUCache(int capacity) { } int get(int key) { } void put(int key, int value) { } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */",
            "java": "class LRUCache { public LRUCache(int capacity) { } public int get(int key) { } public void put(int key, int value) { } } /** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */",
            "javascript": "/** * @param {number} capacity */ var LRUCache = function(capacity) { }; /** * @param {number} key * @return {number} */ LRUCache.prototype.get = function(key) { }; /** * @param {number} key * @param {number} value * @return {void} */ LRUCache.prototype.put = function(key, value) { }; /** * Your LRUCache object will be instantiated and called as such: * var obj = new LRUCache(capacity) * var param_1 = obj.get(key) * obj.put(key,value) */",
            "python": "class LRUCache(object): def __init__(self, capacity): \"\"\" :type capacity: int \"\"\" def get(self, key): \"\"\" :type key: int :rtype: int \"\"\" def put(self, key, value): \"\"\" :type key: int :type value: int :rtype: None \"\"\" # Your LRUCache object will be instantiated and called as such: # obj = LRUCache(capacity) # param_1 = obj.get(key) # obj.put(key,value)"
          }
        }
      ]
    }
  },
  {
    "id": "insertion-sort-list",
    "title": "Insertion Sort List",
    "acceptance": 0.5810935052834004,
    "difficulty": "Medium",
    "likes": 3366,
    "dislikes": 879,
    "stars": null,
    "tags": [
      "linked-list",
      "sorting"
    ],
    "description": "Cho head của một singly danh sách liên kết, sắp xếp danh sách using insertion sắp xếp, và trả về đã sắp xếp list's head. các bước của insertion sắp xếp thuật toán: Insertion sắp xếp iterates, consuming một đầu vào phần tử each repetition và growing một đã sắp xếp đầu ra danh sách. Tại each iteration, insertion sắp xếp loại bỏ một phần tử từ đầu vào dữ liệu, tìm location nó belongs trong đã sắp xếp danh sách và chèn nó có. Nó repeats cho đến khi không đầu vào các phần tử remain. sau đây là một graphical ví dụ của insertion sắp xếp thuật toán. một phần đã sắp xếp danh sách (black) initially Chỉ chứa đầu tiên phần tử trong danh sách. Một phần tử (red) là removed từ đầu vào dữ liệu và chèn trong-place thành đã sắp xếp danh sách với each iteration.",
    "constraints": [
      "số của các nút trong danh sách là Trong khoảng [1, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "examples": [
      {
        "input": "head = [4,2,1,3]",
        "output": "[1,2,3,4]",
        "explanation": ""
      },
      {
        "input": "head = [-1,5,3,4,0]",
        "output": "[-1,0,3,4,5]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* insertionSortList(ListNode* head) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode insertionSortList(ListNode head) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var insertionSortList = function(head) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def insertionSortList(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:52 PM UTC+7",
    "editorial": {
      "content": "Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head. The steps of the insertion sort algorithm: Insertion sort iterates, consuming one input element each repetition and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there. It repeats until no input elements remain. The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
      "lastUpdated": "January 13, 2026 at 3:40:52 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Sorting",
          "description": "Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
          "timeComplexity": "$O(n\\log n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(n)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* insertionSortList(ListNode* head) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode insertionSortList(ListNode head) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var insertionSortList = function(head) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def insertionSortList(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "sort-list",
    "title": "Sort List",
    "acceptance": 0.6352475174072936,
    "difficulty": "Medium",
    "likes": 12849,
    "dislikes": 412,
    "stars": null,
    "tags": [
      "linked-list",
      "two-pointers",
      "divide-and-conquer",
      "sorting",
      "merge-sort"
    ],
    "description": "Cho head của một danh sách liên kết, trả về danh sách sau sắp xếp nó trong thứ tự tăng dần.",
    "constraints": [
      "số của các nút trong danh sách là Trong khoảng [0, 5 * 104].",
      "-105 <= Node.val <= 105 Câu hỏi thêm: Bạn có thể sắp xếp danh sách liên kết trong O(n logn) thời gian và O(1) bộ nhớ (i.e. constant bộ nhớ)?"
    ],
    "examples": [
      {
        "input": "head = [4,2,1,3]",
        "output": "[1,2,3,4]",
        "explanation": ""
      },
      {
        "input": "head = [-1,5,3,4,0]",
        "output": "[-1,0,3,4,5]",
        "explanation": ""
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* sortList(ListNode* head) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode sortList(ListNode head) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var sortList = function(head) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def sortList(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:52 PM UTC+7",
    "editorial": {
      "content": "Given the head of a linked list, return the list after sorting it in ascending order.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
      "lastUpdated": "January 13, 2026 at 3:40:52 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* sortList(ListNode* head) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode sortList(ListNode head) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var sortList = function(head) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def sortList(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "max-points-on-a-line",
    "title": "Max Points on a Line",
    "acceptance": 0.3004742720786447,
    "difficulty": "Hard",
    "likes": 4473,
    "dislikes": 579,
    "stars": null,
    "tags": [
      "array",
      "hash-table",
      "math",
      "geometry"
    ],
    "description": "Cho một mảng của points ở đâu points[i] = [xi, yi] biểu diễn một point trên X-Y plane, trả về lớn nhất số của points đó lie trên giống nhau straight đường thẳng.",
    "constraints": [
      "1 <= points.length <= 300 points[i].độ dài == 2",
      "-104 <= xi, yi <= 104 Tất cả points là không trùng lặp."
    ],
    "examples": [
      {
        "input": "points = [[1,1],[2,2],[3,3]]",
        "output": "3",
        "explanation": ""
      },
      {
        "input": "points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]",
        "output": "4",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int maxPoints(vector<vector<int>>& points) { } };",
      "java": "class Solution { public int maxPoints(int[][] points) { } }",
      "javascript": "/** * @param {number[][]} points * @return {number} */ var maxPoints = function(points) { };",
      "python": "class Solution(object): def maxPoints(self, points): \"\"\" :type points: List[List[int]] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:53 PM UTC+7",
    "editorial": {
      "content": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
      "lastUpdated": "January 13, 2026 at 3:40:53 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: int maxPoints(vector<vector<int>>& points) { } };",
            "java": "class Solution { public int maxPoints(int[][] points) { } }",
            "javascript": "/** * @param {number[][]} points * @return {number} */ var maxPoints = function(points) { };",
            "python": "class Solution(object): def maxPoints(self, points): \"\"\" :type points: List[List[int]] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "evaluate-reverse-polish-notation",
    "title": "Evaluate Reverse Polish Notation",
    "acceptance": 0.5663734433318097,
    "difficulty": "Medium",
    "likes": 8534,
    "dislikes": 1175,
    "stars": null,
    "tags": [
      "array",
      "math",
      "stack"
    ],
    "description": "Bạn được cho một mảng của các chuỗi tokens đó biểu diễn một arithmetic biểu thức trong một Đảo ngược Polish Notation. Evaluate biểu thức. Trả về một số nguyên đó biểu diễn giá trị của biểu thức. Lưu ý rằng: hợp lệ operators là '+', '-', '*', và '/'. Each operand có thể là một số nguyên hoặc another biểu thức. division giữa hai các số nguyên always truncates toward 0. Có sẽ không là bất kỳ division bởi 0. đầu vào biểu diễn một hợp lệ arithmetic biểu thức trong một đảo ngược polish notation. đáp án và tất cả intermediate calculations có thể là được biểu diễn trong một 32-bit số nguyên.",
    "constraints": [
      "1 <= tokens.length <= 104 tokens[i] là một trong hai một operator: \"+\", \"-\", \"*\", hoặc \"/\", hoặc một số nguyên Trong khoảng [-200, 200]."
    ],
    "examples": [
      {
        "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
        "output": "9",
        "explanation": "((2 + 1) * 3) = 9"
      },
      {
        "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
        "output": "6",
        "explanation": "(4 + (13 / 5)) = 6"
      },
      {
        "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
        "output": "22",
        "explanation": "((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22"
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int evalRPN(vector<string>& tokens) { } };",
      "java": "class Solution { public int evalRPN(String[] tokens) { } }",
      "javascript": "/** * @param {string[]} tokens * @return {number} */ var evalRPN = function(tokens) { };",
      "python": "class Solution(object): def evalRPN(self, tokens): \"\"\" :type tokens: List[str] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:54 PM UTC+7",
    "editorial": {
      "content": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation. Evaluate the expression. Return an integer that represents the value of the expression. Note that: The valid operators are '+', '-', '*', and '/'. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
      "lastUpdated": "January 13, 2026 at 3:40:54 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: int evalRPN(vector<string>& tokens) { } };",
            "java": "class Solution { public int evalRPN(String[] tokens) { } }",
            "javascript": "/** * @param {string[]} tokens * @return {number} */ var evalRPN = function(tokens) { };",
            "python": "class Solution(object): def evalRPN(self, tokens): \"\"\" :type tokens: List[str] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "reverse-words-in-a-string",
    "title": "Reverse Words in a String",
    "acceptance": 0.5495449456000913,
    "difficulty": "Medium",
    "likes": 10234,
    "dislikes": 5520,
    "stars": null,
    "tags": [
      "two-pointers",
      "string"
    ],
    "description": "Cho một đầu vào chuỗi s, đảo ngược thứ tự của words. Một word là defined như một dãy của không-bộ nhớ các ký tự. words trong s sẽ là separated bởi Ít nhất một bộ nhớ. Trả về một chuỗi của words trong đảo ngược thứ tự concatenated bởi một một bộ nhớ. Lưu ý rằng s có thể chứa ở đầu hoặc ở cuối dấu cách hoặc nhiều dấu cách giữa hai words. trả về chuỗi nên chỉ có một một bộ nhớ separating words. Làm không include bất kỳ extra dấu cách.",
    "constraints": [
      "1 <= s.length <= 104",
      "s chứa Tiếng Anh các chữ cái (chữ hoa và chữ thường), các chữ số, và dấu cách ' '. Có Ít nhất một word trong s. Câu hỏi thêm: Nếu chuỗi dữ liệu type là mutable trong của bạn language, Bạn có thể solve nó trong-place với O(1) extra bộ nhớ?"
    ],
    "examples": [
      {
        "input": "s = \"the sky is blue\"",
        "output": "\"blue is sky the\"",
        "explanation": ""
      },
      {
        "input": "s = \" hello world \"",
        "output": "\"world hello\"",
        "explanation": "Của bạn được đảo ngược chuỗi nên không chứa ở đầu hoặc ở cuối dấu cách."
      },
      {
        "input": "s = \"a good example\"",
        "output": "\"example good a\"",
        "explanation": "Bạn need để reduce nhiều dấu cách giữa hai words để một một bộ nhớ trong được đảo ngược chuỗi."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: string reverseWords(string s) { } };",
      "java": "class Solution { public String reverseWords(String s) { } }",
      "javascript": "/** * @param {string} s * @return {string} */ var reverseWords = function(s) { };",
      "python": "class Solution(object): def reverseWords(self, s): \"\"\" :type s: str :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:55 PM UTC+7",
    "editorial": {
      "content": "Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:40:55 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: string reverseWords(string s) { } };",
            "java": "class Solution { public String reverseWords(String s) { } }",
            "javascript": "/** * @param {string} s * @return {string} */ var reverseWords = function(s) { };",
            "python": "class Solution(object): def reverseWords(self, s): \"\"\" :type s: str :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "maximum-product-subarray",
    "title": "Maximum Product Subarray",
    "acceptance": 0.35804363447487814,
    "difficulty": "Medium",
    "likes": 20137,
    "dislikes": 814,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming"
    ],
    "description": "Cho một số nguyên mảng nums, tìm một mảng con đó có lớn nhất product, và trả về product. test trường hợp là generated vì vậy đó đáp án sẽ fit trong một 32-bit số nguyên. Lưu ý rằng product của một mảng với một một phần tử là giá trị của đó phần tử.",
    "constraints": [
      "1 <= nums.length <= 2 * 104",
      "-10 <= nums[i] <= 10 product của bất kỳ mảng con của nums là được đảm bảo để fit trong một 32-bit số nguyên."
    ],
    "examples": [
      {
        "input": "nums = [2,3,-2,4]",
        "output": "6",
        "explanation": "[2,3] có lớn nhất product 6."
      },
      {
        "input": "nums = [-2,0,-1]",
        "output": "0",
        "explanation": "kết quả không thể là 2, vì [-2,-1] là không một mảng con."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int maxProduct(vector<int>& nums) { } };",
      "java": "class Solution { public int maxProduct(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var maxProduct = function(nums) { };",
      "python": "class Solution(object): def maxProduct(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:56 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums, find a subarray that has the largest product, and return the product. The test cases are generated so that the answer will fit in a 32-bit integer. Note that the product of an array with a single element is the value of that element.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:40:56 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int maxProduct(vector<int>& nums) { } };",
            "java": "class Solution { public int maxProduct(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var maxProduct = function(nums) { };",
            "python": "class Solution(object): def maxProduct(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "find-minimum-in-rotated-sorted-array",
    "title": "Find Minimum in Rotated Sorted Array",
    "acceptance": 0.5358533275904944,
    "difficulty": "Medium",
    "likes": 14957,
    "dislikes": 653,
    "stars": null,
    "tags": [
      "array",
      "binary-search"
    ],
    "description": "Suppose một mảng của độ dài n đã sắp xếp trong thứ tự tăng dần là rotated giữa 1 và n lần. Ví dụ, mảng nums = [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] nếu nó là rotated 4 lần. [0,1,2,4,5,6,7] nếu nó là rotated 7 lần. Lưu ý rằng rotating một mảng [một[0], một[1], một[2],..., một[n-1]] 1 thời gian kết quả trong mảng [một[n-1], một[0], một[1], một[2],..., một[n-2]]. Cho đã sắp xếp rotated mảng nums của không trùng lặp các phần tử, trả về nhỏ nhất phần tử của điều này mảng. Bạn phải viết một thuật toán đó runs trong O(log n) thời gian.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 5000",
      "-5000 <= nums[i] <= 5000 Tất cả các số nguyên của nums là không trùng lặp. nums là đã sắp xếp và rotated giữa 1 và n lần."
    ],
    "examples": [
      {
        "input": "nums = [3,4,5,1,2]",
        "output": "1",
        "explanation": "original mảng là [1,2,3,4,5] rotated 3 lần."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2]",
        "output": "0",
        "explanation": "original mảng là [0,1,2,4,5,6,7] và nó là rotated 4 lần."
      },
      {
        "input": "nums = [11,13,15,17]",
        "output": "11",
        "explanation": "original mảng là [11,13,15,17] và nó là rotated 4 lần."
      }
    ],
    "content": "Mảng là originally trong thứ tự tăng dần. Now đó mảng là rotated, có sẽ là một point trong mảng ở đâu Có một nhỏ deflection từ tăng dãy. eg. mảng sẽ là something like [4, 5, 6, 7, 0, 1, 2]. Bạn có thể chia tìm kiếm bộ nhớ thành hai và see nào direction để go. Bạn có thể think của một thuật toán nào có O(logN) tìm kiếm độ phức tạp? <ol> <li>All các phần tử để left của inflection point > đầu tiên phần tử của array.</li> <li>All các phần tử để right của inflection point < first element of the array.</li> <ol>",
    "defaultCode": {
      "cpp": "class Solution { public: int findMin(vector<int>& nums) { } };",
      "java": "class Solution { public int findMin(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var findMin = function(nums) { };",
      "python": "class Solution(object): def findMin(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:57 PM UTC+7",
    "editorial": {
      "content": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time.\n\nHint/nhắc ý (crawl được): Array was originally in ascending order. Now that the array is rotated, there would be a point in the array where there is a small deflection from the increasing sequence. eg. The array would be something like [4, 5, 6, 7, 0, 1, 2]. You can divide the search space into two and see which direction to go. Can you think of an algorithm which has O(logN) search complexity? <ol> <li>All the elements to the left of inflection point > first element of the array.</li> <li>All the elements to the right of inflection point < first element of the array.</li> <ol>\n\nGợi ý hướng giải: Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
      "lastUpdated": "January 13, 2026 at 3:40:57 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Binary Search",
          "description": "Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
          "timeComplexity": "$O(\\log n)$ hoặc $O(n\\log M)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int findMin(vector<int>& nums) { } };",
            "java": "class Solution { public int findMin(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var findMin = function(nums) { };",
            "python": "class Solution(object): def findMin(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "find-minimum-in-rotated-sorted-array-ii",
    "title": "Find Minimum in Rotated Sorted Array II",
    "acceptance": 0.44513216710900927,
    "difficulty": "Hard",
    "likes": 5029,
    "dislikes": 516,
    "stars": null,
    "tags": [
      "array",
      "binary-search"
    ],
    "description": "Suppose một mảng của độ dài n đã sắp xếp trong thứ tự tăng dần là rotated giữa 1 và n lần. Ví dụ, mảng nums = [0,1,4,4,5,6,7] might become: [4,5,6,7,0,1,4] nếu nó là rotated 4 lần. [0,1,4,4,5,6,7] nếu nó là rotated 7 lần. Lưu ý rằng rotating một mảng [một[0], một[1], một[2],..., một[n-1]] 1 thời gian kết quả trong mảng [một[n-1], một[0], một[1], một[2],..., một[n-2]]. Cho đã sắp xếp rotated mảng nums đó có thể chứa trùng lặp, trả về nhỏ nhất phần tử của điều này mảng. Bạn phải decrease overall thao tác các bước như much như có thể.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 5000",
      "-5000 <= nums[i] <= 5000 nums là đã sắp xếp và rotated giữa 1 và n lần. Câu hỏi thêm: Điều này problem là similar để Tìm Nhỏ nhất trong Rotated Đã sắp xếp Mảng, but nums có thể chứa trùng lặp. Sẽ điều này affect runtime độ phức tạp? Làm thế nào và tại sao?"
    ],
    "examples": [
      {
        "input": "nums = [1,3,5]",
        "output": "1",
        "explanation": ""
      },
      {
        "input": "nums = [2,2,2,0,1]",
        "output": "0",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int findMin(vector<int>& nums) { } };",
      "java": "class Solution { public int findMin(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var findMin = function(nums) { };",
      "python": "class Solution(object): def findMin(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:58 PM UTC+7",
    "editorial": {
      "content": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become: [4,5,6,7,0,1,4] if it was rotated 4 times. [0,1,4,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array. You must decrease the overall operation steps as much as possible.\n\nGợi ý hướng giải: Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
      "lastUpdated": "January 13, 2026 at 3:40:58 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Binary Search",
          "description": "Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
          "timeComplexity": "$O(\\log n)$ hoặc $O(n\\log M)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int findMin(vector<int>& nums) { } };",
            "java": "class Solution { public int findMin(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var findMin = function(nums) { };",
            "python": "class Solution(object): def findMin(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "min-stack",
    "title": "Min Stack",
    "acceptance": 0.575054326722913,
    "difficulty": "Medium",
    "likes": 15748,
    "dislikes": 984,
    "stars": null,
    "tags": [
      "stack",
      "design"
    ],
    "description": "Thiết kế một ngăn xếp đó supports push, pop, top, và retrieving nhỏ nhất phần tử trong constant thời gian. Cài đặt MinStack lớp: MinStack() khởi tạo ngăn xếp đối tượng. void push(int val) pushes phần tử val onto ngăn xếp. void pop() loại bỏ phần tử trên top của ngăn xếp. int top() gets top phần tử của ngăn xếp. int getMin() retrieves nhỏ nhất phần tử trong ngăn xếp. Bạn phải cài đặt một lời giải với O(1) thời gian độ phức tạp cho each hàm.",
    "constraints": [
      "-231 <= val <= 231 - 1 Methods pop, top và getMin các thao tác sẽ always là called trên không rỗng ngăn xếp. Nhiều nhất 3 * 104 calls sẽ là made để push, pop, top, và getMin."
    ],
    "examples": [],
    "content": "Consider each nút trong ngăn xếp having một nhỏ nhất giá trị. (Credits để @aakarshmadhavan)",
    "defaultCode": {
      "cpp": "class MinStack { public: MinStack() { } void push(int val) { } void pop() { } int top() { } int getMin() { } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj->push(val); * obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->getMin(); */",
      "java": "class MinStack { public MinStack() { } public void push(int val) { } public void pop() { } public int top() { } public int getMin() { } } /** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(val); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */",
      "javascript": "var MinStack = function() { }; /** * @param {number} val * @return {void} */ MinStack.prototype.push = function(val) { }; /** * @return {void} */ MinStack.prototype.pop = function() { }; /** * @return {number} */ MinStack.prototype.top = function() { }; /** * @return {number} */ MinStack.prototype.getMin = function() { }; /** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(val) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */",
      "python": "class MinStack(object): def __init__(self): def push(self, val): \"\"\" :type val: int :rtype: None \"\"\" def pop(self): \"\"\" :rtype: None \"\"\" def top(self): \"\"\" :rtype: int \"\"\" def getMin(self): \"\"\" :rtype: int \"\"\" # Your MinStack object will be instantiated and called as such: # obj = MinStack() # obj.push(val) # obj.pop() # param_3 = obj.top() # param_4 = obj.getMin()"
    },
    "createdAt": "January 13, 2026 at 3:40:59 PM UTC+7",
    "editorial": {
      "content": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. You must implement a solution with O(1) time complexity for each function.\n\nHint/nhắc ý (crawl được): Consider each node in the stack having a minimum value. (Credits to @aakarshmadhavan)\n\nGợi ý hướng giải: Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
      "lastUpdated": "January 13, 2026 at 3:40:59 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class MinStack { public: MinStack() { } void push(int val) { } void pop() { } int top() { } int getMin() { } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj->push(val); * obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->getMin(); */",
            "java": "class MinStack { public MinStack() { } public void push(int val) { } public void pop() { } public int top() { } public int getMin() { } } /** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(val); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */",
            "javascript": "var MinStack = function() { }; /** * @param {number} val * @return {void} */ MinStack.prototype.push = function(val) { }; /** * @return {void} */ MinStack.prototype.pop = function() { }; /** * @return {number} */ MinStack.prototype.top = function() { }; /** * @return {number} */ MinStack.prototype.getMin = function() { }; /** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(val) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */",
            "python": "class MinStack(object): def __init__(self): def push(self, val): \"\"\" :type val: int :rtype: None \"\"\" def pop(self): \"\"\" :rtype: None \"\"\" def top(self): \"\"\" :rtype: int \"\"\" def getMin(self): \"\"\" :rtype: int \"\"\" # Your MinStack object will be instantiated and called as such: # obj = MinStack() # obj.push(val) # obj.pop() # param_3 = obj.top() # param_4 = obj.getMin()"
          }
        }
      ]
    }
  },
  {
    "id": "intersection-of-two-linked-lists",
    "title": "Intersection of Two Linked Lists",
    "acceptance": 0.6285869809040313,
    "difficulty": "Easy",
    "likes": 16366,
    "dislikes": 1481,
    "stars": null,
    "tags": [
      "hash-table",
      "linked-list",
      "two-pointers"
    ],
    "description": "Cho heads của hai singly liên kết-các danh sách headA và headB, trả về nút tại nào hai các danh sách intersect. Nếu hai liên kết các danh sách có không intersection tại tất cả, trả về null. Ví dụ, sau đây hai liên kết các danh sách bắt đầu để intersect tại nút c1: test trường hợp là generated Sao cho Có không cycles anywhere trong toàn bộ liên kết cấu trúc. Lưu ý rằng liên kết các danh sách phải retain their original cấu trúc sau hàm trả về. Custom Judge: đầu vào để judge là cho như theo (của bạn program là không cho những đầu vào): intersectVal - giá trị của nút ở đâu intersection occurs. Điều này là 0 nếu Có không intersected nút. listA - đầu tiên danh sách liên kết. listB - thứ hai danh sách liên kết. skipA - số của các nút để skip ahead trong listA (bắt đầu từ head) để get để intersected nút. skipB - số của các nút để skip ahead trong listB (bắt đầu từ head) để get để intersected nút. judge sẽ thì tạo liên kết cấu trúc dựa trên trên những đầu vào và lần duyệt hai heads, headA và headB để của bạn program. Nếu bạn correctly trả về intersected nút, thì của bạn lời giải sẽ là accepted.",
    "constraints": [
      "số của các nút của listA là trong m. số của các nút của listB là trong n.",
      "1 <= m, n <= 3 * 104",
      "1 <= Node.val <= 105",
      "0 <= skipA <= m",
      "0 <= skipB <= n intersectVal là 0 nếu listA và listB làm không intersect. intersectVal == listA[skipA] == listB[skipB] nếu listA và listB intersect. Câu hỏi thêm: Bạn có thể viết một lời giải đó runs trong O(m + n) thời gian và dùng chỉ O(1) bộ nhớ?",
      "0 <= skipB <= n intersectVal là 0 nếu listA và listB làm không intersect. intersectVal == listA[skipA] == listB[skipB] nếu listA và listB intersect. Câu hỏi thêm: Bạn có thể viết một"
    ],
    "examples": [
      {
        "input": "intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3",
        "output": "Intersected at '8'",
        "explanation": "intersected node's giá trị là 8 ("
      },
      {
        "input": "intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1",
        "output": "Intersected at '2'",
        "explanation": "intersected node's giá trị là 2 ("
      },
      {
        "input": "intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2",
        "output": "No intersection",
        "explanation": "Từ head của Một, nó đọc như [2,6,4]. Từ head của B, nó đọc như [1,5]. Vì hai các danh sách làm không intersect, intersectVal phải là 0, trong khi skipA và skipB có thể là arbitrary các giá trị. Explanation: hai các danh sách làm không intersect, vì vậy trả về null."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} headA * @param {ListNode} headB * @return {ListNode} */ var getIntersectionNode = function(headA, headB) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def getIntersectionNode(self, headA, headB): \"\"\" :type head1, head1: ListNode :rtype: ListNode \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:40:59 PM UTC+7",
    "editorial": {
      "content": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. Custom Judge: The inputs to the judge are given as follows (your program is not given these inputs): intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node. listA - The first linked list. listB - The second linked list. skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node. skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node. The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
      "lastUpdated": "January 13, 2026 at 3:40:59 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} headA * @param {ListNode} headB * @return {ListNode} */ var getIntersectionNode = function(headA, headB) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def getIntersectionNode(self, headA, headB): \"\"\" :type head1, head1: ListNode :rtype: ListNode \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "find-peak-element",
    "title": "Find Peak Element",
    "acceptance": 0.4674715641120633,
    "difficulty": "Medium",
    "likes": 14266,
    "dislikes": 4931,
    "stars": null,
    "tags": [
      "array",
      "binary-search"
    ],
    "description": "Một peak phần tử là một phần tử đó là strictly lớn hơn nó neighbors. Cho một 0-chỉ số số nguyên mảng nums, tìm một peak phần tử, và trả về nó chỉ số. Nếu mảng chứa nhiều peaks, trả về chỉ số để bất kỳ của peaks. Bạn có thể imagine đó nums[-1] = nums[n] = -∞. Trong other words, một phần tử là always considered để là strictly lớn hơn một neighbor đó là bên ngoài mảng. Bạn phải viết một thuật toán đó runs trong O(log n) thời gian.",
    "constraints": [
      "1 <= nums.length <= 1000",
      "-231 <= nums[i] <= 231 - 1 nums[i]!= nums[i + 1] cho tất cả hợp lệ i."
    ],
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "2",
        "explanation": "3 là một peak phần tử và của bạn hàm nên trả về chỉ số số 2."
      },
      {
        "input": "nums = [1,2,1,3,5,6,4]",
        "output": "5",
        "explanation": "Của bạn hàm có thể trả về một trong hai chỉ số số 1 ở đâu peak phần tử là 2, hoặc chỉ số số 5 ở đâu peak phần tử là 6."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int findPeakElement(vector<int>& nums) { } };",
      "java": "class Solution { public int findPeakElement(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var findPeakElement = function(nums) { };",
      "python": "class Solution(object): def findPeakElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:00 PM UTC+7",
    "editorial": {
      "content": "A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time.\n\nGợi ý hướng giải: Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
      "lastUpdated": "January 13, 2026 at 3:41:00 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Binary Search",
          "description": "Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
          "timeComplexity": "$O(\\log n)$ hoặc $O(n\\log M)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int findPeakElement(vector<int>& nums) { } };",
            "java": "class Solution { public int findPeakElement(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var findPeakElement = function(nums) { };",
            "python": "class Solution(object): def findPeakElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "maximum-gap",
    "title": "Maximum Gap",
    "acceptance": 0.510700973427371,
    "difficulty": "Medium",
    "likes": 3530,
    "dislikes": 435,
    "stars": null,
    "tags": [
      "array",
      "sorting",
      "bucket-sort",
      "radix-sort"
    ],
    "description": "Cho một số nguyên mảng nums, trả về lớn nhất difference giữa hai successive các phần tử trong nó đã sắp xếp tạo thành. Nếu mảng chứa nhỏ hơn hai các phần tử, trả về 0. Bạn phải viết một thuật toán đó runs trong linear thời gian và dùng linear extra bộ nhớ.",
    "constraints": [
      "1 <= nums.length <= 105",
      "0 <= nums[i] <= 109"
    ],
    "examples": [
      {
        "input": "nums = [3,6,9,1]",
        "output": "3",
        "explanation": "đã sắp xếp tạo thành của mảng là [1,3,6,9], một trong hai (3,6) hoặc (6,9) có lớn nhất difference 3."
      },
      {
        "input": "nums = [10]",
        "output": "0",
        "explanation": "mảng chứa nhỏ hơn 2 các phần tử, do đó trả về 0."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int maximumGap(vector<int>& nums) { } };",
      "java": "class Solution { public int maximumGap(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var maximumGap = function(nums) { };",
      "python": "class Solution(object): def maximumGap(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:01 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0. You must write an algorithm that runs in linear time and uses linear extra space.\n\nGợi ý hướng giải: Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
      "lastUpdated": "January 13, 2026 at 3:41:01 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Sorting",
          "description": "Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
          "timeComplexity": "$O(n\\log n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(n)$",
          "code": {
            "cpp": "class Solution { public: int maximumGap(vector<int>& nums) { } };",
            "java": "class Solution { public int maximumGap(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var maximumGap = function(nums) { };",
            "python": "class Solution(object): def maximumGap(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "compare-version-numbers",
    "title": "Compare Version Numbers",
    "acceptance": 0.4594811074351384,
    "difficulty": "Medium",
    "likes": 3138,
    "dislikes": 2795,
    "stars": null,
    "tags": [
      "two-pointers",
      "string"
    ],
    "description": "Cho hai version các chuỗi, version1 và version2, compare chúng. Một version chuỗi Gồm revisions separated bởi dots '.'. giá trị của revision là nó số nguyên conversion ignoring ở đầu các số 0. Để compare version các chuỗi, compare their revision các giá trị trong left-để-right thứ tự. Nếu một của version các chuỗi có fewer revisions, treat missing revision các giá trị như 0. Trả về sau đây: Nếu version1 < version2, return -1. If version1 > version2, trả về 1. Otherwise, trả về 0.",
    "constraints": [
      "1 <= version1.length, version2.length <= 500 version1 và version2 chỉ chứa các chữ số và '.'. version1 và version2 là hợp lệ version các số. Tất cả cho revisions trong version1 và version2 có thể là được lưu trong một 32-bit số nguyên."
    ],
    "examples": [
      {
        "input": "version1 = \"1.2\", version2 = \"1.10\"",
        "output": "-1",
        "explanation": "version1's thứ hai revision là \"2\" và version2's thứ hai revision là \"10\": 2 < 10, vì vậy version1 < version2."
      },
      {
        "input": "version1 = \"1.01\", version2 = \"1.001\"",
        "output": "0",
        "explanation": "Ignoring ở đầu các số 0, both \"01\" và \"001\" biểu diễn giống nhau số nguyên \"1\"."
      },
      {
        "input": "version1 = \"1.0\", version2 = \"1.0.0.0\"",
        "output": "0",
        "explanation": "version1 có ít hơn revisions, nào means mỗi missing revision là treated như \"0\"."
      }
    ],
    "content": "Bạn có thể dùng hai các con trỏ cho each version chuỗi để duyệt chúng cùng trong khi comparing corresponding segments. Utilize chuỗi con method để extract each version segment delimited bởi '.'. Ensure you're extracting segments correctly bởi adjusting bắt đầu và kết thúc các chỉ số accordingly.",
    "defaultCode": {
      "cpp": "class Solution { public: int compareVersion(string version1, string version2) { } };",
      "java": "class Solution { public int compareVersion(String version1, String version2) { } }",
      "javascript": "/** * @param {string} version1 * @param {string} version2 * @return {number} */ var compareVersion = function(version1, version2) { };",
      "python": "class Solution(object): def compareVersion(self, version1, version2): \"\"\" :type version1: str :type version2: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:02 PM UTC+7",
    "editorial": {
      "content": "Given two version strings, version1 and version2, compare them. A version string consists of revisions separated by dots '.'. The value of the revision is its integer conversion ignoring leading zeros. To compare version strings, compare their revision values in left-to-right order. If one of the version strings has fewer revisions, treat the missing revision values as 0. Return the following: If version1 < version2, return -1. If version1 > version2, return 1. Otherwise, return 0.\n\nHint/nhắc ý (crawl được): You can use two pointers for each version string to traverse them together while comparing the corresponding segments. Utilize the substring method to extract each version segment delimited by '.'. Ensure you're extracting the segments correctly by adjusting the start and end indices accordingly.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:41:02 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int compareVersion(string version1, string version2) { } };",
            "java": "class Solution { public int compareVersion(String version1, String version2) { } }",
            "javascript": "/** * @param {string} version1 * @param {string} version2 * @return {number} */ var compareVersion = function(version1, version2) { };",
            "python": "class Solution(object): def compareVersion(self, version1, version2): \"\"\" :type version1: str :type version2: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "fraction-to-recurring-decimal",
    "title": "Fraction to Recurring Decimal",
    "acceptance": 0.3040653147312553,
    "difficulty": "Medium",
    "likes": 2568,
    "dislikes": 3858,
    "stars": null,
    "tags": [
      "hash-table",
      "math",
      "string"
    ],
    "description": "Cho hai các số nguyên biểu diễn numerator và denominator của một fraction, trả về fraction trong chuỗi format. Nếu fractional part là repeating, enclose repeating part trong dấu ngoặc Nếu nhiều đáp án là có thể, trả về bất kỳ của chúng. Đảm bảo rằng độ dài của đáp án chuỗi là nhỏ hơn 104 cho tất cả cho đầu vào. Lưu ý rằng nếu fraction có thể là được biểu diễn như một finite độ dài chuỗi, bạn phải trả về nó.",
    "constraints": [
      "-231 <= numerator, denominator <= 231 - 1 denominator!= 0"
    ],
    "examples": [
      {
        "input": "numerator = 1, denominator = 2",
        "output": "\"0.5\"",
        "explanation": ""
      },
      {
        "input": "numerator = 2, denominator = 1",
        "output": "\"2\"",
        "explanation": ""
      },
      {
        "input": "numerator = 4, denominator = 333",
        "output": "\"0.(012)\"",
        "explanation": ""
      }
    ],
    "content": "Không scary math, chỉ apply elementary math knowledge. Still remember làm thế nào để perform một <i>long division</i>? Hãy thử một long division trên 4/9, repeating part là obvious. Now Hãy thử 4/333. Làm bạn see một mẫu? Lưu ý rằng một lần remainder bắt đầu repeating, vì vậy divided kết quả. Là wary của cạnh trường hợp! Danh sách out như many test trường hợp như Bạn có thể think của và test của bạn code thoroughly.",
    "defaultCode": {
      "cpp": "class Solution { public: string fractionToDecimal(int numerator, int denominator) { } };",
      "java": "class Solution { public String fractionToDecimal(int numerator, int denominator) { } }",
      "javascript": "/** * @param {number} numerator * @param {number} denominator * @return {string} */ var fractionToDecimal = function(numerator, denominator) { };",
      "python": "class Solution(object): def fractionToDecimal(self, numerator, denominator): \"\"\" :type numerator: int :type denominator: int :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:03 PM UTC+7",
    "editorial": {
      "content": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses If multiple answers are possible, return any of them. It is guaranteed that the length of the answer string is less than 104 for all the given inputs. Note that if the fraction can be represented as a finite length string, you must return it.\n\nHint/nhắc ý (crawl được): No scary math, just apply elementary math knowledge. Still remember how to perform a <i>long division</i>? Try a long division on 4/9, the repeating part is obvious. Now try 4/333. Do you see a pattern? Notice that once the remainder starts repeating, so does the divided result. Be wary of edge cases! List out as many test cases as you can think of and test your code thoroughly.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
      "lastUpdated": "January 13, 2026 at 3:41:03 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: string fractionToDecimal(int numerator, int denominator) { } };",
            "java": "class Solution { public String fractionToDecimal(int numerator, int denominator) { } }",
            "javascript": "/** * @param {number} numerator * @param {number} denominator * @return {string} */ var fractionToDecimal = function(numerator, denominator) { };",
            "python": "class Solution(object): def fractionToDecimal(self, numerator, denominator): \"\"\" :type numerator: int :type denominator: int :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "two-sum-ii-input-array-is-sorted",
    "title": "Two Sum II - Input Array Is Sorted",
    "acceptance": 0.6438154186062401,
    "difficulty": "Medium",
    "likes": 13215,
    "dislikes": 1516,
    "stars": null,
    "tags": [
      "array",
      "two-pointers",
      "binary-search"
    ],
    "description": "Cho một 1-chỉ số mảng của các số nguyên numbers đó là already đã sắp xếp trong thứ tự không giảm, tìm hai numbers Sao cho họ cộng ra để một specific target số. Let những hai numbers là numbers[index1] và numbers[index2] ở đâu 1 <= index1 < index2 <= numbers.length. Trả về các chỉ số của hai numbers, index1 và index2, cộng bởi một như một số nguyên mảng [index1, index2] của độ dài 2. tests là generated Sao cho Có chính xác một lời giải. Bạn không được dùng giống nhau phần tử hai lần. Của bạn lời giải phải dùng chỉ constant extra bộ nhớ.",
    "constraints": [
      "2 <= numbers.length <= 3 * 104",
      "-1000 <= numbers[i] <= 1000 numbers là đã sắp xếp trong thứ tự không giảm.",
      "-1000 <= target <= 1000 tests là generated Sao cho Có chính xác một lời giải.",
      "-1000 <= target <= 1000 tests là generated Sao cho Có chính xác một"
    ],
    "examples": [
      {
        "input": "numbers = [2,7,11,15], target = 9",
        "output": "[1,2]",
        "explanation": "tổng của 2 và 7 là 9. Do đó, index1 = 1, index2 = 2. Chúng ta trả về [1, 2]."
      },
      {
        "input": "numbers = [2,3,4], target = 6",
        "output": "[1,3]",
        "explanation": "tổng của 2 và 4 là 6. Do đó index1 = 1, index2 = 3. Chúng ta trả về [1, 3]."
      },
      {
        "input": "numbers = [-1,0], target = -1",
        "output": "[1,2]",
        "explanation": "tổng của -1 và 0 là -1. Do đó index1 = 1, index2 = 2. Chúng ta trả về [1, 2]."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<int> twoSum(vector<int>& numbers, int target) { } };",
      "java": "class Solution { public int[] twoSum(int[] numbers, int target) { } }",
      "javascript": "/** * @param {number[]} numbers * @param {number} target * @return {number[]} */ var twoSum = function(numbers, target) { };",
      "python": "class Solution(object): def twoSum(self, numbers, target): \"\"\" :type numbers: List[int] :type target: int :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:04 PM UTC+7",
    "editorial": {
      "content": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space.\n\nGợi ý hướng giải: Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force. Dùng tìm kiếm nhị phân trên chỉ số hoặc trên miền giá trị (binary search on answer).",
      "lastUpdated": "January 13, 2026 at 3:41:04 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: vector<int> twoSum(vector<int>& numbers, int target) { } };",
            "java": "class Solution { public int[] twoSum(int[] numbers, int target) { } }",
            "javascript": "/** * @param {number[]} numbers * @param {number} target * @return {number[]} */ var twoSum = function(numbers, target) { };",
            "python": "class Solution(object): def twoSum(self, numbers, target): \"\"\" :type numbers: List[int] :type target: int :rtype: List[int] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "excel-sheet-column-title",
    "title": "Excel Sheet Column Title",
    "acceptance": 0.45356836738570877,
    "difficulty": "Easy",
    "likes": 6002,
    "dislikes": 905,
    "stars": null,
    "tags": [
      "math",
      "string"
    ],
    "description": "Cho một số nguyên columnNumber, trả về nó corresponding cột title như nó appears trong một Excel sheet. Ví dụ: Một -> 1 B -> 2 C -> 3... Z -> 26 AA -> 27 AB -> 28...",
    "constraints": [
      "1 <= columnNumber <= 231 - 1"
    ],
    "examples": [
      {
        "input": "columnNumber = 1",
        "output": "\"A\"",
        "explanation": ""
      },
      {
        "input": "columnNumber = 28",
        "output": "\"AB\"",
        "explanation": ""
      },
      {
        "input": "columnNumber = 701",
        "output": "\"ZY\"",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: string convertToTitle(int columnNumber) { } };",
      "java": "class Solution { public String convertToTitle(int columnNumber) { } }",
      "javascript": "/** * @param {number} columnNumber * @return {string} */ var convertToTitle = function(columnNumber) { };",
      "python": "class Solution(object): def convertToTitle(self, columnNumber): \"\"\" :type columnNumber: int :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:05 PM UTC+7",
    "editorial": {
      "content": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet. For example: A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ...\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:41:05 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Math / Simulation",
          "description": "Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: string convertToTitle(int columnNumber) { } };",
            "java": "class Solution { public String convertToTitle(int columnNumber) { } }",
            "javascript": "/** * @param {number} columnNumber * @return {string} */ var convertToTitle = function(columnNumber) { };",
            "python": "class Solution(object): def convertToTitle(self, columnNumber): \"\"\" :type columnNumber: int :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "majority-element",
    "title": "Majority Element",
    "acceptance": 0.6603329863613869,
    "difficulty": "Easy",
    "likes": 22269,
    "dislikes": 792,
    "stars": null,
    "tags": [
      "array",
      "hash-table",
      "divide-and-conquer",
      "sorting",
      "counting"
    ],
    "description": "Cho một mảng nums của kích thước n, trả về majority phần tử. majority phần tử là phần tử đó appears nhiều hơn hơn ⌊n / 2⌋ lần. Bạn có thể giả sử rằng majority phần tử always tồn tại trong mảng.",
    "constraints": [
      "n == nums.length",
      "1 <= n <= 5 * 104",
      "-109 <= nums[i] <= 109 đầu vào là generated Sao cho một majority phần tử sẽ tồn tại trong mảng. Câu hỏi thêm: Bạn có thể solve problem trong linear thời gian và trong O(1) bộ nhớ?"
    ],
    "examples": [
      {
        "input": "nums = [3,2,3]",
        "output": "3",
        "explanation": ""
      },
      {
        "input": "nums = [2,2,1,1,1,2,2]",
        "output": "2",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int majorityElement(vector<int>& nums) { } };",
      "java": "class Solution { public int majorityElement(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var majorityElement = function(nums) { };",
      "python": "class Solution(object): def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:05 PM UTC+7",
    "editorial": {
      "content": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả.",
      "lastUpdated": "January 13, 2026 at 3:41:05 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: int majorityElement(vector<int>& nums) { } };",
            "java": "class Solution { public int majorityElement(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var majorityElement = function(nums) { };",
            "python": "class Solution(object): def majorityElement(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "excel-sheet-column-number",
    "title": "Excel Sheet Column Number",
    "acceptance": 0.6701670201791903,
    "difficulty": "Easy",
    "likes": 5058,
    "dislikes": 396,
    "stars": null,
    "tags": [
      "math",
      "string"
    ],
    "description": "Cho một chuỗi columnTitle đó biểu diễn cột title như appears trong một Excel sheet, trả về nó corresponding cột số. Ví dụ: Một -> 1 B -> 2 C -> 3... Z -> 26 AA -> 27 AB -> 28...",
    "constraints": [
      "1 <= columnTitle.length <= 7 columnTitle Chỉ gồm chữ hoa Tiếng Anh các chữ cái. columnTitle là Trong khoảng [\"A\", \"FXSHRXW\"]."
    ],
    "examples": [
      {
        "input": "columnTitle = \"A\"",
        "output": "1",
        "explanation": ""
      },
      {
        "input": "columnTitle = \"AB\"",
        "output": "28",
        "explanation": ""
      },
      {
        "input": "columnTitle = \"ZY\"",
        "output": "701",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int titleToNumber(string columnTitle) { } };",
      "java": "class Solution { public int titleToNumber(String columnTitle) { } }",
      "javascript": "/** * @param {string} columnTitle * @return {number} */ var titleToNumber = function(columnTitle) { };",
      "python": "class Solution(object): def titleToNumber(self, columnTitle): \"\"\" :type columnTitle: str :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:06 PM UTC+7",
    "editorial": {
      "content": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number. For example: A -> 1 B -> 2 C -> 3 ... Z -> 26 AA -> 27 AB -> 28 ...\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:41:06 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Math / Simulation",
          "description": "Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int titleToNumber(string columnTitle) { } };",
            "java": "class Solution { public int titleToNumber(String columnTitle) { } }",
            "javascript": "/** * @param {string} columnTitle * @return {number} */ var titleToNumber = function(columnTitle) { };",
            "python": "class Solution(object): def titleToNumber(self, columnTitle): \"\"\" :type columnTitle: str :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "factorial-trailing-zeroes",
    "title": "Factorial Trailing Zeroes",
    "acceptance": 0.45923417842269965,
    "difficulty": "Medium",
    "likes": 3485,
    "dislikes": 1988,
    "stars": null,
    "tags": [
      "math"
    ],
    "description": "Cho một số nguyên n, trả về số của ở cuối các số 0 trong n!. Lưu ý rằng n! = n * (n - 1) * (n - 2) *... * 3 * 2 * 1.",
    "constraints": [
      "0 <= n <= 104 Câu hỏi thêm: Bạn có thể viết một lời giải đó works trong logarithmic thời gian độ phức tạp?",
      "0 <= n <= 104 Câu hỏi thêm: Bạn có thể viết một"
    ],
    "examples": [
      {
        "input": "n = 3",
        "output": "0",
        "explanation": "3! = 6, không ở cuối 0."
      },
      {
        "input": "n = 5",
        "output": "1",
        "explanation": "5! = 120, một ở cuối 0."
      },
      {
        "input": "n = 0",
        "output": "0",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int trailingZeroes(int n) { } };",
      "java": "class Solution { public int trailingZeroes(int n) { } }",
      "javascript": "/** * @param {number} n * @return {number} */ var trailingZeroes = function(n) { };",
      "python": "class Solution(object): def trailingZeroes(self, n): \"\"\" :type n: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:06 PM UTC+7",
    "editorial": {
      "content": "Given an integer n, return the number of trailing zeroes in n!. Note that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
      "lastUpdated": "January 13, 2026 at 3:41:06 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Math / Simulation",
          "description": "Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int trailingZeroes(int n) { } };",
            "java": "class Solution { public int trailingZeroes(int n) { } }",
            "javascript": "/** * @param {number} n * @return {number} */ var trailingZeroes = function(n) { };",
            "python": "class Solution(object): def trailingZeroes(self, n): \"\"\" :type n: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "binary-search-tree-iterator",
    "title": "Binary Search Tree Iterator",
    "acceptance": 0.759471009554218,
    "difficulty": "Medium",
    "likes": 9150,
    "dislikes": 576,
    "stars": null,
    "tags": [
      "stack",
      "tree",
      "design",
      "binary-search-tree",
      "binary-tree",
      "iterator"
    ],
    "description": "Cài đặt BSTIterator lớp đó biểu diễn một iterator over trong-thứ tự duyệt của một cây tìm kiếm nhị phân (BST): BSTIterator(TreeNode root) Khởi tạo một đối tượng của BSTIterator lớp. root của BST là cho như part của constructor. con trỏ nên là initialized để một không-existent số nhỏ hơn hơn bất kỳ phần tử trong BST. boolean hasNext() Trả về đúng nếu có tồn tại một số trong duyệt để right của con trỏ, otherwise trả về sai. int next() Di chuyển con trỏ để right, thì trả về số tại con trỏ. Lưu ý rằng bởi initializing con trỏ để một không-existent nhỏ nhất số, đầu tiên call để next() sẽ trả về nhỏ nhất phần tử trong BST. Bạn có thể giả sử rằng next() calls sẽ always là hợp lệ. Đó là, có sẽ là Ít nhất một next số trong trong-thứ tự duyệt khi nào next() là called.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [1, 105].",
      "0 <= Node.val <= 106 Nhiều nhất 105 calls sẽ là made để hasNext, và next. Câu hỏi thêm: Bạn có thể cài đặt next() và hasNext() để run trong trung bình O(1) thời gian và dùng O(h) bộ nhớ, ở đâu h là chiều cao của cây?"
    ],
    "examples": [],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class BSTIterator { public: BSTIterator(TreeNode* root) { } int next() { } bool hasNext() { } }; /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj->next(); * bool param_2 = obj->hasNext(); */",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class BSTIterator { public BSTIterator(TreeNode root) { } public int next() { } public boolean hasNext() { } } /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root */ var BSTIterator = function(root) { }; /** * @return {number} */ BSTIterator.prototype.next = function() { }; /** * @return {boolean} */ BSTIterator.prototype.hasNext = function() { }; /** * Your BSTIterator object will be instantiated and called as such: * var obj = new BSTIterator(root) * var param_1 = obj.next() * var param_2 = obj.hasNext() */",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class BSTIterator(object): def __init__(self, root): \"\"\" :type root: Optional[TreeNode] \"\"\" def next(self): \"\"\" :rtype: int \"\"\" def hasNext(self): \"\"\" :rtype: bool \"\"\" # Your BSTIterator object will be instantiated and called as such: # obj = BSTIterator(root) # param_1 = obj.next() # param_2 = obj.hasNext()"
    },
    "createdAt": "January 13, 2026 at 3:41:07 PM UTC+7",
    "editorial": {
      "content": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false. int next() Moves the pointer to the right, then returns the number at the pointer. Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.\n\nGợi ý hướng giải: Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng. Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue).",
      "lastUpdated": "January 13, 2026 at 3:41:07 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Stack",
          "description": "Dùng ngăn xếp để lưu trạng thái/đối tượng trước đó, phù hợp cho ngoặc, đơn điệu, hay mô phỏng.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class BSTIterator { public: BSTIterator(TreeNode* root) { } int next() { } bool hasNext() { } }; /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator* obj = new BSTIterator(root); * int param_1 = obj->next(); * bool param_2 = obj->hasNext(); */",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class BSTIterator { public BSTIterator(TreeNode root) { } public int next() { } public boolean hasNext() { } } /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root */ var BSTIterator = function(root) { }; /** * @return {number} */ BSTIterator.prototype.next = function() { }; /** * @return {boolean} */ BSTIterator.prototype.hasNext = function() { }; /** * Your BSTIterator object will be instantiated and called as such: * var obj = new BSTIterator(root) * var param_1 = obj.next() * var param_2 = obj.hasNext() */",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class BSTIterator(object): def __init__(self, root): \"\"\" :type root: Optional[TreeNode] \"\"\" def next(self): \"\"\" :rtype: int \"\"\" def hasNext(self): \"\"\" :rtype: bool \"\"\" # Your BSTIterator object will be instantiated and called as such: # obj = BSTIterator(root) # param_1 = obj.next() # param_2 = obj.hasNext()"
          }
        }
      ]
    }
  },
  {
    "id": "dungeon-game",
    "title": "Dungeon Game",
    "acceptance": 0.40649891242517183,
    "difficulty": "Hard",
    "likes": 6209,
    "dislikes": 118,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming",
      "matrix"
    ],
    "description": "demons có captured princess và imprisoned her trong dưới cùng-right corner của một dungeon. dungeon Gồm m x n rooms laid out trong một 2D lưới. Our valiant knight là initially vị trí trong top-left room và phải fight his way through dungeon để rescue princess. knight có một initial health point được biểu diễn bởi một dương số nguyên. Nếu tại bất kỳ point his health point drops để 0 hoặc bên dưới, he dies immediately. Một số của rooms là guarded bởi demons (được biểu diễn bởi âm các số nguyên), vì vậy knight loses health upon entering những rooms; other rooms là một trong hai rỗng (được biểu diễn như 0) hoặc chứa magic orbs đó increase knight's health (được biểu diễn bởi dương các số nguyên). Để reach princess như quickly như có thể, knight decides để di chuyển chỉ rightward hoặc downward trong each bước. Trả về knight's nhỏ nhất initial health vì vậy đó he có thể rescue princess. Lưu ý rằng bất kỳ room có thể chứa threats hoặc power-ra, even đầu tiên room knight enters và dưới cùng-right room ở đâu princess là imprisoned.",
    "constraints": [
      "m == dungeon.length n == dungeon[i].độ dài",
      "1 <= m, n <= 200",
      "-1000 <= dungeon[i][j] <= 1000"
    ],
    "examples": [
      {
        "input": "dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]",
        "output": "7",
        "explanation": "initial health của knight phải là Ít nhất 7 nếu he theo optimal đường đi: RIGHT-> RIGHT -> DOWN -> DOWN."
      },
      {
        "input": "dungeon = [[0]]",
        "output": "1",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int calculateMinimumHP(vector<vector<int>>& dungeon) { } };",
      "java": "class Solution { public int calculateMinimumHP(int[][] dungeon) { } }",
      "javascript": "/** * @param {number[][]} dungeon * @return {number} */ var calculateMinimumHP = function(dungeon) { };",
      "python": "class Solution(object): def calculateMinimumHP(self, dungeon): \"\"\" :type dungeon: List[List[int]] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:08 PM UTC+7",
    "editorial": {
      "content": "The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of m x n rooms laid out in a 2D grid. Our valiant knight was initially positioned in the top-left room and must fight his way through dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers). To reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Return the knight's minimum initial health so that he can rescue the princess. Note that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn. Duyệt ma trận theo hàng/cột/biên; dùng đánh dấu hoặc visited nếu cần.",
      "lastUpdated": "January 13, 2026 at 3:41:08 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int calculateMinimumHP(vector<vector<int>>& dungeon) { } };",
            "java": "class Solution { public int calculateMinimumHP(int[][] dungeon) { } }",
            "javascript": "/** * @param {number[][]} dungeon * @return {number} */ var calculateMinimumHP = function(dungeon) { };",
            "python": "class Solution(object): def calculateMinimumHP(self, dungeon): \"\"\" :type dungeon: List[List[int]] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "combine-two-tables",
    "title": "Combine Two Tables",
    "acceptance": 0.7900885338568289,
    "difficulty": "Easy",
    "likes": 4178,
    "dislikes": 252,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Person +-------------+---------+ | Cột Tên | Type | +-------------+---------+ | personId | int | | lastName | varchar | | firstName | varchar | +-------------+---------+ personId là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. Điều này bảng chứa information about ID của một số persons và their đầu tiên và last tên. Bảng: Address +-------------+---------+ | Cột Tên | Type | +-------------+---------+ | addressId | int | | personId | int | | city | varchar | | state | varchar | +-------------+---------+ addressId là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. Each hàng của điều này bảng chứa information about city và state của một person với ID = PersonId. Viết một lời giải để report đầu tiên tên, last tên, city, và state của each person trong Person bảng. Nếu address của một personId là không present trong Address bảng, report null instead. Trả về kết quả bảng Theo bất kỳ thứ tự nào. kết quả format là trong sau đây ví dụ.",
    "constraints": [],
    "examples": [
      {
        "input": "Person table: +----------+----------+-----------+ | personId | lastName | firstName | +----------+----------+-----------+ | 1 | Wang | Allen | | 2 | Alice | Bob | +----------+----------+-----------+ Address table: +-----------+----------+---------------+------------+ | addressId | personId | city | state | +-----------+----------+---------------+------------+ | 1 | 2 | New York City | New York | | 2 | 3 | Leetcode | California | +-----------+----------+---------------+------------+",
        "output": "+-----------+----------+---------------+----------+ | firstName | lastName | city | state | +-----------+----------+---------------+----------+ | Allen | Wang | Null | Null | | Bob | Alice | New York City | New York | +-----------+----------+---------------+----------+",
        "explanation": "Có không address trong address bảng cho personId = 1 vì vậy chúng ta trả về null trong their city và state. addressId = 1 chứa information about address của personId = 2."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:09 PM UTC+7",
    "editorial": {
      "content": "Table: Person +-------------+---------+ | Column Name | Type | +-------------+---------+ | personId | int | | lastName | varchar | | firstName | varchar | +-------------+---------+ personId is the primary key (column with unique values) for this table. This table contains information about the ID of some persons and their first and last names. Table: Address +-------------+---------+ | Column Name | Type | +-------------+---------+ | addressId | int | | personId | int | | city | varchar | | state | varchar | +-------------+---------+ addressId is the primary key (column with unique values) for this table. Each row of this table contains information about the city and state of one person with ID = PersonId. Write a solution to report the first name, last name, city, and state of each person in the Person table. If the address of a personId is not present in the Address table, report null instead. Return the result table in any order. The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:09 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "second-highest-salary",
    "title": "Second Highest Salary",
    "acceptance": 0.4594884421358712,
    "difficulty": "Medium",
    "likes": 4134,
    "dislikes": 1010,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Nhân viên +-------------+------+ | Cột Tên | Type | +-------------+------+ | id | int | | salary | int | +-------------+------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. Each hàng của điều này bảng chứa information about salary của một nhân viên. Viết một lời giải để tìm thứ hai cao nhất phân biệt salary từ Nhân viên bảng. Nếu Có không thứ hai cao nhất salary, trả về null (trả về None trong Pandas). kết quả format là trong sau đây ví dụ.",
    "constraints": [],
    "examples": [
      {
        "input": "Employee table: +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+",
        "output": "+---------------------+ | SecondHighestSalary | +---------------------+ | 200 | +---------------------+",
        "explanation": ""
      },
      {
        "input": "Employee table: +----+--------+ | id | salary | +----+--------+ | 1 | 100 | +----+--------+",
        "output": "+---------------------+ | SecondHighestSalary | +---------------------+ | null | +---------------------+",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:09 PM UTC+7",
    "editorial": {
      "content": "Table: Employee +-------------+------+ | Column Name | Type | +-------------+------+ | id | int | | salary | int | +-------------+------+ id is the primary key (column with unique values) for this table. Each row of this table contains information about the salary of an employee. Write a solution to find the second highest distinct salary from the Employee table. If there is no second highest salary, return null (return None in Pandas). The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:09 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "nth-highest-salary",
    "title": "Nth Highest Salary",
    "acceptance": 0.38709759377225095,
    "difficulty": "Medium",
    "likes": 2253,
    "dislikes": 1113,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Nhân viên +-------------+------+ | Cột Tên | Type | +-------------+------+ | id | int | | salary | int | +-------------+------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. Each hàng của điều này bảng chứa information about salary của một nhân viên. Viết một lời giải để tìm nth cao nhất phân biệt salary từ Nhân viên bảng. Nếu Có nhỏ hơn n phân biệt salaries, trả về null. kết quả format là trong sau đây ví dụ.",
    "constraints": [],
    "examples": [
      {
        "input": "Employee table: +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ n = 2",
        "output": "+------------------------+ | getNthHighestSalary(2) | +------------------------+ | 200 | +------------------------+",
        "explanation": ""
      },
      {
        "input": "Employee table: +----+--------+ | id | salary | +----+--------+ | 1 | 100 | +----+--------+ n = 2",
        "output": "+------------------------+ | getNthHighestSalary(2) | +------------------------+ | null | +------------------------+",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:10 PM UTC+7",
    "editorial": {
      "content": "Table: Employee +-------------+------+ | Column Name | Type | +-------------+------+ | id | int | | salary | int | +-------------+------+ id is the primary key (column with unique values) for this table. Each row of this table contains information about the salary of an employee. Write a solution to find the nth highest distinct salary from the Employee table. If there are less than n distinct salaries, return null. The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:10 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "rank-scores",
    "title": "Rank Scores",
    "acceptance": 0.6681032393961226,
    "difficulty": "Medium",
    "likes": 2432,
    "dislikes": 300,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Scores +-------------+---------+ | Cột Tên | Type | +-------------+---------+ | id | int | | score | decimal | +-------------+---------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. Each hàng của điều này bảng chứa score của một game. Score là một floating point giá trị với hai decimal places. Viết một lời giải để tìm rank của scores. ranking nên là calculated according để sau đây rules: scores nên là ranked từ cao nhất để lowest. Nếu Có một tie giữa hai scores, both nên có giống nhau ranking. Sau một tie, next ranking số nên là next consecutive số nguyên giá trị. Trong other words, có nên là không holes giữa ranks. Trả về kết quả bảng thứ tự bởi score trong thứ tự giảm dần. kết quả format là trong sau đây ví dụ.",
    "constraints": [],
    "examples": [
      {
        "input": "Scores table: +----+-------+ | id | score | +----+-------+ | 1 | 3.50 | | 2 | 3.65 | | 3 | 4.00 | | 4 | 3.85 | | 5 | 4.00 | | 6 | 3.65 | +----+-------+",
        "output": "+-------+------+ | score | rank | +-------+------+ | 4.00 | 1 | | 4.00 | 1 | | 3.85 | 2 | | 3.65 | 3 | | 3.65 | 3 | | 3.50 | 4 | +-------+------+",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:10 PM UTC+7",
    "editorial": {
      "content": "Table: Scores +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | score | decimal | +-------------+---------+ id is the primary key (column with unique values) for this table. Each row of this table contains the score of a game. Score is a floating point value with two decimal places. Write a solution to find the rank of the scores. The ranking should be calculated according to the following rules: The scores should be ranked from the highest to the lowest. If there is a tie between two scores, both should have the same ranking. After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks. Return the result table ordered by score in descending order. The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:10 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "largest-number",
    "title": "Largest Number",
    "acceptance": 0.4230137774709198,
    "difficulty": "Medium",
    "likes": 9347,
    "dislikes": 797,
    "stars": null,
    "tags": [
      "array",
      "string",
      "greedy",
      "sorting"
    ],
    "description": "Cho một danh sách của không âm các số nguyên nums, arrange chúng Sao cho họ tạo thành lớn nhất số và trả về nó. Vì kết quả có thể là very lớn, vì vậy bạn need để trả về một chuỗi instead của một số nguyên.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 109"
    ],
    "examples": [
      {
        "input": "nums = [10,2]",
        "output": "\"210\"",
        "explanation": ""
      },
      {
        "input": "nums = [3,30,34,5,9]",
        "output": "\"9534330\"",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: string largestNumber(vector<int>& nums) { } };",
      "java": "class Solution { public String largestNumber(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {string} */ var largestNumber = function(nums) { };",
      "python": "class Solution(object): def largestNumber(self, nums): \"\"\" :type nums: List[int] :rtype: str \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:12 PM UTC+7",
    "editorial": {
      "content": "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it. Since the result may be very large, so you need to return a string instead of an integer.\n\nGợi ý hướng giải: Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu. Chọn quyết định cục bộ tối ưu và chứng minh rằng nó dẫn tới tối ưu toàn cục.",
      "lastUpdated": "January 13, 2026 at 3:41:12 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Sorting",
          "description": "Sắp xếp để đưa dữ liệu về trật tự thuận tiện, sau đó áp dụng quét tuyến tính/two pointers/merge.",
          "timeComplexity": "$O(n\\log n)$",
          "spaceComplexity": "$O(1)$ hoặc $O(n)$",
          "code": {
            "cpp": "class Solution { public: string largestNumber(vector<int>& nums) { } };",
            "java": "class Solution { public String largestNumber(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {string} */ var largestNumber = function(nums) { };",
            "python": "class Solution(object): def largestNumber(self, nums): \"\"\" :type nums: List[int] :rtype: str \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "consecutive-numbers",
    "title": "Consecutive Numbers",
    "acceptance": 0.4758767514623861,
    "difficulty": "Medium",
    "likes": 2651,
    "dislikes": 357,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Logs +-------------+---------+ | Cột Tên | Type | +-------------+---------+ | id | int | | num | varchar | +-------------+---------+ Trong SQL, id là primary khóa cho điều này bảng. id là một autoincrement cột bắt đầu từ 1. Tìm tất cả các số đó appear Ít nhất ba lần consecutively. Trả về kết quả bảng Theo bất kỳ thứ tự nào. kết quả format là trong sau đây ví dụ.",
    "constraints": [],
    "examples": [
      {
        "input": "Logs table: +----+-----+ | id | num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+",
        "output": "+-----------------+ | ConsecutiveNums | +-----------------+ | 1 | +-----------------+",
        "explanation": "1 là chỉ số đó appears consecutively cho Ít nhất ba lần."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:12 PM UTC+7",
    "editorial": {
      "content": "Table: Logs +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | num | varchar | +-------------+---------+ In SQL, id is the primary key for this table. id is an autoincrement column starting from 1. Find all numbers that appear at least three times consecutively. Return the result table in any order. The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:12 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "employees-earning-more-than-their-managers",
    "title": "Employees Earning More Than Their Managers",
    "acceptance": 0.7262443644275194,
    "difficulty": "Easy",
    "likes": 3025,
    "dislikes": 293,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Nhân viên +-------------+---------+ | Cột Tên | Type | +-------------+---------+ | id | int | | tên | varchar | | salary | int | | managerId | int | +-------------+---------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. Each hàng của điều này bảng indicates ID của một nhân viên, their tên, salary, và ID của their manager. Viết một lời giải để tìm các nhân viên ai earn nhiều hơn hơn their managers. Trả về kết quả bảng Theo bất kỳ thứ tự nào. kết quả format là trong sau đây ví dụ.",
    "constraints": [],
    "examples": [
      {
        "input": "Employee table: +----+-------+--------+-----------+ | id | name | salary | managerId | +----+-------+--------+-----------+ | 1 | Joe | 70000 | 3 | | 2 | Henry | 80000 | 4 | | 3 | Sam | 60000 | Null | | 4 | Max | 90000 | Null | +----+-------+--------+-----------+",
        "output": "+----------+ | Employee | +----------+ | Joe | +----------+",
        "explanation": "Joe là chỉ nhân viên ai earns nhiều hơn hơn his manager."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:13 PM UTC+7",
    "editorial": {
      "content": "Table: Employee +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | name | varchar | | salary | int | | managerId | int | +-------------+---------+ id is the primary key (column with unique values) for this table. Each row of this table indicates the ID of an employee, their name, salary, and the ID of their manager. Write a solution to find the employees who earn more than their managers. Return the result table in any order. The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:13 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "duplicate-emails",
    "title": "Duplicate Emails",
    "acceptance": 0.7322745944912993,
    "difficulty": "Easy",
    "likes": 2392,
    "dislikes": 84,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Person +-------------+---------+ | Cột Tên | Type | +-------------+---------+ | id | int | | email | varchar | +-------------+---------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. Each hàng của điều này bảng chứa một email. emails sẽ không chứa chữ hoa các chữ cái. Viết một lời giải để report tất cả trùng lặp emails. Lưu ý rằng it's được đảm bảo đó email field là không NULL. Trả về kết quả bảng Theo bất kỳ thứ tự nào. kết quả format là trong sau đây ví dụ.",
    "constraints": [],
    "examples": [
      {
        "input": "Person table: +----+---------+ | id | email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+",
        "output": "+---------+ | Email | +---------+ | a@b.com | +---------+",
        "explanation": "một@b.com là repeated hai lần."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:14 PM UTC+7",
    "editorial": {
      "content": "Table: Person +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | email | varchar | +-------------+---------+ id is the primary key (column with unique values) for this table. Each row of this table contains an email. The emails will not contain uppercase letters. Write a solution to report all the duplicate emails. Note that it's guaranteed that the email field is not NULL. Return the result table in any order. The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:14 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "customers-who-never-order",
    "title": "Customers Who Never Order",
    "acceptance": 0.7132171222279525,
    "difficulty": "Easy",
    "likes": 2984,
    "dislikes": 153,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Customers +-------------+---------+ | Cột Tên | Type | +-------------+---------+ | id | int | | tên | varchar | +-------------+---------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. Each hàng của điều này bảng indicates ID và tên của một customer. Bảng: Thứ tự +-------------+------+ | Cột Tên | Type | +-------------+------+ | id | int | | customerId | int | +-------------+------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. customerId là một foreign khóa (reference các cột) của ID từ Customers bảng. Each hàng của điều này bảng indicates ID của một thứ tự và ID của customer ai thứ tự nó. Viết một lời giải để tìm tất cả customers ai never thứ tự anything. Trả về kết quả bảng Theo bất kỳ thứ tự nào. kết quả format là trong sau đây ví dụ.",
    "constraints": [],
    "examples": [
      {
        "input": "Customers table: +----+-------+ | id | name | +----+-------+ | 1 | Joe | | 2 | Henry | | 3 | Sam | | 4 | Max | +----+-------+ Orders table: +----+------------+ | id | customerId | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+",
        "output": "+-----------+ | Customers | +-----------+ | Henry | | Max | +-----------+",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:15 PM UTC+7",
    "editorial": {
      "content": "Table: Customers +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | name | varchar | +-------------+---------+ id is the primary key (column with unique values) for this table. Each row of this table indicates the ID and name of a customer. Table: Orders +-------------+------+ | Column Name | Type | +-------------+------+ | id | int | | customerId | int | +-------------+------+ id is the primary key (column with unique values) for this table. customerId is a foreign key (reference columns) of the ID from the Customers table. Each row of this table indicates the ID of an order and the ID of the customer who ordered it. Write a solution to find all customers who never order anything. Return the result table in any order. The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:15 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "department-highest-salary",
    "title": "Department Highest Salary",
    "acceptance": 0.5687866343102482,
    "difficulty": "Medium",
    "likes": 2335,
    "dislikes": 207,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Nhân viên +--------------+---------+ | Cột Tên | Type | +--------------+---------+ | id | int | | tên | varchar | | salary | int | | departmentId | int | +--------------+---------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. departmentId là một foreign khóa (reference các cột) của ID từ Department bảng. Each hàng của điều này bảng indicates ID, tên, và salary của một nhân viên. Nó cũng chứa ID của their department. Bảng: Department +-------------+---------+ | Cột Tên | Type | +-------------+---------+ | id | int | | tên | varchar | +-------------+---------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. Đảm bảo rằng department tên là không NULL. Each hàng của điều này bảng indicates ID của một department và nó tên. Viết một lời giải để tìm các nhân viên ai có cao nhất salary trong each của departments. Trả về kết quả bảng Theo bất kỳ thứ tự nào. kết quả format là trong sau đây ví dụ.",
    "constraints": [],
    "examples": [
      {
        "input": "Employee table: +----+-------+--------+--------------+ | id | name | salary | departmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Jim | 90000 | 1 | | 3 | Henry | 80000 | 2 | | 4 | Sam | 60000 | 2 | | 5 | Max | 90000 | 1 | +----+-------+--------+--------------+ Department table: +----+-------+ | id | name | +----+-------+ | 1 | IT | | 2 | Sales | +----+-------+",
        "output": "+------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Jim | 90000 | | Sales | Henry | 80000 | | IT | Max | 90000 | +------------+----------+--------+",
        "explanation": "Lớn nhất và Jim both có cao nhất salary trong Nó department và Henry có cao nhất salary trong Sales department."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:16 PM UTC+7",
    "editorial": {
      "content": "Table: Employee +--------------+---------+ | Column Name | Type | +--------------+---------+ | id | int | | name | varchar | | salary | int | | departmentId | int | +--------------+---------+ id is the primary key (column with unique values) for this table. departmentId is a foreign key (reference columns) of the ID from the Department table. Each row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department. Table: Department +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | name | varchar | +-------------+---------+ id is the primary key (column with unique values) for this table. It is guaranteed that department name is not NULL. Each row of this table indicates the ID of a department and its name. Write a solution to find employees who have the highest salary in each of the departments. Return the result table in any order. The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:16 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "department-top-three-salaries",
    "title": "Department Top Three Salaries",
    "acceptance": 0.5951843380164036,
    "difficulty": "Hard",
    "likes": 2522,
    "dislikes": 274,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Nhân viên +--------------+---------+ | Cột Tên | Type | +--------------+---------+ | id | int | | tên | varchar | | salary | int | | departmentId | int | +--------------+---------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. departmentId là một foreign khóa (reference cột) của ID từ Department bảng. Each hàng của điều này bảng indicates ID, tên, và salary của một nhân viên. Nó cũng chứa ID của their department. Bảng: Department +-------------+---------+ | Cột Tên | Type | +-------------+---------+ | id | int | | tên | varchar | +-------------+---------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. Each hàng của điều này bảng indicates ID của một department và nó tên. Một company's executives là interested trong seeing ai earns nhiều nhất money trong each của company's departments. Một high earner trong một department là một nhân viên ai có một salary trong top ba không trùng lặp salaries cho đó department. Viết một lời giải để tìm các nhân viên ai là high earners trong each của departments. Trả về kết quả bảng Theo bất kỳ thứ tự nào. kết quả format là trong sau đây ví dụ.",
    "constraints": [
      "Có không các nhân viên với exact giống nhau tên, salary và department."
    ],
    "examples": [
      {
        "input": "Employee table: +----+-------+--------+--------------+ | id | name | salary | departmentId | +----+-------+--------+--------------+ | 1 | Joe | 85000 | 1 | | 2 | Henry | 80000 | 2 | | 3 | Sam | 60000 | 2 | | 4 | Max | 90000 | 1 | | 5 | Janet | 69000 | 1 | | 6 | Randy | 85000 | 1 | | 7 | Will | 70000 | 1 | +----+-------+--------+--------------+ Department table: +----+-------+ | id | name | +----+-------+ | 1 | IT | | 2 | Sales | +----+-------+",
        "output": "+------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | IT | Joe | 85000 | | IT | Randy | 85000 | | IT | Will | 70000 | | Sales | Henry | 80000 | | Sales | Sam | 60000 | +------------+----------+--------+",
        "explanation": "Trong Nó department: - Lớn nhất earns cao nhất không trùng lặp salary - Both Randy và Joe earn thứ hai-cao nhất không trùng lặp salary - Sẽ earns thứ ba-cao nhất không trùng lặp salary Trong Sales department: - Henry earns cao nhất salary - Sam earns thứ hai-cao nhất salary - Có không thứ ba-cao nhất salary như Có chỉ hai các nhân viên"
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:17 PM UTC+7",
    "editorial": {
      "content": "Table: Employee +--------------+---------+ | Column Name | Type | +--------------+---------+ | id | int | | name | varchar | | salary | int | | departmentId | int | +--------------+---------+ id is the primary key (column with unique values) for this table. departmentId is a foreign key (reference column) of the ID from the Department table. Each row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department. Table: Department +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | name | varchar | +-------------+---------+ id is the primary key (column with unique values) for this table. Each row of this table indicates the ID of a department and its name. A company's executives are interested in seeing who earns the most money in each of the company's departments. A high earner in a department is an employee who has a salary in the top three unique salaries for that department. Write a solution to find the employees who are high earners in each of the departments. Return the result table in any order. The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:17 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "repeated-dna-sequences",
    "title": "Repeated DNA Sequences",
    "acceptance": 0.5261054334148298,
    "difficulty": "Medium",
    "likes": 3579,
    "dislikes": 567,
    "stars": null,
    "tags": [
      "hash-table",
      "string",
      "bit-manipulation",
      "sliding-window",
      "rolling-hash",
      "hash-function"
    ],
    "description": "DNA dãy là composed của một series của nucleotides abbreviated như 'Một', 'C', 'G', và 'T'. Ví dụ, \"ACGAATTCCG\" là một DNA dãy. Khi nào studying DNA, nó là useful để identify repeated dãy trong DNA. Cho một chuỗi s đó biểu diễn một DNA dãy, trả về tất cả 10-chữ cái-long dãy (chuỗi con) đó occur nhiều hơn hơn một lần trong một DNA molecule. Bạn có thể trả về đáp án Theo bất kỳ thứ tự nào.",
    "constraints": [
      "1 <= s.length <= 105 s[i] là một trong hai 'Một', 'C', 'G', hoặc 'T'."
    ],
    "examples": [
      {
        "input": "s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"",
        "output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
        "explanation": ""
      },
      {
        "input": "s = \"AAAAAAAAAAAAA\"",
        "output": "[\"AAAAAAAAAA\"]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: vector<string> findRepeatedDnaSequences(string s) { } };",
      "java": "class Solution { public List<String> findRepeatedDnaSequences(String s) { } }",
      "javascript": "/** * @param {string} s * @return {string[]} */ var findRepeatedDnaSequences = function(s) { };",
      "python": "class Solution(object): def findRepeatedDnaSequences(self, s): \"\"\" :type s: str :rtype: List[str] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:17 PM UTC+7",
    "editorial": {
      "content": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. For example, \"ACGAATTCCG\" is a DNA sequence. When studying DNA, it is useful to identify repeated sequences within the DNA. Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:41:17 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: vector<string> findRepeatedDnaSequences(string s) { } };",
            "java": "class Solution { public List<String> findRepeatedDnaSequences(String s) { } }",
            "javascript": "/** * @param {string} s * @return {string[]} */ var findRepeatedDnaSequences = function(s) { };",
            "python": "class Solution(object): def findRepeatedDnaSequences(self, s): \"\"\" :type s: str :rtype: List[str] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "best-time-to-buy-and-sell-stock-iv",
    "title": "Best Time to Buy and Sell Stock IV",
    "acceptance": 0.49194195748364694,
    "difficulty": "Hard",
    "likes": 7946,
    "dislikes": 223,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming"
    ],
    "description": "Bạn được cho một số nguyên mảng prices ở đâu prices[i] là price của một cho cổ phiếu trên ith ngày, và một số nguyên k. Tìm lớn nhất lợi nhuận Bạn có thể achieve. Bạn có thể complete Nhiều nhất k transactions: i.e. bạn có thể buy Nhiều nhất k lần và sell Nhiều nhất k lần. Lưu ý: Bạn không được engage trong nhiều transactions simultaneously (i.e., bạn phải sell cổ phiếu trước bạn buy again).",
    "constraints": [
      "1 <= k <= 100",
      "1 <= prices.length <= 1000",
      "0 <= prices[i] <= 1000"
    ],
    "examples": [
      {
        "input": "k = 2, prices = [2,4,1]",
        "output": "2",
        "explanation": "Buy trên ngày 1 (price = 2) và sell trên ngày 2 (price = 4), lợi nhuận = 4-2 = 2."
      },
      {
        "input": "k = 2, prices = [3,2,6,5,0,3]",
        "output": "7",
        "explanation": "Buy trên ngày 2 (price = 2) và sell trên ngày 3 (price = 6), lợi nhuận = 6-2 = 4. Thì buy trên ngày 5 (price = 0) và sell trên ngày 6 (price = 3), lợi nhuận = 3-0 = 3."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int maxProfit(int k, vector<int>& prices) { } };",
      "java": "class Solution { public int maxProfit(int k, int[] prices) { } }",
      "javascript": "/** * @param {number} k * @param {number[]} prices * @return {number} */ var maxProfit = function(k, prices) { };",
      "python": "class Solution(object): def maxProfit(self, k, prices): \"\"\" :type k: int :type prices: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:18 PM UTC+7",
    "editorial": {
      "content": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k. Find the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times. Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:41:18 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int maxProfit(int k, vector<int>& prices) { } };",
            "java": "class Solution { public int maxProfit(int k, int[] prices) { } }",
            "javascript": "/** * @param {number} k * @param {number[]} prices * @return {number} */ var maxProfit = function(k, prices) { };",
            "python": "class Solution(object): def maxProfit(self, k, prices): \"\"\" :type k: int :type prices: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "rotate-array",
    "title": "Rotate Array",
    "acceptance": 0.4421478064634757,
    "difficulty": "Medium",
    "likes": 20589,
    "dislikes": 2165,
    "stars": null,
    "tags": [
      "array",
      "math",
      "two-pointers"
    ],
    "description": "Cho một số nguyên mảng nums, xoay mảng để right bởi k các bước, ở đâu k là không âm.",
    "constraints": [
      "1 <= nums.length <= 105",
      "-231 <= nums[i] <= 231 - 1",
      "0 <= k <= 105 Câu hỏi thêm: Hãy thử đưa ra như many các lời giải như Bạn có thể. Có Ít nhất ba khác nhau ways để solve điều này problem. Bạn có thể làm nó trong-place với O(1) extra bộ nhớ?"
    ],
    "examples": [
      {
        "input": "nums = [1,2,3,4,5,6,7], k = 3",
        "output": "[5,6,7,1,2,3,4]",
        "explanation": "xoay 1 các bước để right: [7,1,2,3,4,5,6] xoay 2 các bước để right: [6,7,1,2,3,4,5] xoay 3 các bước để right: [5,6,7,1,2,3,4]"
      },
      {
        "input": "nums = [-1,-100,3,99], k = 2",
        "output": "[3,99,-1,-100]",
        "explanation": "xoay 1 các bước để right: [99,-1,-100,3] xoay 2 các bước để right: [3,99,-1,-100]"
      }
    ],
    "content": "easiest lời giải sẽ dùng additional bộ nhớ và đó là perfectly fine. actual trick đưa ra khi nào trying để solve điều này problem không using bất kỳ additional bộ nhớ. Điều này means bạn need để dùng original mảng somehow để di chuyển các phần tử around. Now, chúng ta có thể place each phần tử trong nó original location và shift tất cả các phần tử around nó để adjust như đó sẽ là too costly và nhiều nhất likely sẽ thời gian out trên lớn hơn đầu vào các mảng. Một đường thẳng của thought là dựa trên trên reversing mảng (hoặc parts của nó) để obtain desired kết quả. Think about làm thế nào reversal might potentially help us out bởi using một ví dụ. other đường thẳng của thought là một tad bit complicated but essentially nó xây dựng trên idea của placing each phần tử trong nó original vị trí trong khi giữ track của phần tử originally trong đó vị trí. Basically, tại mỗi bước, chúng ta place một phần tử trong nó rightful vị trí và giữ track của phần tử already có hoặc một là overwritten trong một additional variable. Chúng ta không thể làm điều này trong một linear lần duyệt và idea here là dựa trên trên <b>cyclic-dependencies</b> giữa các phần tử.",
    "defaultCode": {
      "cpp": "class Solution { public: void rotate(vector<int>& nums, int k) { } };",
      "java": "class Solution { public void rotate(int[] nums, int k) { } }",
      "javascript": "/** * @param {number[]} nums * @param {number} k * @return {void} Do not return anything, modify nums in-place instead. */ var rotate = function(nums, k) { };",
      "python": "class Solution(object): def rotate(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: None Do not return anything, modify nums in-place instead. \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:18 PM UTC+7",
    "editorial": {
      "content": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\nHint/nhắc ý (crawl được): The easiest solution would use additional memory and that is perfectly fine. The actual trick comes when trying to solve this problem without using any additional memory. This means you need to use the original array somehow to move the elements around. Now, we can place each element in its original location and shift all the elements around it to adjust as that would be too costly and most likely will time out on larger input arrays. One line of thought is based on reversing the array (or parts of it) to obtain the desired result. Think about how reversal might potentially help us out by using an example. The other line of thought is a tad bit complicated but essentially it builds on the idea of placing each element in its original position while keeping track of the element originally in that position. Basically, at every step, we place an element in its rightful position and keep track of the element already there or the one being overwritten in an additional variable. We can't do this in one linear pass and the idea here is based on <b>cyclic-dependencies</b> between elements.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên. Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
      "lastUpdated": "January 13, 2026 at 3:41:18 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers",
          "description": "Dùng hai con trỏ (trái/phải) và di chuyển dựa trên điều kiện để tối ưu so với brute force.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: void rotate(vector<int>& nums, int k) { } };",
            "java": "class Solution { public void rotate(int[] nums, int k) { } }",
            "javascript": "/** * @param {number[]} nums * @param {number} k * @return {void} Do not return anything, modify nums in-place instead. */ var rotate = function(nums, k) { };",
            "python": "class Solution(object): def rotate(self, nums, k): \"\"\" :type nums: List[int] :type k: int :rtype: None Do not return anything, modify nums in-place instead. \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "reverse-bits",
    "title": "Reverse Bits",
    "acceptance": 0.6547539233673831,
    "difficulty": "Easy",
    "likes": 5576,
    "dislikes": 1642,
    "stars": null,
    "tags": [
      "divide-and-conquer",
      "bit-manipulation"
    ],
    "description": "Đảo ngược bits của một cho 32 bits có dấu số nguyên.",
    "constraints": [
      "0 <= n <= 231 - 2 n là even. Câu hỏi thêm: Nếu điều này hàm là called many lần, làm thế nào sẽ bạn optimize nó?"
    ],
    "examples": [
      {
        "input": "n = 43261596",
        "output": "964176192",
        "explanation": "Số nguyên Nhị phân 43261596 00000010100101000001111010011100 964176192 00111001011110000010100101000000"
      },
      {
        "input": "n = 2147483644",
        "output": "1073741822",
        "explanation": "Số nguyên Nhị phân 2147483644 01111111111111111111111111111100 1073741822 00111111111111111111111111111110"
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int reverseBits(int n) { } };",
      "java": "class Solution { public int reverseBits(int n) { } }",
      "javascript": "/** * @param {number} n * @return {number} */ var reverseBits = function(n) { };",
      "python": "class Solution(object): def reverseBits(self, n): \"\"\" :type n: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:19 PM UTC+7",
    "editorial": {
      "content": "Reverse bits of a given 32 bits signed integer.\n\nGợi ý hướng giải: Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả. Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
      "lastUpdated": "January 13, 2026 at 3:41:19 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Divide and Conquer",
          "description": "Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả.",
          "timeComplexity": "$O(n\\log n)$ hoặc tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": "class Solution { public: int reverseBits(int n) { } };",
            "java": "class Solution { public int reverseBits(int n) { } }",
            "javascript": "/** * @param {number} n * @return {number} */ var reverseBits = function(n) { };",
            "python": "class Solution(object): def reverseBits(self, n): \"\"\" :type n: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "number-of-1-bits",
    "title": "Number of 1 Bits",
    "acceptance": 0.7600344680320341,
    "difficulty": "Easy",
    "likes": 7078,
    "dislikes": 1364,
    "stars": null,
    "tags": [
      "divide-and-conquer",
      "bit-manipulation"
    ],
    "description": "Cho một dương số nguyên n, viết một hàm đó trả về số của tập hợp bits trong nó nhị phân representation (cũng known như Hamming weight).",
    "constraints": [
      "1 <= n <= 231 - 1 Câu hỏi thêm: Nếu điều này hàm là called many lần, làm thế nào sẽ bạn optimize nó?"
    ],
    "examples": [
      {
        "input": "n = 11",
        "output": "3",
        "explanation": "đầu vào nhị phân chuỗi 1011 có một total của ba tập hợp bits."
      },
      {
        "input": "n = 128",
        "output": "1",
        "explanation": "đầu vào nhị phân chuỗi 10000000 có một total của một tập hợp bit."
      },
      {
        "input": "n = 2147483645",
        "output": "30",
        "explanation": "đầu vào nhị phân chuỗi 1111111111111111111111111111101 có một total của thirty tập hợp bits."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int hammingWeight(int n) { } };",
      "java": "class Solution { public int hammingWeight(int n) { } }",
      "javascript": "/** * @param {number} n * @return {number} */ var hammingWeight = function(n) { };",
      "python": "class Solution(object): def hammingWeight(self, n): \"\"\" :type n: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:20 PM UTC+7",
    "editorial": {
      "content": "Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).\n\nGợi ý hướng giải: Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả. Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
      "lastUpdated": "January 13, 2026 at 3:41:20 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Divide and Conquer",
          "description": "Chia bài toán thành các bài toán con, giải độc lập rồi gộp kết quả.",
          "timeComplexity": "$O(n\\log n)$ hoặc tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": "class Solution { public: int hammingWeight(int n) { } };",
            "java": "class Solution { public int hammingWeight(int n) { } }",
            "javascript": "/** * @param {number} n * @return {number} */ var hammingWeight = function(n) { };",
            "python": "class Solution(object): def hammingWeight(self, n): \"\"\" :type n: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "word-frequency",
    "title": "Word Frequency",
    "acceptance": 0.28185027779189653,
    "difficulty": "Medium",
    "likes": 579,
    "dislikes": 311,
    "stars": null,
    "tags": [
      "shell"
    ],
    "description": "Viết một bash script để tính frequency của each word trong một text file words.txt. Cho simplicity sake, Bạn có thể giả sử: words.txt Chỉ chứa chữ thường các ký tự và bộ nhớ ' ' các ký tự. Each word phải consist của chữ thường các ký tự chỉ. Words là separated bởi một hoặc nhiều hơn khoảng trắng các ký tự. Ví dụ: Giả sử đó words.txt có sau đây content: ngày là sunny sunny là là Của bạn script nên đầu ra sau đây, đã sắp xếp bởi giảm dần frequency: 4 là 3 sunny 2 ngày 1 Lưu ý: Don't worry about handling ties, Đảm bảo rằng each word's frequency count là không trùng lặp. Bạn có thể viết nó trong một-đường thẳng using Unix pipes?",
    "constraints": [],
    "examples": [],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:21 PM UTC+7",
    "editorial": {
      "content": "Write a bash script to calculate the frequency of each word in a text file words.txt. For simplicity sake, you may assume: words.txt contains only lowercase characters and space ' ' characters. Each word must consist of lowercase characters only. Words are separated by one or more whitespace characters. Example: Assume that words.txt has the following content: the day is sunny the the the sunny is is Your script should output the following, sorted by descending frequency: the 4 is 3 sunny 2 day 1 Note: Don't worry about handling ties, it is guaranteed that each word's frequency count is unique. Could you write it in one-line using Unix pipes?",
      "lastUpdated": "January 13, 2026 at 3:41:21 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "valid-phone-numbers",
    "title": "Valid Phone Numbers",
    "acceptance": 0.28688423294104226,
    "difficulty": "Easy",
    "likes": 475,
    "dislikes": 981,
    "stars": null,
    "tags": [
      "shell"
    ],
    "description": "Cho một text file file.txt đó chứa một danh sách của phone các số (một per đường thẳng), viết một một-liner bash script để print tất cả hợp lệ phone các số. Bạn có thể giả sử rằng một hợp lệ phone số phải appear trong một của sau đây hai formats: (xxx) xxx-xxxx hoặc xxx-xxx-xxxx. (x means một chữ số) Bạn có thể cũng giả sử each đường thẳng trong text file phải không chứa ở đầu hoặc ở cuối white dấu cách. Ví dụ: Giả sử đó file.txt có sau đây content: 987-123-4567 123 456 7890 (123) 456-7890 Của bạn script nên đầu ra sau đây hợp lệ phone các số: 987-123-4567 (123) 456-7890",
    "constraints": [],
    "examples": [],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:21 PM UTC+7",
    "editorial": {
      "content": "Given a text file file.txt that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers. You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) You may also assume each line in the text file must not contain leading or trailing white spaces. Example: Assume that file.txt has the following content: 987-123-4567 123 456 7890 (123) 456-7890 Your script should output the following valid phone numbers: 987-123-4567 (123) 456-7890",
      "lastUpdated": "January 13, 2026 at 3:41:21 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "transpose-file",
    "title": "Transpose File",
    "acceptance": 0.30173326430155556,
    "difficulty": "Medium",
    "likes": 163,
    "dislikes": 290,
    "stars": null,
    "tags": [
      "shell"
    ],
    "description": "Cho một text file file.txt, transpose nó content. Bạn có thể giả sử rằng each hàng có giống nhau số của các cột, và each field là separated bởi ' ' ký tự. Ví dụ: Nếu file.txt có sau đây content: tên age alice 21 ryan 30 Đầu ra sau đây: tên alice ryan age 21 30",
    "constraints": [],
    "examples": [],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:22 PM UTC+7",
    "editorial": {
      "content": "Given a text file file.txt, transpose its content. You may assume that each row has the same number of columns, and each field is separated by the ' ' character. Example: If file.txt has the following content: name age alice 21 ryan 30 Output the following: name alice ryan age 21 30",
      "lastUpdated": "January 13, 2026 at 3:41:22 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "tenth-line",
    "title": "Tenth Line",
    "acceptance": 0.35832797121136295,
    "difficulty": "Easy",
    "likes": 419,
    "dislikes": 485,
    "stars": null,
    "tags": [
      "shell"
    ],
    "description": "Cho một text file file.txt, print chỉ 10th đường thẳng của file. Ví dụ: Giả sử đó file.txt có sau đây content: Đường thẳng 1 Đường thẳng 2 Đường thẳng 3 Đường thẳng 4 Đường thẳng 5 Đường thẳng 6 Đường thẳng 7 Đường thẳng 8 Đường thẳng 9 Đường thẳng 10 Của bạn script nên đầu ra tenth đường thẳng, nào là: Đường thẳng 10 Lưu ý: 1. Nếu file chứa nhỏ hơn 10 các đường thẳng, điều gì nên bạn đầu ra? 2. There's Ít nhất ba khác nhau các lời giải. Hãy thử explore tất cả possibilities.",
    "constraints": [],
    "examples": [],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:23 PM UTC+7",
    "editorial": {
      "content": "Given a text file file.txt, print just the 10th line of the file. Example: Assume that file.txt has the following content: Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10 Your script should output the tenth line, which is: Line 10 Note: 1. If the file contains less than 10 lines, what should you output? 2. There's at least three different solutions. Try to explore all possibilities.",
      "lastUpdated": "January 13, 2026 at 3:41:23 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "delete-duplicate-emails",
    "title": "Delete Duplicate Emails",
    "acceptance": 0.653946139339784,
    "difficulty": "Easy",
    "likes": 2011,
    "dislikes": 413,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Person +-------------+---------+ | Cột Tên | Type | +-------------+---------+ | id | int | | email | varchar | +-------------+---------+ id là primary khóa (cột với không trùng lặp các giá trị) cho điều này bảng. Each hàng của điều này bảng chứa một email. emails sẽ không chứa chữ hoa các chữ cái. Viết một lời giải để xóa tất cả trùng lặp emails, giữ chỉ một không trùng lặp email với nhỏ nhất id. Cho SQL users, please Lưu ý rằng bạn là supposed để viết một Xóa statement và không một Chọn một. Cho Pandas users, please Lưu ý rằng bạn là supposed để modify Person trong place. Sau running của bạn script, đáp án shown là Person bảng. driver sẽ đầu tiên compile và run của bạn piece của code và thì show Person bảng. final thứ tự của Person bảng không matter. kết quả format là trong sau đây ví dụ.",
    "constraints": [],
    "examples": [
      {
        "input": "Person table: +----+------------------+ | id | email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+------------------+",
        "output": "+----+------------------+ | id | email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | +----+------------------+",
        "explanation": "john@example.com là repeated hai lần. Chúng ta giữ hàng với nhỏ nhất Id = 1."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:24 PM UTC+7",
    "editorial": {
      "content": "Table: Person +-------------+---------+ | Column Name | Type | +-------------+---------+ | id | int | | email | varchar | +-------------+---------+ id is the primary key (column with unique values) for this table. Each row of this table contains an email. The emails will not contain uppercase letters. Write a solution to delete all duplicate emails, keeping only one unique email with the smallest id. For SQL users, please note that you are supposed to write a DELETE statement and not a SELECT one. For Pandas users, please note that you are supposed to modify Person in place. After running your script, the answer shown is the Person table. The driver will first compile and run your piece of code and then show the Person table. The final order of the Person table does not matter. The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:24 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "rising-temperature",
    "title": "Rising Temperature",
    "acceptance": 0.5091728665628189,
    "difficulty": "Easy",
    "likes": 4084,
    "dislikes": 729,
    "stars": null,
    "tags": [
      "database"
    ],
    "description": "Bảng: Weather +---------------+---------+ | Cột Tên | Type | +---------------+---------+ | id | int | | recordDate | date | | temperature | int | +---------------+---------+ id là cột với không trùng lặp các giá trị cho điều này bảng. Có không khác nhau các hàng với giống nhau recordDate. Điều này bảng chứa information about temperature trên một certain ngày. Viết một lời giải để tìm tất cả dates' id với higher temperatures compared để nó previous dates (yesterday). Trả về kết quả bảng Theo bất kỳ thứ tự nào. kết quả format là trong sau đây ví dụ.",
    "constraints": [],
    "examples": [
      {
        "input": "Weather table: +----+------------+-------------+ | id | recordDate | temperature | +----+------------+-------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +----+------------+-------------+",
        "output": "+----+ | id | +----+ | 2 | | 4 | +----+",
        "explanation": "Trong 2015-01-02, temperature là higher hơn previous ngày (10 -> 25). Trong 2015-01-04, temperature là higher hơn previous ngày (20 -> 30)."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": null,
      "java": null,
      "javascript": null,
      "python": null
    },
    "createdAt": "January 13, 2026 at 3:41:24 PM UTC+7",
    "editorial": {
      "content": "Table: Weather +---------------+---------+ | Column Name | Type | +---------------+---------+ | id | int | | recordDate | date | | temperature | int | +---------------+---------+ id is the column with unique values for this table. There are no different rows with the same recordDate. This table contains information about the temperature on a certain day. Write a solution to find all dates' id with higher temperatures compared to its previous dates (yesterday). Return the result table in any order. The result format is in the following example.",
      "lastUpdated": "January 13, 2026 at 3:41:24 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "General Approach",
          "description": "Triển khai theo hướng tiếp cận tổng quát phù hợp với tags.",
          "timeComplexity": "Tùy bài",
          "spaceComplexity": "Tùy bài",
          "code": {
            "cpp": null,
            "java": null,
            "javascript": null,
            "python": null
          }
        }
      ]
    }
  },
  {
    "id": "house-robber",
    "title": "House Robber",
    "acceptance": 0.5282673044312444,
    "difficulty": "Medium",
    "likes": 23149,
    "dislikes": 502,
    "stars": null,
    "tags": [
      "array",
      "dynamic-programming"
    ],
    "description": "Bạn là một professional robber planning để rob houses along một street. Each house có một certain lượng của money stashed, chỉ constraint dừng bạn từ robbing each của chúng là đó kề nhau houses có security systems connected và nó sẽ automatically contact police nếu hai kề nhau houses là broken thành trên giống nhau night. Cho một số nguyên mảng nums biểu diễn lượng của money của each house, trả về lớn nhất lượng của money Bạn có thể rob tonight không alerting police.",
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "4",
        "explanation": "Rob house 1 (money = 1) và thì rob house 3 (money = 3). Total lượng Bạn có thể rob = 1 + 3 = 4."
      },
      {
        "input": "nums = [2,7,9,3,1]",
        "output": "12",
        "explanation": "Rob house 1 (money = 2), rob house 3 (money = 9) và rob house 5 (money = 1). Total lượng Bạn có thể rob = 2 + 9 + 1 = 12."
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int rob(vector<int>& nums) { } };",
      "java": "class Solution { public int rob(int[] nums) { } }",
      "javascript": "/** * @param {number[]} nums * @return {number} */ var rob = function(nums) { };",
      "python": "class Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:25 PM UTC+7",
    "editorial": {
      "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\nGợi ý hướng giải: Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
      "lastUpdated": "January 13, 2026 at 3:41:25 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Dynamic Programming",
          "description": "Dùng quy hoạch động: định nghĩa trạng thái, công thức chuyển, và tính dần từ nhỏ đến lớn.",
          "timeComplexity": "$O(n^2)$ hoặc $O(n\\cdot m)$",
          "spaceComplexity": "$O(n)$ hoặc $O(n\\cdot m)$",
          "code": {
            "cpp": "class Solution { public: int rob(vector<int>& nums) { } };",
            "java": "class Solution { public int rob(int[] nums) { } }",
            "javascript": "/** * @param {number[]} nums * @return {number} */ var rob = function(nums) { };",
            "python": "class Solution(object): def rob(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "binary-tree-right-side-view",
    "title": "Binary Tree Right Side View",
    "acceptance": 0.6910054332959601,
    "difficulty": "Medium",
    "likes": 13241,
    "dislikes": 1082,
    "stars": null,
    "tags": [
      "tree",
      "depth-first-search",
      "breadth-first-search",
      "binary-tree"
    ],
    "description": "Cho root của một cây nhị phân, imagine yourself standing trên right side của nó, trả về các giá trị của các nút Bạn có thể see thứ tự từ top để dưới cùng.",
    "constraints": [
      "số của các nút trong cây là Trong khoảng [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "examples": [
      {
        "input": "root = [1,2,3,null,5,null,4]",
        "output": "[1,3,4]",
        "explanation": ""
      },
      {
        "input": "root = [1,2,3,4,null,null,null,5]",
        "output": "[1,3,4,5]",
        "explanation": ""
      },
      {
        "input": "root = [1,null,3]",
        "output": "[1,3]",
        "explanation": ""
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> rightSideView(TreeNode* root) { } };",
      "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<Integer> rightSideView(TreeNode root) { } }",
      "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var rightSideView = function(root) { };",
      "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def rightSideView(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[int] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:26 PM UTC+7",
    "editorial": {
      "content": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n\nGợi ý hướng giải: Duyệt cây bằng DFS/BFS, tính toán theo nút (đệ quy hoặc dùng stack/queue). Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần.",
      "lastUpdated": "January 13, 2026 at 3:41:26 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector<int> rightSideView(TreeNode* root) { } };",
            "java": "/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List<Integer> rightSideView(TreeNode root) { } }",
            "javascript": "/** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var rightSideView = function(root) { };",
            "python": "# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def rightSideView(self, root): \"\"\" :type root: Optional[TreeNode] :rtype: List[int] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "number-of-islands",
    "title": "Number of Islands",
    "acceptance": 0.6355533004322947,
    "difficulty": "Medium",
    "likes": 24626,
    "dislikes": 604,
    "stars": null,
    "tags": [
      "array",
      "depth-first-search",
      "breadth-first-search",
      "union-find",
      "matrix"
    ],
    "description": "Cho một m x n 2D nhị phân grid grid nào biểu diễn một bản đồ của '1's (land) và '0's (nước), trả về số của islands. Một island là surrounded bởi nước và là tạo thành bởi connecting kề nhau lands horizontally hoặc thẳng đứng. Bạn có thể giả sử tất cả bốn các cạnh của grid là tất cả surrounded bởi nước.",
    "constraints": [
      "m == grid.length n == grid[i].độ dài",
      "1 <= m, n <= 300 grid[i][j] là '0' hoặc '1'."
    ],
    "examples": [
      {
        "input": "grid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"] ]",
        "output": "1",
        "explanation": ""
      },
      {
        "input": "grid = [ [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"1\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"1\",\"1\"] ]",
        "output": "3",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int numIslands(vector<vector<char>>& grid) { } };",
      "java": "class Solution { public int numIslands(char[][] grid) { } }",
      "javascript": "/** * @param {character[][]} grid * @return {number} */ var numIslands = function(grid) { };",
      "python": "class Solution(object): def numIslands(self, grid): \"\"\" :type grid: List[List[str]] :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:27 PM UTC+7",
    "editorial": {
      "content": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\nGợi ý hướng giải: Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần. Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
      "lastUpdated": "January 13, 2026 at 3:41:27 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS",
          "description": "Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "class Solution { public: int numIslands(vector<vector<char>>& grid) { } };",
            "java": "class Solution { public int numIslands(char[][] grid) { } }",
            "javascript": "/** * @param {character[][]} grid * @return {number} */ var numIslands = function(grid) { };",
            "python": "class Solution(object): def numIslands(self, grid): \"\"\" :type grid: List[List[str]] :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "bitwise-and-of-numbers-range",
    "title": "Bitwise AND of Numbers Range",
    "acceptance": 0.4851556225882906,
    "difficulty": "Medium",
    "likes": 4238,
    "dislikes": 318,
    "stars": null,
    "tags": [
      "bit-manipulation"
    ],
    "description": "Cho hai các số nguyên left và right đó biểu diễn khoảng [left, right], trả về bitwise Và của tất cả các số trong điều này khoảng, inclusive.",
    "constraints": [
      "0 <= left <= right <= 231 - 1"
    ],
    "examples": [
      {
        "input": "left = 5, right = 7",
        "output": "4",
        "explanation": ""
      },
      {
        "input": "left = 0, right = 0",
        "output": "0",
        "explanation": ""
      },
      {
        "input": "left = 1, right = 2147483647",
        "output": "0",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: int rangeBitwiseAnd(int left, int right) { } };",
      "java": "class Solution { public int rangeBitwiseAnd(int left, int right) { } }",
      "javascript": "/** * @param {number} left * @param {number} right * @return {number} */ var rangeBitwiseAnd = function(left, right) { };",
      "python": "class Solution(object): def rangeBitwiseAnd(self, left, right): \"\"\" :type left: int :type right: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:30 PM UTC+7",
    "editorial": {
      "content": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n\nGợi ý hướng giải: Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
      "lastUpdated": "January 13, 2026 at 3:41:30 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Bit Manipulation",
          "description": "Khai thác phép toán bit (AND/OR/XOR/shift) để tối ưu thời gian/bộ nhớ.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int rangeBitwiseAnd(int left, int right) { } };",
            "java": "class Solution { public int rangeBitwiseAnd(int left, int right) { } }",
            "javascript": "/** * @param {number} left * @param {number} right * @return {number} */ var rangeBitwiseAnd = function(left, right) { };",
            "python": "class Solution(object): def rangeBitwiseAnd(self, left, right): \"\"\" :type left: int :type right: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "happy-number",
    "title": "Happy Number",
    "acceptance": 0.5905300742132124,
    "difficulty": "Easy",
    "likes": 11711,
    "dislikes": 1621,
    "stars": null,
    "tags": [
      "hash-table",
      "math",
      "two-pointers"
    ],
    "description": "Viết một thuật toán để xác định nếu một số n là happy. Một happy số là một số defined bởi sau đây process: Bắt đầu với bất kỳ dương số nguyên, thay thế số bởi tổng của squares của nó các chữ số. Repeat process cho đến khi số bằng 1 (ở đâu nó sẽ stay), hoặc nó loops endlessly trong một cycle nào không include 1. Những các số cho nào điều này process kết thúc trong 1 là happy. Trả về đúng nếu n là một happy số, và sai nếu không.",
    "constraints": [
      "1 <= n <= 231 - 1"
    ],
    "examples": [
      {
        "input": "n = 19",
        "output": "true",
        "explanation": "12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1"
      },
      {
        "input": "n = 2",
        "output": "false",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool isHappy(int n) { } };",
      "java": "class Solution { public boolean isHappy(int n) { } }",
      "javascript": "/** * @param {number} n * @return {boolean} */ var isHappy = function(n) { };",
      "python": "class Solution(object): def isHappy(self, n): \"\"\" :type n: int :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:31 PM UTC+7",
    "editorial": {
      "content": "Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. Return true if n is a happy number, and false if not.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
      "lastUpdated": "January 13, 2026 at 3:41:31 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: bool isHappy(int n) { } };",
            "java": "class Solution { public boolean isHappy(int n) { } }",
            "javascript": "/** * @param {number} n * @return {boolean} */ var isHappy = function(n) { };",
            "python": "class Solution(object): def isHappy(self, n): \"\"\" :type n: int :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "remove-linked-list-elements",
    "title": "Remove Linked List Elements",
    "acceptance": 0.5353149355044576,
    "difficulty": "Easy",
    "likes": 8929,
    "dislikes": 285,
    "stars": null,
    "tags": [
      "linked-list",
      "recursion"
    ],
    "description": "Cho head của một danh sách liên kết và một số nguyên val, loại bỏ tất cả các nút của danh sách liên kết đó có Node.val == val, và trả về new head.",
    "constraints": [
      "số của các nút trong danh sách là Trong khoảng [0, 104].",
      "1 <= Node.val <= 50",
      "0 <= val <= 50"
    ],
    "examples": [
      {
        "input": "head = [1,2,6,3,4,5,6], val = 6",
        "output": "[1,2,3,4,5]",
        "explanation": ""
      },
      {
        "input": "head = [], val = 1",
        "output": "[]",
        "explanation": ""
      },
      {
        "input": "head = [7,7,7,7], val = 7",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeElements(ListNode* head, int val) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} val * @return {ListNode} */ var removeElements = function(head, val) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def removeElements(self, head, val): \"\"\" :type head: Optional[ListNode] :type val: int :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:32 PM UTC+7",
    "editorial": {
      "content": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng đệ quy để biểu diễn bài toán con; có thể kết hợp memoization để tránh lặp.",
      "lastUpdated": "January 13, 2026 at 3:41:32 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers trên Linked List",
          "description": "Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeElements(ListNode* head, int val) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @param {number} val * @return {ListNode} */ var removeElements = function(head, val) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def removeElements(self, head, val): \"\"\" :type head: Optional[ListNode] :type val: int :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "count-primes",
    "title": "Count Primes",
    "acceptance": 0.3561848098680523,
    "difficulty": "Medium",
    "likes": 8694,
    "dislikes": 1570,
    "stars": null,
    "tags": [
      "array",
      "math",
      "enumeration",
      "number-theory"
    ],
    "description": "Cho một số nguyên n, trả về số của prime các số đó là strictly nhỏ hơn n.",
    "constraints": [
      "0 <= n <= 5 * 106"
    ],
    "examples": [
      {
        "input": "n = 10",
        "output": "4",
        "explanation": "Có 4 prime các số nhỏ hơn 10, họ là 2, 3, 5, 7."
      },
      {
        "input": "n = 0",
        "output": "0",
        "explanation": ""
      },
      {
        "input": "n = 1",
        "output": "0",
        "explanation": ""
      }
    ],
    "content": "Kiểm tra tất cả các số nguyên Trong khoảng [1, n - 1] là không hiệu quả. Think about một better approach. Vì nhiều nhất của các số là không primes, chúng ta need một nhanh approach để exclude không-prime các số nguyên. Dùng Sieve của Eratosthenes.",
    "defaultCode": {
      "cpp": "class Solution { public: int countPrimes(int n) { } };",
      "java": "class Solution { public int countPrimes(int n) { } }",
      "javascript": "/** * @param {number} n * @return {number} */ var countPrimes = function(n) { };",
      "python": "class Solution(object): def countPrimes(self, n): \"\"\" :type n: int :rtype: int \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:33 PM UTC+7",
    "editorial": {
      "content": "Given an integer n, return the number of prime numbers that are strictly less than n.\n\nHint/nhắc ý (crawl được): Checking all the integers in the range [1, n - 1] is not efficient. Think about a better approach. Since most of the numbers are not primes, we need a fast approach to exclude the non-prime integers. Use Sieve of Eratosthenes.\n\nGợi ý hướng giải: Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
      "lastUpdated": "January 13, 2026 at 3:41:33 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Math / Simulation",
          "description": "Phân tích toán học và mô phỏng cẩn thận; chú ý tràn số và biên.",
          "timeComplexity": "$O(n)$ hoặc $O(1)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "class Solution { public: int countPrimes(int n) { } };",
            "java": "class Solution { public int countPrimes(int n) { } }",
            "javascript": "/** * @param {number} n * @return {number} */ var countPrimes = function(n) { };",
            "python": "class Solution(object): def countPrimes(self, n): \"\"\" :type n: int :rtype: int \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "isomorphic-strings",
    "title": "Isomorphic Strings",
    "acceptance": 0.47820900628176316,
    "difficulty": "Easy",
    "likes": 10313,
    "dislikes": 2268,
    "stars": null,
    "tags": [
      "hash-table",
      "string"
    ],
    "description": "Cho hai các chuỗi s và t, xác định nếu họ là isomorphic. Hai các chuỗi s và t là isomorphic nếu các ký tự trong s có thể là replaced để get t. Tất cả occurrences của một ký tự phải là replaced với another ký tự trong khi preserving thứ tự của các ký tự. Không hai các ký tự có thể bản đồ để giống nhau ký tự, but một ký tự có thể bản đồ để chính nó.",
    "constraints": [
      "1 <= s.length <= 5 * 104 t.length == s.length s và t consist của bất kỳ hợp lệ ascii ký tự."
    ],
    "examples": [
      {
        "input": "s = \"egg\", t = \"add\"",
        "output": "true",
        "explanation": "các chuỗi s và t có thể là made identical bởi: Bản đồ 'e' để 'một'. Bản đồ 'g' để 'd'."
      },
      {
        "input": "s = \"foo\", t = \"bar\"",
        "output": "false",
        "explanation": "các chuỗi s và t có thể không là made identical như 'o' needs để là bản đồ để both 'một' và 'r'."
      },
      {
        "input": "s = \"paper\", t = \"title\"",
        "output": "true",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "class Solution { public: bool isIsomorphic(string s, string t) { } };",
      "java": "class Solution { public boolean isIsomorphic(String s, String t) { } }",
      "javascript": "/** * @param {string} s * @param {string} t * @return {boolean} */ var isIsomorphic = function(s, t) { };",
      "python": "class Solution(object): def isIsomorphic(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:34 PM UTC+7",
    "editorial": {
      "content": "Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:41:34 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Solution { public: bool isIsomorphic(string s, string t) { } };",
            "java": "class Solution { public boolean isIsomorphic(String s, String t) { } }",
            "javascript": "/** * @param {string} s * @param {string} t * @return {boolean} */ var isIsomorphic = function(s, t) { };",
            "python": "class Solution(object): def isIsomorphic(self, s, t): \"\"\" :type s: str :type t: str :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "reverse-linked-list",
    "title": "Reverse Linked List",
    "acceptance": 0.8008649804636275,
    "difficulty": "Easy",
    "likes": 24087,
    "dislikes": 564,
    "stars": null,
    "tags": [
      "linked-list",
      "recursion"
    ],
    "description": "Cho head của một singly danh sách liên kết, đảo ngược danh sách, và trả về được đảo ngược danh sách.",
    "constraints": [
      "số của các nút trong danh sách là khoảng [0, 5000].",
      "-5000 <= Node.val <= 5000 Câu hỏi thêm: Một danh sách liên kết có thể là được đảo ngược một trong hai iteratively hoặc recursively. Bạn có thể cài đặt both?"
    ],
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]",
        "explanation": ""
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1]",
        "explanation": ""
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": ""
      }
    ],
    "content": "",
    "defaultCode": {
      "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { } };",
      "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { } }",
      "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { };",
      "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def reverseList(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:34 PM UTC+7",
    "editorial": {
      "content": "Given the head of a singly linked list, reverse the list, and return the reversed list.\n\nGợi ý hướng giải: Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ. Dùng đệ quy để biểu diễn bài toán con; có thể kết hợp memoization để tránh lặp.",
      "lastUpdated": "January 13, 2026 at 3:41:34 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Two Pointers trên Linked List",
          "description": "Dùng con trỏ để duyệt và thao tác nút; hay dùng fast/slow cho bài toán khoảng cách/chu kỳ.",
          "timeComplexity": "$O(n)$",
          "spaceComplexity": "$O(1)$",
          "code": {
            "cpp": "/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { } };",
            "java": "/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { } }",
            "javascript": "/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {ListNode} */ var reverseList = function(head) { };",
            "python": "# Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def reverseList(self, head): \"\"\" :type head: Optional[ListNode] :rtype: Optional[ListNode] \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "course-schedule",
    "title": "Course Schedule",
    "acceptance": 0.505539415506845,
    "difficulty": "Medium",
    "likes": 17728,
    "dislikes": 854,
    "stars": null,
    "tags": [
      "depth-first-search",
      "breadth-first-search",
      "graph",
      "topological-sort"
    ],
    "description": "Có một total của numCourses các khóa học bạn có để take, labeled từ 0 để numCourses - 1. Bạn được cho một mảng prerequisites ở đâu prerequisites[i] = [ai, bi] indicates đó bạn phải take khóa học bi đầu tiên nếu bạn want để take khóa học ai. Ví dụ, cặp [0, 1], indicates đó để take khóa học 0 bạn có để đầu tiên take khóa học 1. Trả về đúng nếu Bạn có thể kết thúc tất cả các khóa học. Otherwise, trả về sai.",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000 prerequisites[i].độ dài == 2",
      "0 <= ai, bi < numCourses Tất cả các cặp prerequisites[i] là không trùng lặp."
    ],
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1,0]]",
        "output": "true",
        "explanation": "Có một total của 2 các khóa học để take. Để take khóa học 1 bạn nên có kết thúc khóa học 0. Vì vậy nó là có thể."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "false",
        "explanation": "Có một total của 2 các khóa học để take. Để take khóa học 1 bạn nên có kết thúc khóa học 0, và để take khóa học 0 bạn nên cũng có kết thúc khóa học 1. Vì vậy nó là impossible."
      }
    ],
    "content": "Điều này problem là equivalent để tìm nếu một cycle tồn tại trong một directed đồ thị. Nếu một cycle tồn tại, không topological thứ tự tồn tại và do đó nó sẽ là impossible để take tất cả các khóa học. <a href=\"https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/03Graphs.pdf\" target=\"_blank\">Topological Sắp xếp via DFS</a> - Một great tutorial explaining basic concepts của Topological Sắp xếp. Topological sắp xếp có thể cũng là done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>.",
    "defaultCode": {
      "cpp": "class Solution { public: bool canFinish(int numCourses, vector<vector<int>>& prerequisites) { } };",
      "java": "class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { } }",
      "javascript": "/** * @param {number} numCourses * @param {number[][]} prerequisites * @return {boolean} */ var canFinish = function(numCourses, prerequisites) { };",
      "python": "class Solution(object): def canFinish(self, numCourses, prerequisites): \"\"\" :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool \"\"\""
    },
    "createdAt": "January 13, 2026 at 3:41:35 PM UTC+7",
    "editorial": {
      "content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return true if you can finish all courses. Otherwise, return false.\n\nHint/nhắc ý (crawl được): This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses. <a href=\"https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/03Graphs.pdf\" target=\"_blank\">Topological Sort via DFS</a> - A great tutorial explaining the basic concepts of Topological Sort. Topological sort could also be done via <a href=\"http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\" target=\"_blank\">BFS</a>.\n\nGợi ý hướng giải: Duyệt theo chiều sâu (recursion/stack) để thăm toàn bộ cấu trúc và backtrack khi cần. Duyệt theo lớp (queue), phù hợp tìm đường đi ngắn trên đồ thị không trọng số.",
      "lastUpdated": "January 13, 2026 at 3:41:35 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "BFS/DFS (Graph Traversal)",
          "description": "Mô hình hóa thành đồ thị và duyệt BFS/DFS để tìm thành phần liên thông/đường đi/trạng thái.",
          "timeComplexity": "$O(V+E)$",
          "spaceComplexity": "$O(V)$",
          "code": {
            "cpp": "class Solution { public: bool canFinish(int numCourses, vector<vector<int>>& prerequisites) { } };",
            "java": "class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { } }",
            "javascript": "/** * @param {number} numCourses * @param {number[][]} prerequisites * @return {boolean} */ var canFinish = function(numCourses, prerequisites) { };",
            "python": "class Solution(object): def canFinish(self, numCourses, prerequisites): \"\"\" :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool \"\"\""
          }
        }
      ]
    }
  },
  {
    "id": "implement-trie-prefix-tree",
    "title": "Implement Trie (Prefix Tree)",
    "acceptance": 0.6899138119391705,
    "difficulty": "Medium",
    "likes": 12331,
    "dislikes": 160,
    "stars": null,
    "tags": [
      "hash-table",
      "string",
      "design",
      "trie"
    ],
    "description": "Một Trie (phát âm như \"try\") hoặc cây tiền tố là một cấu trúc dữ liệu dạng cây được dùng để hiệu quả lưu và retrieve khóa trong một dataset của các chuỗi. Có various các ứng dụng của điều này cấu trúc dữ liệu, such như tự động hoàn thành và kiểm tra chính tả. Cài đặt Trie lớp: Trie() Khởi tạo Trie đối tượng. void chèn(Chuỗi word) Chèn chuỗi word thành Trie. boolean tìm kiếm(Chuỗi word) Trả về đúng nếu chuỗi word là trong Trie (i.e., là chèn trước), và sai otherwise. boolean startsWith(Chuỗi tiền tố) Trả về đúng nếu Có một trước đó chèn chuỗi word đó có tiền tố tiền tố, và sai otherwise.",
    "constraints": [
      "1 <= word.length, prefix.length <= 2000 word và tiền tố consist chỉ của chữ thường Tiếng Anh các chữ cái. Nhiều nhất 3 * 104 calls trong total sẽ là made để chèn, tìm kiếm, và startsWith."
    ],
    "examples": [],
    "content": "",
    "defaultCode": {
      "cpp": "class Trie { public: Trie() { } void insert(string word) { } bool search(string word) { } bool startsWith(string prefix) { } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_2 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */",
      "java": "class Trie { public Trie() { } public void insert(String word) { } public boolean search(String word) { } public boolean startsWith(String prefix) { } } /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */",
      "javascript": "var Trie = function() { }; /** * @param {string} word * @return {void} */ Trie.prototype.insert = function(word) { }; /** * @param {string} word * @return {boolean} */ Trie.prototype.search = function(word) { }; /** * @param {string} prefix * @return {boolean} */ Trie.prototype.startsWith = function(prefix) { }; /** * Your Trie object will be instantiated and called as such: * var obj = new Trie() * obj.insert(word) * var param_2 = obj.search(word) * var param_3 = obj.startsWith(prefix) */",
      "python": "class Trie(object): def __init__(self): def insert(self, word): \"\"\" :type word: str :rtype: None \"\"\" def search(self, word): \"\"\" :type word: str :rtype: bool \"\"\" def startsWith(self, prefix): \"\"\" :type prefix: str :rtype: bool \"\"\" # Your Trie object will be instantiated and called as such: # obj = Trie() # obj.insert(word) # param_2 = obj.search(word) # param_3 = obj.startsWith(prefix)"
    },
    "createdAt": "January 13, 2026 at 3:41:35 PM UTC+7",
    "editorial": {
      "content": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n\nGợi ý hướng giải: Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1). Xử lý chuỗi bằng quét tuyến tính, đếm, hoặc pattern matching tùy yêu cầu.",
      "lastUpdated": "January 13, 2026 at 3:41:35 PM UTC+7",
      "videoUrl": null,
      "approaches": [
        {
          "name": "Hash Map / Hash Set",
          "description": "Dùng bảng băm để lưu/truy vấn trạng thái đã gặp trong thời gian trung bình O(1).",
          "timeComplexity": "$O(n)$ trung bình",
          "spaceComplexity": "$O(n)$",
          "code": {
            "cpp": "class Trie { public: Trie() { } void insert(string word) { } bool search(string word) { } bool startsWith(string prefix) { } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_2 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */",
            "java": "class Trie { public Trie() { } public void insert(String word) { } public boolean search(String word) { } public boolean startsWith(String prefix) { } } /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */",
            "javascript": "var Trie = function() { }; /** * @param {string} word * @return {void} */ Trie.prototype.insert = function(word) { }; /** * @param {string} word * @return {boolean} */ Trie.prototype.search = function(word) { }; /** * @param {string} prefix * @return {boolean} */ Trie.prototype.startsWith = function(prefix) { }; /** * Your Trie object will be instantiated and called as such: * var obj = new Trie() * obj.insert(word) * var param_2 = obj.search(word) * var param_3 = obj.startsWith(prefix) */",
            "python": "class Trie(object): def __init__(self): def insert(self, word): \"\"\" :type word: str :rtype: None \"\"\" def search(self, word): \"\"\" :type word: str :rtype: bool \"\"\" def startsWith(self, prefix): \"\"\" :type prefix: str :rtype: bool \"\"\" # Your Trie object will be instantiated and called as such: # obj = Trie() # obj.insert(word) # param_2 = obj.search(word) # param_3 = obj.startsWith(prefix)"
          }
        }
      ]
    }
  }
]