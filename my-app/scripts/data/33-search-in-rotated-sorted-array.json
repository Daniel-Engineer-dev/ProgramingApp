{
  "id": "33-search-in-rotated-sorted-array",
  "title": "Search in Rotated Sorted Array",
  "difficulty": "Medium",
  "acceptance": 0.43,
  "tags": [
    "array",
    "binary-search"
  ],
  "constraints": [
    "1 <= nums.length <= 10^4",
    "-10^4 <= nums[i] <= 10^4",
    "nums chứa các số nguyên duy nhất.",
    "nums ban đầu được sắp xếp theo thứ tự tăng dần, sau đó được xoay một số lần."
  ],
  "description": "Cho một mảng số nguyên đã được xoay (rotated) từ một mảng đã được sắp xếp tăng dần và một số nguyên target, hãy tìm vị trí của target trong mảng đã xoay. Nếu target không tồn tại trong mảng, trả về -1.",
  "defaultCode": {
    "cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};",
    "java": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}",
    "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        ",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    \n};"
  },
  "driverCodes": {
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// __USER_CODE_HERE__\n\nint main() {\n    int n, target;\n    cin >> n;\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) cin >> nums[i];\n    cin >> target;\n    Solution sol;\n    cout << sol.search(nums, target);\n    return 0;\n}",
    "python": "import sys\nfrom typing import List\n\n# __USER_CODE_HERE__\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().splitlines()\n    if len(input_data) < 2: sys.exit(0)\n    nums = list(map(int, input_data[0].split()))\n    target = int(input_data[1])\n    sol = Solution()\n    print(sol.search(nums, target))",
    "java": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNextLine()) return;\n        String[] parts = sc.nextLine().split(\"\\\\s+\");\n        int[] nums = new int[parts.length];\n        for (int i = 0; i < parts.length; i++) nums[i] = Integer.parseInt(parts[i]);\n        if (!sc.hasNextInt()) return;\n        int target = sc.nextInt();\n        \n        Solution sol = new Solution();\n        System.out.print(sol.search(nums, target));\n    }\n}\n\n// __USER_CODE_HERE__",
    "javascript": "const fs = require('fs');\n\n// Định nghĩa một class rỗng để tránh lỗi ReferenceError nếu người dùng không dùng class\nclass Solution {}\n\n// __USER_CODE_HERE__\n\ntry {\n    const input = fs.readFileSync(0, 'utf8').split('\\n');\n    if (input.length < 2) process.exit(0);\n\n    const nums = input[0].trim().split(/\\s+/).map(Number);\n    const target = parseInt(input[1]);\n\n    const sol = new Solution();\n    // Kiểm tra xem hàm search nằm ở global (var/function) hay nằm trong class Solution\n    const fn = (typeof search === 'function') ? search : (sol.search ? sol.search.bind(sol) : null);\n\n    if (typeof fn === 'function') {\n        const res = fn(nums, target);\n        process.stdout.write(res.toString());\n    } else {\n        console.error(\"Error: function search not found.\");\n    }\n} catch (e) {\n    console.error(e);\n}"
  },
  "testCases": [
    {
      "input": "4 5 6 7 0 1 2\n0",
      "expected": "4",
      "isHidden": false
    },
    {
      "input": "1\n0",
      "expected": "-1",
      "isHidden": false
    },
    {
      "input": "3 1\n1",
      "expected": "1",
      "isHidden": true
    }
  ],
  "examples": [
    {
      "input": "nums = [4,5,6,7,0,1,2], target = 0",
      "output": "4",
      "explanation": "Vì 0 nằm ở vị trí thứ 4 trong mảng đã xoay."
    },
    {
      "input": "nums = [1], target = 0",
      "output": "-1",
      "explanation": "Vì 0 không tồn tại trong mảng."
    },
    {
      "input": "nums = [3,1], target = 1",
      "output": "1",
      "explanation": "Vì 1 nằm ở vị trí thứ 1 trong mảng đã xoay."
    }
  ],
  "editorial": {
    "approaches": [
      {
        "name": "Modified Binary Search",
        "description": "Thực hiện tìm kiếm nhị phân trên mảng đã xoay, nhưng cần xác định phần nào của mảng vẫn được sắp xếp để áp dụng tìm kiếm nhị phân.",
        "timeComplexity": "$O(log n)$",
        "spaceComplexity": "$O(1)$",
        "code": {
          "cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) return mid;\n            // Nếu phần bên trái được sắp xếp\n            if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } // Nếu phần bên phải được sắp xếp\n            else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n};",
          "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            # Nếu phần bên trái được sắp xếp\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # Nếu phần bên phải được sắp xếp\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1",
          "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        if (nums[mid] === target) return mid;\n        // Nếu phần bên trái được sắp xếp\n        if (nums[left] <= nums[mid]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } // Nếu phần bên phải được sắp xếp\n        else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n};",
          "java": "class Solution {\n    public int search(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) return mid;\n            // Nếu phần bên trái được sắp xếp\n            if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } // Nếu phần bên phải được sắp xếp\n            else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n}"
        }
      }
    ],
    "videoUrl": "https://youtube.com/watch?v=U8XENwh8Oy8",
    "content": "Bài toán yêu cầu tìm kiếm một phần tử trong mảng đã xoay. Mảng ban đầu được sắp xếp tăng dần, sau đó được xoay một số lần. Sử dụng tìm kiếm nhị phân có thể giải quyết vấn đề này một cách hiệu quả."
  }
}