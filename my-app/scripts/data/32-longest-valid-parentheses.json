{
  "id": "32-longest-valid-parentheses",
  "title": "Longest Valid Parentheses",
  "difficulty": "Hard",
  "acceptance": 0.28,
  "tags": [
    "string",
    "dynamic-programming"
  ],
  "constraints": [
    "1 <= s.length <= 10^3",
    "s[i] == '(' hoặc s[i] == ')'"
  ],
  "description": "Cho một chuỗi các dấu ngoặc đơn s, hãy tìm độ dài của dãy dấu ngoặc đơn hợp lệ dài nhất.",
  "defaultCode": {
    "cpp": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        \n    }\n};",
    "java": "class Solution {\n    public int longestValidParentheses(String s) {\n        \n    }\n}",
    "python": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        ",
    "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function(s) {\n    \n};"
  },
  "driverCodes": {
    "cpp": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// __USER_CODE_HERE__\n\nint main() {\n    string s;\n    getline(cin, s);\n    Solution sol;\n    cout << sol.longestValidParentheses(s);\n    return 0;\n}",
    "python": "import sys\n\nclass Solution:\n    # __USER_CODE_HERE__\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    sol = Solution()\n    print(sol.longestValidParentheses(input_data))",
    "java": "import java.util.Scanner;\n\nclass Solution {\n    // __USER_CODE_HERE__\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n        Solution sol = new Solution();\n        System.out.println(sol.longestValidParentheses(s));\n    }\n}",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.on('line', (input) => {\n    const s = input.trim();\n    const sol = new Solution();\n    console.log(sol.longestValidParentheses(s));\n});\n\nclass Solution {\n    // __USER_CODE_HERE__\n}"
  },
  "testCases": [
    {
      "input": "(()",
      "expected": "2",
      "isHidden": false
    },
    {
      "input": ")()())",
      "expected": "4",
      "isHidden": false
    },
    {
      "input": "",
      "expected": "0",
      "isHidden": true
    }
  ],
  "examples": [
    {
      "input": "s = \"(()\"",
      "output": "2",
      "explanation": "Dãy dấu ngoặc đơn hợp lệ dài nhất là \"()\"."
    },
    {
      "input": "s = \")()())\"",
      "output": "4",
      "explanation": "Dãy dấu ngoặc đơn hợp lệ dài nhất là \"()()\"."
    },
    {
      "input": "s = \"\"",
      "output": "0",
      "explanation": "Không có dãy dấu ngoặc đơn hợp lệ."
    }
  ],
  "editorial": {
    "approaches": [
      {
        "name": "Động (Dynamic Programming)",
        "description": "Sử dụng mảng dp để lưu trữ độ dài của dãy dấu ngoặc đơn hợp lệ dài nhất kết thúc tại mỗi vị trí.",
        "timeComplexity": "$O(n)$",
        "spaceComplexity": "$O(n)$",
        "code": {
          "cpp": "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.size();\n        vector<int> dp(n, 0);\n        int maxLen = 0;\n        for (int i = 1; i < n; i++) {\n            if (s[i] == ')') {\n                if (s[i - 1] == '(') {\n                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {\n                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                }\n                maxLen = max(maxLen, dp[i]);\n            }\n        }\n        return maxLen;\n    }\n};",
          "python": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * n\n        max_len = 0\n        for i in range(1, n):\n            if s[i] == ')':\n                if s[i - 1] == '(':\n                    dp[i] = dp[i - 2] + 2 if i >= 2 else 2\n                elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(': \n                    dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2 if i - dp[i - 1] >= 2 else dp[i - 1] + 2\n                max_len = max(max_len, dp[i])\n        return max_len",
          "javascript": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function(s) {\n    const n = s.length;\n    const dp = new Array(n).fill(0);\n    let maxLen = 0;\n    for (let i = 1; i < n; i++) {\n        if (s[i] === ')') {\n            if (s[i - 1] === '(') {\n                dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n            } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] === '(') {\n                dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n            }\n            maxLen = Math.max(maxLen, dp[i]);\n        }\n    }\n    return maxLen;\n};",
          "java": "class Solution {\n    public int longestValidParentheses(String s) {\n        int n = s.length();\n        int[] dp = new int[n];\n        int maxLen = 0;\n        for (int i = 1; i < n; i++) {\n            if (s.charAt(i) == ')') {\n                if (s.charAt(i - 1) == '(') {\n                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {\n                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                }\n                maxLen = Math.max(maxLen, dp[i]);\n            }\n        }\n        return maxLen;\n    }\n}"
        }
      }
    ],
    "videoUrl": "https://youtube.com/watch?v=q56S5NIqjdE"
  },
  "videoUrl": "https://www.youtube.com/watch?v=V7ZQLGl6vZ8",
  "content": "Bài toán này có thể được giải quyết bằng cách sử dụng động (Dynamic Programming). Ý tưởng là sử dụng mảng dp để lưu trữ độ dài của dãy dấu ngoặc đơn hợp lệ dài nhất kết thúc tại mỗi vị trí."
}