{
  "id": "35-search-insert-position",
  "title": "Search Insert Position",
  "difficulty": "Easy",
  "acceptance": 0.43,
  "tags": [
    "array",
    "binary-search"
  ],
  "constraints": [
    "1 <= nums.length <= 10^4",
    "-10^4 <= nums[i] <= 10^4",
    "nums chứa các phần tử đã được sắp xếp theo thứ tự tăng dần.",
    "Không có phần tử trùng lặp trong mảng."
  ],
  "description": "Cho một mảng số nguyên đã được sắp xếp theo thứ tự tăng dần và một số nguyên target, hãy tìm vị trí mà target nên được chèn vào để duy trì thứ tự tăng dần của mảng.",
  "defaultCode": {
    "cpp": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        \n    }\n};",
    "java": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        \n    }\n}",
    "python": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        ",
    "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    \n};"
  },
  "driverCodes": {
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// __USER_CODE_HERE__\n\nint main() {\n    int n, target;\n    cin >> n;\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) cin >> nums[i];\n    cin >> target;\n    Solution sol;\n    cout << sol.searchInsert(nums, target);\n    return 0;\n}",
    "python": "import sys\nfrom typing import List\n\n# __USER_CODE_HERE__\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().splitlines()\n    if len(input_data) < 2: sys.exit(0)\n    n = len(input_data[0].split())\n    nums = list(map(int, input_data[0].split()))\n    target = int(input_data[1])\n    sol = Solution()\n    print(sol.searchInsert(nums, target))",
    "java": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNextLine()) return;\n        String[] parts = sc.nextLine().split(\"\\\\s+\");\n        int[] nums = new int[parts.length];\n        for (int i = 0; i < parts.length; i++) nums[i] = Integer.parseInt(parts[i]);\n        if (!sc.hasNextInt()) return;\n        int target = sc.nextInt();\n        \n        Solution sol = new Solution();\n        System.out.print(sol.searchInsert(nums, target));\n    }\n}\n\n// __USER_CODE_HERE__",
    "javascript": "const fs = require('fs');\n\n// Định nghĩa một class rỗng để tránh lỗi ReferenceError nếu người dùng không dùng class\nclass Solution {}\n\n// __USER_CODE_HERE__\n\ntry {\n    const input = fs.readFileSync(0, 'utf8').split('\\n');\n    if (input.length < 2) process.exit(0);\n\n    const nums = input[0].trim().split(/\\s+/).map(Number);\n    const target = parseInt(input[1]);\n\n    const sol = new Solution();\n    // Kiểm tra xem hàm searchInsert nằm ở global (var/function) hay nằm trong class Solution\n    const fn = (typeof searchInsert === 'function') ? searchInsert : (sol.searchInsert ? sol.searchInsert.bind(sol) : null);\n\n    if (typeof fn === 'function') {\n        const res = fn(nums, target);\n        process.stdout.write(res.toString());\n    } else {\n        console.error(\"Error: function searchInsert not found.\");\n    }\n} catch (e) {\n    console.error(e);\n}"
  },
  "testCases": [
    {
      "input": "1 3 5 6\n5",
      "expected": "2",
      "isHidden": false
    },
    {
      "input": "1 3 5 6\n2",
      "expected": "1",
      "isHidden": false
    },
    {
      "input": "1 3 5 6\n7",
      "expected": "4",
      "isHidden": true
    }
  ],
  "examples": [
    {
      "input": "nums = [1,3,5,6], target = 5",
      "output": "2",
      "explanation": "Vì 5 đã có trong mảng tại vị trí thứ 2 (chỉ số 0-based), nên trả về 2."
    },
    {
      "input": "nums = [1,3,5,6], target = 2",
      "output": "1",
      "explanation": "Vì 2 không có trong mảng, và nó cần được chèn vào giữa 1 và 3 để duy trì thứ tự tăng dần, nên trả về 1."
    },
    {
      "input": "nums = [1,3,5,6], target = 7",
      "output": "4",
      "explanation": "Vì 7 không có trong mảng, và nó cần được chèn vào cuối mảng để duy trì thứ tự tăng dần, nên trả về 4."
    }
  ],
  "editorial": {
    "approaches": [
      {
        "name": "Binary Search",
        "description": "Sử dụng thuật toán tìm kiếm nhị phân để tìm vị trí mà target nên được chèn vào.",
        "timeComplexity": "$O(log n)$",
        "spaceComplexity": "$O(1)$",
        "code": {
          "cpp": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        return left;\n    }\n};",
          "python": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left",
          "javascript": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n        if (nums[mid] === target) return mid;\n        else if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n};",
          "java": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        return left;\n    }\n}"
        }
      }
    ],
    "videoUrl": "https://youtube.com/watch?v=K-RYzDZkzCI",
    "content": "Bài toán này có thể được giải quyết bằng cách sử dụng thuật toán tìm kiếm nhị phân. Ý tưởng là tìm vị trí mà target nên được chèn vào để duy trì thứ tự tăng dần của mảng."
  }
}