{
  "id": "37-sudoku-solver",
  "title": "Sudoku Solver",
  "difficulty": "Hard",
  "acceptance": 0.35,
  "tags": [
    "array",
    "backtracking"
  ],
  "constraints": [
    "Mảng đầu vào là một lưới 9x9.",
    "Các giá trị trong lưới là số nguyên từ 0 đến 9.",
    "0 đại diện cho ô trống.",
    "Đảm bảo có một và chỉ một giải pháp hợp lệ."
  ],
  "description": "Viết một hàm để giải quyết một bảng Sudoku. Hàm này sẽ nhận vào một bảng Sudoku dưới dạng mảng 2 chiều và trả về bảng đã được giải quyết.",
  "defaultCode": {
    "cpp": "class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        \n    }\n};",
    "java": "class Solution {\n    public void solveSudoku(char[][] board) {\n        \n    }\n}",
    "python": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        ",
    "javascript": "/**\n * @param {character[][]} board\n * @return {void}\n */\nvar solveSudoku = function(board) {\n    \n};"
  },
  "driverCodes": {
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// __USER_CODE_HERE__\n\nint main() {\n    vector<vector<char>> board(9, vector<char>(9));\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            cin >> board[i][j];\n        }\n    }\n    Solution sol;\n    sol.solveSudoku(board);\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            cout << board[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "python": "import sys\nfrom typing import List\n\n# __USER_CODE_HERE__\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().splitlines()\n    board = [list(line) for line in input_data]\n    sol = Solution()\n    sol.solveSudoku(board)\n    for row in board:\n        print(' '.join(row))",
    "java": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[][] board = new char[9][9];\n        for (int i = 0; i < 9; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 9; j++) {\n                board[i][j] = line.charAt(j);\n            }\n        }\n        \n        Solution sol = new Solution();\n        sol.solveSudoku(board);\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                System.out.print(board[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n\n// __USER_CODE_HERE__",
    "javascript": "const fs = require('fs');\n\n// Định nghĩa một class rỗng để tránh lỗi ReferenceError nếu người dùng không dùng class\nconst Solution = {};\n\n// __USER_CODE_HERE__\n\ntry {\n    const input = fs.readFileSync(0, 'utf8').split('\\n');\n    const board = input.map(line => line.trim().split(''));\n    const sol = new Solution();\n    // Kiểm tra xem hàm solveSudoku nằm ở global (var/function) hay nằm trong class Solution\n    const fn = (typeof solveSudoku === 'function') ? solveSudoku : (sol.solveSudoku ? sol.solveSudoku.bind(sol) : null);\n\n    if (typeof fn === 'function') {\n        fn(board);\n        console.log(board.map(row => row.join(' ')).join('\\n'));\n    } else {\n        console.error(\"Error: function solveSudoku not found.\");\n    }\n} catch (e) {\n    console.error(e);\n}"
  },
  "testCases": [
    {
      "input": "5...3....\\n6..4..8..\\n....8.9.5\\n8...6...3\\n4..8.3..1\\n7...2...6\\n....6...8\\n...5.4..7\\n...3.2...9",
      "expected": "534678912\\n672195348\\n198342567\\n859761423\\n426853791\\n713924856\\n961537284\\n337498125\\n285671934",
      "isHidden": false
    },
    {
      "input": "...9...5.\\n6...1...3\\n...8...6.\\n8...3...9\\n4..7...1\\n.2...5...8\\n..3...9.8\\n...1...4.\\n7...6...3",
      "expected": "519748632\\n628135497\\n473962158\\n896354721\\n214783956\\n937516284\\n168429753\\n735189426\\n542687139",
      "isHidden": false
    }
  ],
  "examples": [
    {
      "input": "board = [\n    [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n    ,[\n    \"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n    ,[\n    \".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n    ,[\n    \"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n    ,[\n    \"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n    ,[\n    \"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n    ,[\n    \".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n    ,[\n    \".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n    ,[\n    \".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\n",
      "output": "[\n    [\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"]\n    ,[\n    \"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"]\n    ,[\n    \"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"]\n    ,[\n    \"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"]\n    ,[\n    \"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"]\n    ,[\n    \"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"]\n    ,[\n    \"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"]\n    ,[\n    \"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"]\n    ,[\n    \"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]\n]\n",
      "explanation": "Giải pháp này điền các số từ 1 đến 9 vào các ô trống sao cho mỗi hàng, cột và khối 3x3 chứa mỗi số chỉ một lần."
    }
  ],
  "editorial": {
    "approaches": [
      {
        "name": "Backtracking (Đệ quy)",
        "description": "Sử dụng kỹ thuật backtracking để điền các số từ 1 đến 9 vào các ô trống. Nếu một số không hợp lệ, quay lui và thử số tiếp theo.",
        "timeComplexity": "$O(9^{n})$ - Trong trường hợp xấu nhất, phải thử tất cả các số cho mỗi ô trống.",
        "spaceComplexity": "$O(n)$ - Không gian cần thiết cho việc gọi đệ quy.",
        "code": {
          "cpp": "class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n    bool solve(vector<vector<char>>& board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') {\n                    for (char c = '1'; c <= '9'; c++) {\n                        if (isValid(board, i, j, c)) {\n                            board[i][j] = c;\n                            if (solve(board)) return true;\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    bool isValid(vector<vector<char>>& board, int row, int col, char c) {\n        // Kiểm tra hàng và cột\n        for (int i = 0; i < 9; i++) {\n            if (board[row][i] == c || board[i][col] == c) return false;\n        }\n        // Kiểm tra khối 3x3\n        int startRow = row - row % 3, startCol = col - col % 3;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (board[i + startRow][j + startCol] == c) return false;\n            }\n        }\n        return true;\n    }\n};",
          "python": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        self.board = board\n        self.solve()\n    def solve(self) -> bool:\n        for i in range(9):\n            for j in range(9):\n                if self.board[i][j] == '.':\n                    for c in '123456789':\n                        if self.isValid(i, j, c):\n                            self.board[i][j] = c\n                            if self.solve(): return True\n                            self.board[i][j] = '.'\n                    return False\n        return True\n    def isValid(self, row: int, col: int, c: str) -> bool:\n        # Kiểm tra hàng và cột\n        for i in range(9):\n            if self.board[row][i] == c or self.board[i][col] == c: return False\n        # Kiểm tra khối 3x3\n        startRow, startCol = row - row % 3, col - col % 3\n        for i in range(3):\n            for j in range(3):\n                if self.board[i + startRow][j + startCol] == c: return False\n        return True",
          "javascript": "/**\n * @param {character[][]} board\n * @return {void}\n */\nvar solveSudoku = function(board) {\n    function solve() {\n        for (let i = 0; i < 9; i++) {\n            for (let j = 0; j < 9; j++) {\n                if (board[i][j] === '.') {\n                    for (let c = '1'; c <= '9'; c++) {\n                        if (isValid(i, j, c)) {\n                            board[i][j] = c;\n                            if (solve()) return true;\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    function isValid(row, col, c) {\n        // Kiểm tra hàng và cột\n        for (let i = 0; i < 9; i++) {\n            if (board[row][i] === c || board[i][col] === c) return false;\n        }\n        // Kiểm tra khối 3x3\n        let startRow = row - row % 3, startCol = col - col % 3;\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 3; j++) {\n                if (board[i + startRow][j + startCol] === c) return false;\n            }\n        }\n        return true;\n    }\n    solve();\n};",
          "java": "class Solution {\n    public void solveSudoku(char[][] board) {\n        solve(board);\n    }\n    public boolean solve(char[][] board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') {\n                    for (char c = '1'; c <= '9'; c++) {\n                        if (isValid(board, i, j, c)) {\n                            board[i][j] = c;\n                            if (solve(board)) return true;\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    public boolean isValid(char[][] board, int row, int col, char c) {\n        // Kiểm tra hàng và cột\n        for (int i = 0; i < 9; i++) {\n            if (board[row][i] == c || board[i][col] == c) return false;\n        }\n        // Kiểm tra khối 3x3\n        int startRow = row - row % 3, startCol = col - col % 3;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (board[i + startRow][j + startCol] == c) return false;\n            }\n        }\n        return true;\n    }\n}"
        }
      }
    ],
    "videoUrl": "https://youtube.com/watch?v=eAFcj_2quWI",
    "content": "Bài toán này yêu cầu giải quyết một bảng Sudoku bằng cách điền các số từ 1 đến 9 vào các ô trống sao cho mỗi hàng, cột và khối 3x3 chứa mỗi số chỉ một lần. Kỹ thuật backtracking là phù hợp cho bài toán này."
  }
}