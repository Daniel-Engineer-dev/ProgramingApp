{
  "id": "40-combination-sum-ii",
  "title": "Combination Sum II",
  "difficulty": "Medium",
  "acceptance": 0.42,
  "tags": [
    "array",
    "backtracking"
  ],
  "constraints": [
    "1 <= candidates.length <= 100",
    "1 <= candidates[i] <= 100",
    "Mỗi phần tử trong candidates là duy nhất.",
    "Tổng của mỗi kết hợp không vượt quá 1000."
  ],
  "description": "Cho một mảng số nguyên không giảm candidates và một số nguyên target, hãy tìm tất cả các kết hợp duy nhất trong candidates mà tổng của chúng bằng target. Mỗi số trong candidates chỉ có thể được sử dụng một lần trong mỗi kết hợp.",
  "defaultCode": {
    "cpp": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        \n    }\n};",
    "java": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        \n    }\n}",
    "python": "from typing import List\n\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ",
    "javascript": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    \n};"
  },
  "driverCodes": {
    "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\n// __USER_CODE_HERE__\n\nint main() {\n    string line;\n    if (!getline(cin, line)) return 0;\n    stringstream ss(line);\n    vector<int> candidates;\n    int n;\n    while (ss >> n) candidates.push_back(n);\n    if (!(cin >> n)) return 0;\n    int target = n;\n    Solution sol;\n    vector<vector<int>> res = sol.combinationSum2(candidates, target);\n    for (auto& vec : res) {\n        for (int num : vec) cout << num << \" \";\n        cout << endl;\n    }\n    return 0;\n}",
    "python": "import sys\nfrom typing import List\n\n# # __USER_CODE_HERE__\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().splitlines()\n    if len(input_data) < 2: sys.exit(0)\n    candidates = list(map(int, input_data[0].split()))\n    target = int(input_data[1])\n    sol = Solution()\n    res = sol.combinationSum2(candidates, target)\n    for vec in res:\n        print(' '.join(map(str, vec)))",
    "java": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (!sc.hasNextLine()) return;\n        String[] parts = sc.nextLine().split(\"\\\\s+\");\n        int[] candidates = new int[parts.length];\n        for (int i = 0; i < parts.length; i++) candidates[i] = Integer.parseInt(parts[i]);\n        if (!sc.hasNextInt()) return;\n        int target = sc.nextInt();\n        \n        Solution sol = new Solution();\n        List<List<Integer>> res = sol.combinationSum2(candidates, target);\n        for (List<Integer> vec : res) {\n            for (Integer num : vec) System.out.print(num + \" \");\n            System.out.println();\n        }\n    }\n}\n\n// __USER_CODE_HERE__",
    "javascript": "const fs = require('fs');\n\n// Định nghĩa một class rỗng để tránh lỗi ReferenceError nếu người dùng không dùng class\nconst Solution = {};\n\n// __USER_CODE_HERE__\n\ntry {\n    const input = fs.readFileSync(0, 'utf8').split('\\n');\n    if (input.length < 2) process.exit(0);\n\n    const candidates = input[0].trim().split(/\\s+/).map(Number);\n    const target = parseInt(input[1]);\n\n    const sol = new Solution();\n    // Kiểm tra xem hàm combinationSum2 nằm ở global (var/function) hay nằm trong class Solution\n    const fn = (typeof combinationSum2 === 'function') ? combinationSum2 : (sol.combinationSum2 ? sol.combinationSum2.bind(sol) : null);\n\n    if (typeof fn === 'function') {\n        const res = fn(candidates, target);\n        if (Array.isArray(res)) {\n            res.forEach(vec => process.stdout.write(vec.join(' ') + '\\n'));\n        }\n    } else {\n        console.error(\"Error: function combinationSum2 not found.\");\n    }\n} catch (e) {\n    console.error(e);\n}"
  },
  "testCases": [
    {
      "input": "10 1 2 7 6 1 5\n8",
      "expected": "[[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]",
      "isHidden": false
    },
    {
      "input": "2 5 2 1 2\n5",
      "expected": "[[1,2,2], [5]]",
      "isHidden": false
    },
    {
      "input": "1\n1",
      "expected": "[[1]]",
      "isHidden": true
    }
  ],
  "examples": [
    {
      "input": "candidates = [10,1,2,7,6,1,5], target = 8",
      "output": "[[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]",
      "explanation": "Các kết hợp duy nhất có tổng bằng 8 là [1,1,6], [1,2,5], [1,7], và [2,6]."
    },
    {
      "input": "candidates = [2,5,2,1,2], target = 5",
      "output": "[[1,2,2], [5]]",
      "explanation": "Các kết hợp duy nhất có tổng bằng 5 là [1,2,2] và [5]."
    },
    {
      "input": "candidates = [1], target = 1",
      "output": "[[1]]",
      "explanation": "Chỉ có một kết hợp duy nhất có tổng bằng 1 là [1]."
    }
  ],
  "editorial": {
    "approaches": [
      {
        "name": "Sử dụng thuật toán Backtracking",
        "description": "Sử dụng một hàm đệ quy để thử tất cả các kết hợp có thể. Tránh lặp lại các kết hợp bằng cách sắp xếp mảng candidates và bỏ qua các phần tử trùng lặp.",
        "timeComplexity": "$O(2^n)$ - Trong trường hợp xấu nhất, chúng ta phải thử tất cả các kết hợp có thể.",
        "spaceComplexity": "$O(n)$ - Độ sâu của ngăn xếp gọi hàm.",
        "code": {
          "cpp": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<vector<int>> res;\n        sort(candidates.begin(), candidates.end());\n        vector<int> path;\n        backtrack(res, path, candidates, target, 0);\n        return res;\n    }\n    void backtrack(vector<vector<int>>& res, vector<int>& path, vector<int>& candidates, int target, int start) {\n        if (target < 0) return;\n        if (target == 0) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = start; i < candidates.size(); i++) {\n            if (i > start && candidates[i] == candidates[i-1]) continue;\n            path.push_back(candidates[i]);\n            backtrack(res, path, candidates, target-candidates[i], i+1);\n            path.pop_back();\n        }\n    }\n};",
          "python": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        candidates.sort()\n        self.backtrack(res, [], candidates, target, 0)\n        return res\n    def backtrack(self, res, path, candidates, target, start):\n        if target < 0: return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]: continue\n            self.backtrack(res, path + [candidates[i]], candidates, target - candidates[i], i + 1)",
          "javascript": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    const res = [];\n    candidates.sort((a, b) => a - b);\n    const backtrack = (path, start) => {\n        if (target < 0) return;\n        if (target === 0) {\n            res.push([...path]);\n            return;\n        }\n        for (let i = start; i < candidates.length; i++) {\n            if (i > start && candidates[i] === candidates[i-1]) continue;\n            path.push(candidates[i]);\n            backtrack(path, i + 1);\n            path.pop();\n        }\n    };\n    backtrack([], 0);\n    return res;\n};",
          "java": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(candidates);\n        backtrack(res, new ArrayList<>(), candidates, target, 0);\n        return res;\n    }\n    private void backtrack(List<List<Integer>> res, List<Integer> path, int[] candidates, int target, int start) {\n        if (target < 0) return;\n        if (target == 0) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = start; i < candidates.length; i++) {\n            if (i > start && candidates[i] == candidates[i-1]) continue;\n            path.add(candidates[i]);\n            backtrack(res, path, candidates, target - candidates[i], i + 1);\n            path.remove(path.size() - 1);\n        }\n    }\n}"
        }
      }
    ],
    "videoUrl": "https://youtube.com/watch?v=FOyRpNUSFeA",
    "content": "Bài toán này yêu cầu tìm tất cả các kết hợp duy nhất trong mảng candidates mà tổng của chúng bằng target. Mỗi số trong candidates chỉ có thể được sử dụng một lần trong mỗi kết hợp."
  }
}